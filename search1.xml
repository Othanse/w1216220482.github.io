<?xml version="1.0" encoding="UTF-8"?>
<urlset>
	 
	 
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/10/%E8%BD%AC-%E5%85%B3%E4%BA%8EANT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]关于ANT的一些总结]]></title>
                <content><![CDATA[<p>使用ant好久了，但是说实话基本对ANT立面的属性什么的都很不熟悉，其实就是个用，其余的啥也不知道。</p>
<p>project、target、task等等的很多的属性其实都不知道是干什么用的，最近闲下来了需要好好研究研究这玩意也算是个技术储备。</p>
<a id="more"></a>
<p>ant 是apache 工程的一个子工程，是一个基于java的build工具。ant类似于make工具，但没有传统的make工具的缺点。</p>
<p>传统的make往往只能限制在某一平台上使用，ant本身用java类实现，要构建的工程的配置文件用<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=xml%E6%A0%BC%E5%BC%8F" target="_blank" rel="external">xml格式</a>描述，可以很方便实现多平台编译,非常适合build大型工程。</p>
<p>首先我们知道ant构建的形式是<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=xml" target="_blank" rel="external">xml</a>文件格式，一般的文件名称都是build.xml，</p>
<h3 id="1-&lt;project&gt;标签">1.&lt;project&gt;标签</h3><p> peoject ：是构建文件的跟标签，</p>
<p>&lt;project default=”main” basedir=”.” name=”ruyicai_android” &gt;—&gt;这个是我自己项目的project</p>
<p>就如代码中所示，其各个属性的含义分别如下。&nbsp;<br>(1) default表示默认的运行目标，这个属性是必须的。&nbsp;<br>(2) basedir表示项目的基准目录。就是表示工程基路径，如果设置成”.”则表示build.xml文件的所在路径。<br>(3) name表示项目名。&nbsp;<br>(4)&nbsp;<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=description" target="_blank" rel="external">description</a>表示项目的描述。&nbsp;<br>每个构建文件都对应于一个项目，但是大型项目经常包含大量的子项目，每一个子项目都可以有&nbsp;<br>自己的构建文件。</p>
<h3 id="2-&lt;target&gt;标签">2.&lt;target&gt;标签</h3><p>&lt;target name=”init”&gt;—&gt;这个是我自己项目的target</p>
<p>一个项目标签下可以有一个或多个target标签。一个target标签可以依赖其他的target标签。例&nbsp;<br>如，有一个target用于<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">编译程序</a>，另一个target用于声称可执行文件。在生成可执行文件之前必&nbsp;<br>须先编译该文件，因策可执行文件的target依赖于编译程序的target。Target的所有属性如下。&nbsp;<br>(1).name表示标明，这个属性是必须的。&nbsp;<br>(2).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=depends" target="_blank" rel="external">depends</a>表示依赖的目标。&nbsp;<br>(3)if表示仅当属性设置时才执行。&nbsp;<br>(4)unless表示当属性没有设置时才执行。&nbsp;<br>(5)description表示项目的描述。&nbsp;<br>Ant的depends属性指定了target的执行顺序。Ant会依照depends属性中target出现顺序依次执行&nbsp;<br>每个target。在执行之前，首先需要执行它所依赖的target。</p>
<p>Z.B：</p>
<p>&lt;target name=”run” depends=”complie”&gt;</p>
<p>&lt;target name=”complie” depends=”prepare”&gt;</p>
<p>&lt;target name=”prepare”&gt;</p>
<p>程序中的名为run的target的&nbsp;<br>depends属性compile，而名为compile的target的depends属性是prepare，所以这几个target执&nbsp;<br>行的顺序是prepare-&gt;compile-&gt;run。&nbsp;<br>一个target只能被执行一次，即使有多个target依赖于它。如果没有if或unless属性，target总&nbsp;<br>会被执行。</p>
<h3 id="3-&lt;mkdir&gt;标签">3.&lt;mkdir&gt;标签</h3><p>该标签用于创建一个目录，它有一个属性dir用来指定所创建的目录名，其代码如下：&nbsp;<br>&lt;mkdir dir=”out”/&gt;&nbsp;<br>通过以上代码就创建了一个目录，这个目录已经被前面的property标签所指定。</p>
<h3 id="4&lt;jar&gt;标签">4&lt;jar&gt;标签</h3><p>该标签用来生成一个<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=JAR" target="_blank" rel="external">JAR</a>文件，其属性如下。&nbsp;<br>(1) destfile表示JAR文件名。&nbsp;<br>(2) basedir表示被归档的文件名。&nbsp;<br>(3)&nbsp;<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=include" target="_blank" rel="external">include</a>s表示别归档的<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">文件模式</a>。&nbsp;<br>(4) exchudes表示被排除的文件模式。</p>
<h3 id="5．&lt;javac标签&gt;">5．&lt;javac标签&gt;</h3><p>该标签用于编译一个或一组java文件，其属性如下。&nbsp;<br>(1).srcdir表示<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E6%BA%90%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">源程序</a>的目录。&nbsp;<br>(2).destdir表示<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=class%E6%96%87%E4%BB%B6" target="_blank" rel="external">class文件</a>的输出目录。&nbsp;<br>(3).include表示被编译的文件的模式。&nbsp;<br>(4).excludes表示被排除的文件的模式。&nbsp;<br>(5).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=classpath" target="_blank" rel="external">classpath</a>表示所使用的类路径。&nbsp;<br>(6).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=debug" target="_blank" rel="external">debug</a>表示包含的调试信息。&nbsp;<br>(7).optimize表示是否使用优化。&nbsp;<br>(8).verbose 表示提供详细的输出信息。&nbsp;<br>(9).fileonerror表示当碰到错误就自动停止。</p>
<h3 id="6．&lt;java&gt;标签">6．&lt;java&gt;标签</h3><p>该标签用来执行编译生成的.class文件，其属性如下。&nbsp;<br>(1).classname 表示将执行的类名。&nbsp;<br>(2).jar表示包含该类的JAR文件名。&nbsp;<br>(3).classpath所表示用到的类路径。&nbsp;<br>(4).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=fork" target="_blank" rel="external">fork</a>表示在一个新的<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">虚拟机</a>中运行该类。&nbsp;<br>(5).failonerror表示当出现错误时自动停止。&nbsp;<br>(6).output 表示输出文件。&nbsp;<br>(7).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=append" target="_blank" rel="external">append</a>表示追加或者覆盖默认文件。</p>
<h3 id="7-&lt;delete&gt;标签">7.&lt;delete&gt;标签</h3><p>该标签用于删除一个文件或一组文件，去属性如下。&nbsp;<br>(1)/file表示要删除的文件。&nbsp;<br>(2).dir表示要删除的目录。&nbsp;<br>(3).includeEmptyDirs 表示指定是否要删除空目录，默认值是删除。&nbsp;<br>(4).failonerror 表示指定当碰到错误是否停止，默认值是自动停止。&nbsp;<br>(5).verbose表示指定是否列出所删除的文件，默认值为不列出。</p>
<h3 id="8-&lt;copy&gt;标签">8.&lt;copy&gt;标签</h3><p>该标签用于文件或文件集的拷贝，其属性如下。<br>(1).file 表示源文件。<br>(2).tofile 表示<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6" target="_blank" rel="external">目标文件</a>。<br>(3).todir 表示目标目录。&nbsp;<br>(4).overwrite 表示指定是否覆盖目标文件，默认值是不覆盖。&nbsp;<br>(5).includeEmptyDirs 表示制定是否拷贝空目录，默认值为拷贝。&nbsp;<br>(6).failonerror 表示指定如目标没有发现是否自动停止，默认值是停止。<br>(7).verbose 表示制定是否显示详细信息，默认值不显示。</p>
<h3 id="9-&lt;exec&gt;执行文件：">9<strong>.&lt;exec&gt;执行文件</strong>：</h3><p>&lt;property name=”<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=aapt" target="_blank" rel="external">aapt</a>“ value=”E:\Android TOOL\android-sdk-windows\platform-tools\aapt.exe”/&gt;<font color="#ff0000" style="margin: 0px; padding: 0px;">&nbsp;<br></font>&lt;exec executable=”${aapt}” &gt;</p>
<p>&lt;/exec&gt;</p>
<h3 id="10-&lt;property&gt;标签：">10.&lt;property&gt;标签：</h3><p>property任务用来设置属性，一个工程可以设置很多属性，属性有名字和值，属性设置后可以在后面引用。<br>&lt;property name=”aapt” value=”E:\Android TOOL\android-sdk-windows\platform-tools\aapt.exe”/&gt;<font color="#ff0000" style="margin: 0px; padding: 0px;">&nbsp;<br></font></p>
<p>设置一个名字为aapt，它的值是一个路径用value来设置这里写的是绝对路径（可以写相对路径但是还不会）。</p>
<p>当然也可以使用location这个值来设定路径&nbsp;<br>&lt;property name=”aapt” location=”E:\Android TOOL\android-sdk-windows\platform-tools\aapt.exe”/&gt;</p>
<p>在网上找的结果是value可以设定相对路径，但是在平台间必须转换“\”和”/”。</p>
<p>使用location则不需要，但是必须是绝对路径。</p>
<p>Ant的 location属性专门设计用于以平台无关的方式包含文件系统路径。所以应该用location来代&nbsp;<br>替value,此时用/或是\都会在不同的平台转换为正确的分隔符</p>
<p>用我自己的项目中的代码来说明下：</p>
<p>&lt;property name=”apk-name” value=”ruyicai” /&gt;这里的apk-name是我以后创建的文件夹的名称和生成的apk文件名的一部分，这样写是没有问题的在其他地方引用—&gt;${apk-name}就OK了。</p>
<p>但是如果&lt;property name=”apk-name” location=”ruyicai” /&gt;会报出如下的错误。</p>
<p>[echo] start initing …</p>
<p>BUILD FAILED&nbsp;<br>E:\workspace\ruyicai_android_2.4\build.xml:30: Directory E:\workspace\ruyicai_android_2.4\build\E:\workspace\ruyicai_android_2.4\ruyicai creation was not successful for an unknown reason</p>
<p>Total time: 0 seconds&nbsp;<br>这是我第三十行的&nbsp; &lt;mkdir dir=”build/${apk-name}” /&gt;</p>
<p>明显如果使用location那么就会去寻找当前项目绝对路径下的ruyicai文件夹。</p>
<p>那么就有一个问题这里为什么是这个路径？</p>
<p>E:\workspace\ruyicai_android_2.4\</p>
<p>很明显是根据project中的basedir的属性有关系，上面说过了如果basedir的属性是“.”表示build.xml的路径，而builid.xml的路径正好是E:\workspace\ruyicai_android_2.4\这个路径。</p>
<p>OK先总结这些，总的来说ant没有那么难，但是也绝对不是那么简单需要下一番功夫的</p>
<p>转自： <a href="http://www.fx114.net/qa-186-78040.aspx" target="_blank" rel="external">http://www.fx114.net/qa-186-78040.aspx</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/10/%E8%BD%AC-%E5%85%B3%E4%BA%8EAndroid%E6%89%93%E5%8C%85%E9%82%A3%E4%BA%9B%E4%BA%8B/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]关于Android打包那些事]]></title>
                <content><![CDATA[<p>使用gradle打包apk已经成为当前主流趋势，我也在这个过程中经历了各种需求，并不断结合gradle新的支持，一一改进。在此，把这些相关的东西记录，做一总结。</p>
<a id="more"></a>
<h2 id="1-_替换AndroidManifest中的占位符">1. 替换AndroidManifest中的占位符</h2><p>我想把其中的${app_label}替换为@string/app_name</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    defaultConfig&#123;</span><br><span class="line">        manifestPlaceholders = [app_label:<span class="string">"@string/app_name"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只想替换debug版本：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">	          manifestPlaceholders = [app_label:<span class="string">"@string/app_name_debug"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的需求是替换渠道编号：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        // 把dev产品型号的apk的AndroidManifest中的channel替换dev</span><br><span class="line">        <span class="string">"dev"</span>&#123;</span><br><span class="line">            manifestPlaceholders = [channel:<span class="string">"dev"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_独立配置签名信息">2. 独立配置签名信息</h2><p>对于签名相关的信息,直接写在gradle当然不好,特别是一些开源项目，可以添加到gradle.properties:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">RELEASE_KEY_PASSWORD=<span class="value">xxxx</span></span></span><br><span class="line"><span class="setting">RELEASE_KEY_ALIAS=<span class="value">xxx</span></span></span><br><span class="line"><span class="setting">RELEASE_STORE_PASSWORD=<span class="value">xxx</span></span></span><br><span class="line"><span class="setting">RELEASE_STORE_FILE=<span class="value">../.keystore/xxx.jks</span></span></span><br></pre></td></tr></table></figure>
<p>然后在build.gradle中引用即可：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">signingConfigs</span> &#123;</span><br><span class="line">        <span class="title">release</span> &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不想提交到版本库，可以添加到local.properties中，然后在build.gradle中读取。</p>
<h2 id="3-_多渠道打包">3. 多渠道打包</h2><p>多渠道打包的关键之处在于，定义不同的product flavor, 并把AndroiManifest中的channel渠道编号替换为对应的flavor标识：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"dev"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        official&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"official"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        wandoujia&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"wandoujia"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"xiaomi"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"360"</span>&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意一点，这里的flavor名如果是数字开头，必须用引号引起来。<br>构建一下，就能生成一系列的Build Variant了:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devDebug</span><br><span class="line">devRelease</span><br><span class="line">officialDebug</span><br><span class="line">officialRelease</span><br><span class="line">wandoujiaDebug</span><br><span class="line">wandoujiaRelease</span><br><span class="line">xiaomiDebug</span><br><span class="line">xiaomiRelease</span><br><span class="line"><span class="number">360</span>Debug</span><br><span class="line"><span class="number">360</span>Release</span><br></pre></td></tr></table></figure></p>
<p>其中debug, release是gradle默认自带的两个build type, 下一节还会继续说明。<br>选择一个，就能编译出对应渠道的apk了。</p>
<h2 id="4-_自定义Build_Type">4. 自定义Build Type</h2><p>前面说到默认的build type有两种debug和release，区别如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release版本生成的BuildConfig特性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"release"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// debug版本生成的BuildConfig特性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"debug"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在有一种需求，增加一种build type，介于debug和release之间，就是和release版本一样，但是要保留debug状态（如果做过rom开发的话，类似于user debug版本），我们称为preview版本吧。<br>其实很简单：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">signingConfigs</span> &#123;</span><br><span class="line">        <span class="title">debug</span> &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        preview &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        <span class="title">debug</span> &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_debug"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        preview&#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_preview"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，build type还有一个好处，如果想要一次性生成所有的preview版本，执行assemblePreview即可，debug和releae版本同理。</p>
<h2 id="5-_build_type中的定制参数">5. build type中的定制参数</h2><p>上面我们在不同的build type替换${app_label}为不同的字符串，这样安装到手机上就能明显的区分出不同build type的版本。<br>除此之外，可能还可以配置一些参数，我这里列几个我在工作中用到的：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">        <span class="title">debug</span> &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_debug"</span>]</span><br><span class="line">            applicationIdSuffix <span class="string">".debug"</span></span><br><span class="line">            minifyEnabled <span class="built_in">false</span></span><br><span class="line">            signingConfig signingConfigs.<span class="built_in">debug</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name"</span>]</span><br><span class="line">            minifyEnabled <span class="built_in">true</span></span><br><span class="line">            shrinkResources <span class="built_in">true</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">        preview&#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_preview"</span>]</span><br><span class="line">            applicationIdSuffix <span class="string">".preview"</span></span><br><span class="line">            debuggable <span class="built_in">true</span> // 保留<span class="built_in">debug</span>信息</span><br><span class="line">            minifyEnabled <span class="built_in">true</span></span><br><span class="line">            shrinkResources <span class="built_in">true</span></span><br><span class="line">            signingConfig signingConfigs.preview</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些都用的太多了，稍微解释一下：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minifyEnabled 混淆处理</span></span><br><span class="line"><span class="comment">// shrinkResources 去除无用资源</span></span><br><span class="line"><span class="comment">// signingConfig 签名</span></span><br><span class="line"><span class="comment">// proguardFiles 混淆配置</span></span><br><span class="line"><span class="comment">// applicationIdSuffix 增加APP ID的后缀</span></span><br><span class="line"><span class="comment">// debuggable 是否保留调试信息</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-_多工程全局配置">6. 多工程全局配置</h2><p>随着产品渠道的铺开，往往一套代码需要支持多个产品形态，这就需要抽象出主要代码到一个Library，然后基于Library扩展几个App Module。<br>相信每个module的build.gradle都会有这个代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">22</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">10</span></span><br><span class="line">        targetSdkVersion <span class="number">22</span></span><br><span class="line">        versionCode <span class="number">34</span></span><br><span class="line">        versionName <span class="string">"v2.6.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当升级sdk、build tool、target sdk等，几个module都要更改，非常的麻烦。最重要的是，很容易忘记，最终导致app module之间的差异不统一，也不可控。<br>强大的gradle插件在1.1.0支持全局变量设定，一举解决了这个问题。<br>先在project的根目录下的build.gradle定义ext全局变量:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = <span class="number">22</span></span><br><span class="line">    buildToolsVersion = <span class="string">"23.0.1"</span></span><br><span class="line">    minSdkVersion = <span class="number">10</span></span><br><span class="line">    targetSdkVersion = <span class="number">22</span></span><br><span class="line">    versionCode = <span class="number">34</span></span><br><span class="line">    versionName = <span class="string">"v2.6.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在各module的build.gradle中引用如下：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">android &#123;</span><br><span class="line">    compileSdkVersion rootProject<span class="string">.ext.compileSdkVersion</span></span><br><span class="line">    buildToolsVersion rootProject<span class="string">.ext.buildToolsVersion</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId "com<span class="string">.xxx.xxx"</span></span><br><span class="line">        minSdkVersion rootProject<span class="string">.ext.minSdkVersion</span></span><br><span class="line">        targetSdkVersion rootProject<span class="string">.ext.targetSdkVersion</span></span><br><span class="line">        versionCode rootProject<span class="string">.ext.versionCode</span></span><br><span class="line">        versionName rootProject<span class="string">.ext.versionName</span></span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后每次修改project级别的build.gradle即可实现全局统一配置。</p>
<h2 id="7-_自定义导出的APK名称">7. 自定义导出的APK名称</h2><p>默认android studio生成的apk名称为app-debug.apk或者app-release.apk，当有多个渠道的时候，需要同时编出50个渠道包的时候，就麻烦了，不知道谁是谁了。<br>这个时候，就需要自定义导出的APK名称了，不同的渠道编出的APK的文件名应该是不一样的。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// rename the apk with the version name</span></span><br><span class="line">    applicationVariants<span class="built_in">.</span><span class="literal">all</span> &#123; variant <span class="subst">-&gt;</span><br><span class="line">        </span>variant<span class="built_in">.</span>outputs<span class="built_in">.</span>each &#123; output <span class="subst">-&gt;</span><br><span class="line">            </span>output<span class="built_in">.</span>outputFile = <span class="literal">new</span> File(</span><br><span class="line">                    output<span class="built_in">.</span>outputFile<span class="built_in">.</span><span class="keyword">parent</span>,</span><br><span class="line">                    <span class="string">"ganchai-$&#123;variant.buildType.name&#125;-$&#123;variant.versionName&#125;-$&#123;variant.productFlavors[0].name&#125;.apk"</span><span class="built_in">.</span>toLowerCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当apk太多时，如果能把apk按debug，release，preview分一下类就更好了（事实上，对于我这样经常发版的人，一编往往就要编四五十个版本的人，debug和release版本全混在一起没法看，必须分类），简单：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">rename</span> the apk with the version name</span><br><span class="line">    // add output file <span class="sub"><span class="keyword">sub</span> folder by build type</span><br><span class="line">    applicationVariants.all &#123;</span> variant -&gt;</span><br><span class="line">        variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">            output.outputFile = new File(</span><br><span class="line">                    output.outputFile.parent + <span class="string">"/<span class="subst">$&#123;variant.buildType.name&#125;</span>"</span>,</span><br><span class="line">                    <span class="string">"ganchai-<span class="subst">$&#123;variant.buildType.name&#125;</span>-<span class="subst">$&#123;variant.versionName&#125;</span>-<span class="subst">$&#123;variant.productFlavors[<span class="number">0</span>].name&#125;</span>.apk"</span>.toLowerCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在生成了类似于ganchai-dev-preview-v2.4.0.0.apk这样格式的包了，preview的包自然就放在preview的文件夹下，清晰明了。</p>
<h2 id="8-_混淆技巧">8. 混淆技巧</h2><p>混淆能让反编译的代码可读性变的很差，而且还能显著的减少APK包的大小。</p>
<h3 id="1)-_第一个技巧">1). 第一个技巧</h3><p>相信很多朋友对混淆都觉得麻烦，甚至说，非常乱。因为添加混淆规则需要查询官方说明文档，甚至有的官方文档还没说明。当你引用了太多库后，添加混淆规则将使一场噩梦。<br>这里介绍一个技巧，不用查官方文档，不用逐个库考虑添加规则。<br>首先，除了默认的混淆配置(android-sdk/tools/proguard/proguard-android.txt), 自己的代码肯定是要自己配置的：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 位于module下的proguard-rules.pro</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment">######</span><span class="comment">### 主程序不能混淆的代码 ###</span><span class="comment">######</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">-dontwarn xxx.model.**</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">xxx</span>.<span class="title">model</span>.** &#123; *; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 等等，自己的代码自己清楚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment">######</span><span class="comment">##### 不优化泛型和反射 ###</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">-keepattributes Signature</span><br></pre></td></tr></table></figure></p>
<p>接下来是麻烦的第三方库，一般来说，如果是极光推的话，它的包名是cn.jpush, 添加如下代码即可：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn cn.jpush.<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">-keep class cn.jpush.<span class="keyword">*</span><span class="keyword">*</span> &#123; <span class="keyword">*</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的第三库也是如此，一个一个添加，太累！其实可以用第三方反编译工具（比如jadx：<a href="https://github.com/skylot/jadx" target="_blank" rel="external">https://github.com/skylot/jadx</a>&nbsp;），打开apk后，一眼就能看到引用的所有第三方库的包名，把所有不想混淆或者不确定能不能混淆的，直接都添加又有何不可：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#####################################</span><br><span class="line">######### 第三方库或者jar包 ###########</span><br><span class="line">#####################################</span><br><span class="line"></span><br><span class="line">-<span class="ruby">dontwarn cn.jpush.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">jpush</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.squareup.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">squareup</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.octo.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">octo</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn de.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">de</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn javax.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">javax</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn u.aly.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">u</span>.<span class="title">aly</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn uk.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">uk</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.baidu.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">baidu</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.facebook.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">facebook</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.google.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">## ... ...</span><br></pre></td></tr></table></figure></p>
<h3 id="2)-_第二个技巧">2). 第二个技巧</h3><p>一般release版本混淆之后，像友盟这样的统计系统如果有崩溃异常，会记录如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.NullPointerException</span>: java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">	at com<span class="class">.xxx</span><span class="class">.TabMessageFragment</span>$<span class="number">7</span>.<span class="function"><span class="title">run</span><span class="params">(Unknown Source)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个Unknown Source是很要命的，排除错误无法定位到具体行了，大大降低调试效率。<br>当然，友盟支持上传Mapping文件，可帮助定位，mapping文件的位置在：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project &gt; <span class="class"><span class="keyword">module</span></span></span><br><span class="line">        &gt; build &gt; outputs &gt; &#123;flavor name&#125; &gt; &#123;build <span class="keyword">type</span>&#125; &gt; mapping.txt</span><br></pre></td></tr></table></figure></p>
<p>如果版本一多，mapping.txt每次都要重新生成，还要上传，终归还是麻烦。<br>其实，在proguard-rules.pro中添加如下代码即可：<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-keepattributes SourceFile,LineNumberTable</span></span><br></pre></td></tr></table></figure></p>
<p>当然apk包会大那么一点点（我这里6M的包，大个200k吧），但是再也不用mapping.txt也能定位到行了，为了这种解脱，这个代价我个人觉得是值的，而且超值！</p>
<h2 id="9-_动态设置一些额外信息">9. 动态设置一些额外信息</h2><p>假如想把当前的编译时间、编译的机器、最新的commit版本添加到apk，而这些信息又不好写在代码里，强大的gradle给了我创造可能的自信：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        resValue <span class="string">"string"</span>, <span class="string">"build_time"</span>, buildTime()</span><br><span class="line">        resValue <span class="string">"string"</span>, <span class="string">"build_host"</span>, hostName()</span><br><span class="line">        resValue <span class="string">"string"</span>, <span class="string">"build_revision"</span>, revision()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTime</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> new <span class="constant">Date</span>().format(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hostName</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="constant">System</span>.getProperty(<span class="string">"user.name"</span>) + <span class="string">"@"</span> + <span class="constant">InetAddress</span>.localHost.hostName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">revision</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">code</span> = <span class="title">new</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span></span></span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine <span class="string">'git'</span>, <span class="string">'rev-parse'</span>, <span class="string">'--short'</span>, <span class="string">'HEAD'</span></span><br><span class="line">        standardOutput = code</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码实现了动态的添加了3个字符串资源: build_time、build_host、build_revision, 然后在其他地方可像如引用字符串一样使用如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Activity里调用</span></span><br><span class="line"><span class="function"><span class="title">getString</span><span class="params">(R.string.build_time)</span></span>  <span class="comment">// 输出2015-11-07 17:01</span></span><br><span class="line"><span class="function"><span class="title">getString</span><span class="params">(R.string.build_host)</span></span>  <span class="comment">// 输出jay@deepin，这是我的电脑的用户名和PC名</span></span><br><span class="line"><span class="function"><span class="title">getString</span><span class="params">(R.string.build_revision)</span></span> <span class="comment">// 输出3dd5823, 这是最后一次commit的sha值</span></span><br></pre></td></tr></table></figure></p>
<p>这个地方，如何从命令行读取返回结果，很有意思。<br>其实这段代码来自我学习VLC源码时偶然看到，深受启发，不敢独享，特摘抄在此。<br>vlc源码及编译地址：<a href="https://wiki.videolan.org/AndroidCompile%EF%BC%8C" target="_blank" rel="external">https://wiki.videolan.org/AndroidCompile，</a>&nbsp;有兴趣可以过去一观。</p>
<h2 id="10-_给自己留个”后门”:_点七下">10. 给自己留个”后门”: 点七下</h2><p>为了调试方便，我们往往会在debug版本留一个显示我们想看的界面（记得之前微博的一个iOS版本就泄露了一个调试界面），如何进入到一个界面，我们可以仿照android开发者选项的方式，点七下才显示，我们来实现一个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> clickCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> clickTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sevenClickView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clickTime == <span class="number">0</span>) &#123;</span><br><span class="line">            clickTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - clickTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            clickCount = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clickCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        clickTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clickCount &gt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="comment">// 点七下条件达到，跳到debug界面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>release版本肯定是不能暴露这个界面的，也不能让人用am在命令行调起，如何防止呢，可以在release版本把这个debug界面的exported设为false。</p>
<h2 id="11-_自动化构建">11. 自动化构建</h2><p>如何使用jenkins打包android和ios，并上传到蒲公英平台，这个可以参考我的另外一篇文章专门介绍:&nbsp;<a href="http://www.jayfeng.com/2015/10/22/%E4%BD%BF%E7%94%A8jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E5%92%8Cios%E5%BA%94%E7%94%A8/" target="_blank" rel="external">《使用jenkins自动化构建android和ios应用》</a>，不过，这篇文章还没写完，实际上在公司里已经一直在用了，哪天心情好了总会写完的，这里不再赘述。</p>
<h2 id="12-_小结">12. 小结</h2><p>android打包因为groovy语言的强大，变的强大的同时必然也变的复杂，今天把我经历的这些门道拿出来说道一下，做一个小小的总结，后续有更新我还会添加。</p>
<p>转自：<a href="http://www.jayfeng.com/2015/11/07/Android%E6%89%93%E5%8C%85%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">Android打包的那些事</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/10/%E8%BD%AC-%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%85%B3%E6%B3%A8%E7%9A%84-so%E6%96%87%E4%BB%B6/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]你应该关注的.so文件]]></title>
                <content><![CDATA[<p><a href="http://ph0b.com/android-abis-and-so-files/" target="_blank" rel="external"><strong>原文链接</strong></a></p>
<p>早期的Android系统几乎只支持ARMv5的CPU架构，你知道现在它支持多少种吗？7种！</p>
<p>Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。</p>
<a id="more"></a>
<p>应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。</p>
<div style="padding: 0px; margin: 0px; line-height: 25.2000007629395px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; text-align: right; background-color: rgb(250, 250, 250);"><a name="_label0" style="padding: 0px; margin: 0px; color: rgb(34, 116, 155);"></a></div>

<h3 id="为什么你需要重点关注-so文件">为什么你需要重点关注.so文件</h3><p>如果项目中使用到了NDK，它将会生成.so文件，因此显然你已经在关注它了。如果只是使用Java语言进行编码，你可能在想不需要关注.so文 件了吧，因为Java是跨平台的。但事实上，即使你在项目中只是使用Java语言，很多情况下，你可能并没有意识到项目中依赖的函数库或者引擎库里面已经 嵌入了.so文件，并依赖于不同的ABI。</p>
<p>例如，项目中使用RenderScript支持库，OpenCV，Unity，android-gif-drawable，SQLCipher等，你都已经在生成的APK文件中包含.so文件了，而你需要关注.so文件。</p>
<p>Android应用支持的ABI取决于APK中位于lib/ABI目录中的.so文件，其中ABI可能是上面说过的七种ABI中的一种。</p>
<p><img src="http://i.imgur.com/mS2Zzpo.png" alt="关于Android的.so文件你所需要知道的"></p>
<p><a href="https://play.google.com/store/apps/details?id=com.xh.nativelibsmonitor.app" target="_blank" rel="external">Native Libs Monitor</a>&nbsp;这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。</p>
<div style="padding: 0px; margin: 0px; line-height: 25.2000007629395px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);"><br><br>当然，我们也可以自己对app反编译来获取这些信息，不过相对麻烦一些。<br></div>

<p>很多设备都支持多于一种的ABI。例如ARM64和x86设备也可以同时运行armeabi-v7a和armeabi的二进制包。但最好是针对特 定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新， 例如硬件fpu，更多的寄存器，更好的向量化等）。</p>
<p>我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为 Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件，如果在对应的lib／ABI目录中存在.so文件的 话。</p>
<h3 id="App中可能出错的地方">App中可能出错的地方</h3><p>处理.so文件时有一条简单却并不知名的重要法则。</p>
<p>你应该尽可能的提供专为每个ABI优化过的.so文件，但要么全部支持，要么都不支持：你不应该混合着使用。你应该为每个ABI目录提供对应的.so文件。</p>
<p>当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的 话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支 持armeabi-v7a和armeabi）。</p>
<h3 id="其他地方也可能出错">其他地方也可能出错</h3><p>当你引入一个.so文件时，不止影响到CPU架构。我从其他开发者那里可以看到一系列常见的错误，其中最多的是”UnsatisfiedLinkError”，”dlopen: failed”以及其他类型的crash或者低下的性能：</p>
<h4 id="使用android-21平台版本编译的-so文件运行在android-15的设备上">使用android-21平台版本编译的.so文件运行在android-15的设备上</h4><p>使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是后向兼容的，而是前向兼容的。推荐使用app的minSdkVersion对应的编译平台。</p>
<p>这也意味着当你引入一个预编译好的.so文件时，你需要检查它被编译所用的平台版本。</p>
<h4 id="混合使用不同C++运行时编译的-so文件">混合使用不同C++运行时编译的.so文件</h4><p>.so文件可以依赖于不同的C++运行时，静态编译或者动态加载。混合使用不同版本的C++运行时可能导致很多奇怪的crash，是应该避免的。 作为一个经验法则，当只有一个.so文件时，静态编译C++运行时是没问题的，否则当存在多个.so文件时，应该让所有的.so文件都动态链接相同的 C++运行时。</p>
<p>这意味着当引入一个新的预编译.so文件，而且项目中还存在其他的.so文件时，我们需要首先确认新引入的.so文件使用的C++运行时是否和已经存在的.so文件一致。</p>
<h4 id="没有为每个支持的CPU架构提供对应的-so文件">没有为每个支持的CPU架构提供对应的.so文件</h4><p>这一点在前文已经说到了，但你应该真的特别注意它，因为它可能发生在根本没有意识到的情况下。</p>
<p>例如：你的app支持armeabi-v7a和x86架构，然后使用Android Studio新增了一个函数库依赖，这个函数库包含.so文件并支持更多的CPU架构，例如新增android-gif-drawable函数库：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">compile</span> ‘<span class="tag">pl</span><span class="class">.droidsonroids</span><span class="class">.gif</span><span class="pseudo">:android-gif-drawable</span><span class="pseudo">:1</span><span class="class">.1</span>.+’</span><br></pre></td></tr></table></figure></p>
<p>发布我们的app后，会发现它在某些设备上会发生Crash，例如Galaxy S6，最终可以发现只有64位目录下的.so文件被安装进手机。</p>
<p>解决方案：重新编译我们的.so文件使其支持缺失的ABIs，或者设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ndk</span><span class="class">.abiFilters</span></span><br></pre></td></tr></table></figure></p>
<p>显示指定支持的ABIs。</p>
<p>最后一点：&nbsp;如果你是一个SDK提供者，但提供的函数库不支持所有的ABIs，那你将会搞砸你的用户，因为他们能支持的ABIs必将只能少于你提供的。</p>
<h4 id="将-so文件放在错误的地方">将.so文件放在错误的地方</h4><p>我们往往很容易对.so文件应该放在或者生成到哪里感到困惑，下面是一个总结：</p>
<ul>
<li>Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）</li>
<li>Eclipse工程放在libs/ABI目录中（这也是ndk-build命令默认生成.so文件的目录）</li>
<li>AAR压缩包中位于jni/ABI目录中（.so文件会自动包含到引用AAR压缩包的APK中）</li>
<li>最终APK文件中的lib/ABI目录中</li>
<li>通过PackageManager安装后，在小于Android 5.0的系统中，.so文件位于app的nativeLibraryPath目录中；在大于等于Android 5.0的系统中，.so文件位于app的nativeLibraryRootDir/CPU_ARCH目录中。</li>
</ul>
<h4 id="只提供armeabi架构的-so文件而忽略其他ABIs的">只提供armeabi架构的.so文件而忽略其他ABIs的</h4><p>所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件，因此似乎移除其他ABIs的.so文件是一个减少APK大小的好技巧。但事实上并不是：这不只影响到函数库的性能和兼容性。</p>
<p>x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性 能（ART，webview，media等等）。</p>
<p>以减少APK包大小为由是一个错误的借口，因为你也可以选择在应用市场上传指定ABI版本的APK，生成不同ABI版本的APK可以在build.gradle中如下配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   ...</span><br><span class="line">   splits &#123;</span><br><span class="line">     abi &#123;</span><br><span class="line">       enable <span class="keyword">true</span></span><br><span class="line">       reset()</span><br><span class="line">       <span class="keyword">include</span> <span class="string">'x86'</span>, <span class="string">'x86_64'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'arm64-v8a'</span> <span class="comment">//select ABIs to build APKs for</span></span><br><span class="line">       universalApk <span class="keyword">true</span> <span class="comment">//generate an additional APK that contains all the ABIs</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// map for the version code</span></span><br><span class="line">   <span class="keyword">project</span>.ext.versionCodes = [<span class="string">'armeabi'</span>: <span class="number">1</span>, <span class="string">'armeabi-v7a'</span>: <span class="number">2</span>, <span class="string">'arm64-v8a'</span>: <span class="number">3</span>, <span class="string">'mips'</span>: <span class="number">5</span>, <span class="string">'mips64'</span>: <span class="number">6</span>, <span class="string">'x86'</span>: <span class="number">8</span>, <span class="string">'x86_64'</span>: <span class="number">9</span>]</span><br><span class="line">   android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">     <span class="comment">// assign different version code for each output</span></span><br><span class="line">     variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">       output.versionCodeOverride =</span><br><span class="line">           <span class="keyword">project</span>.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), <span class="number">0</span>) * <span class="number">1000000</span> + android.defaultConfig.versionCode</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自： <a href="http://www.open-open.com/lib/view/open1440421271716.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1440421271716.html</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/08/hexo-%E8%8F%9C%E9%B9%B0%E6%95%99%E4%BD%A0%E6%80%8E%E4%B9%88%E8%BD%AC%E8%BD%BD%E5%88%AB%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[hexo 菜鹰教你怎么转载别人博客到自己搭建的博客]]></title>
                <content><![CDATA[<p>有时候在网上看到别人的博文写的不错，想要转载到自己博客里。</p>
<p>但是由于我们是自己搭建的博客，发表的文章都是以源码方式编辑的。没有方便的一键转载什么的~~</p>
<p>那在这种时候改怎么办呢~<br><a id="more"></a></p>
<p>下面是一点个人发现的一些小技巧，<br>当然，也许还有其他更方便你的方式我还没有发现，<br>如果有更加方便的方式转载博客的话，期待能在下方回复，</p>
<h3 id="方法1：">方法1：</h3><p>直接将该网页保存成html格式的，然后将不需要的一些广告或者其他的东西去掉，<br>最后保存将该html直接放在_post目录下，记得添加title、date之类的东西</p>
<h3 id="方法2：">方法2：</h3><p>在网上找个在线或者离线html转Markdown格式的。<br>然后将方法1中获取的html文件~~就不继续说了~</p>
<h3 id="方法3_(这个是我正在使用的方法)：">方法3 (这个是我正在使用的方法)：</h3><p>需准备材料：<br>     <strong><a href="http://www.wiz.cn/download.html" target="_blank" rel="external">为知笔记</a></strong><br>安装上为知笔记后再安装一个<a href="http://app.wiz.cn/plugin/file/1995" target="_blank" rel="external">Markdown编辑插件</a></p>
<p>下载完毕后<strong>重启</strong>一下，在<strong>未编辑</strong>状态下能看到!<img src="http://i.imgur.com/gP39Peu.png" alt=""><br>Editor.md  Markdown编辑器</p>
<p>，点击就可以在markdown模式下编辑了！</p>
<p>然而，这与转载博客并没有关系。怎么转载呢？还要保持格式。</p>
<p>是不是发现复制想要转载的文章，然后粘贴在Markdown或者Editplus里格式全无啊。<br>在为知笔记里就不会，按照步骤：</p>
<h4 id="转载博客步骤：">转载博客步骤：</h4><h5 id="1，复制要转载的内容">1，复制要转载的内容</h5><h5 id="2，在为知笔记新建一个笔记，然后粘贴在内容框中">2，在为知笔记新建一个笔记，然后粘贴在内容框中</h5><h5 id="3，保存并退出笔记">3，保存并退出笔记</h5><h5 id="4，点击Editor-md编辑在Markdown模式下编辑">4，点击Editor.md编辑在Markdown模式下编辑</h5><p>你会发现他自动帮你转好了，直接复制可用。有可能有少数部分不是很完美，但是稍作休整就好了，记得添加博客的格式头文件(title/date/layout之类的属性)</p>
<p>搞完这些，你的博客发布什么的就不用多说了吧！搞定！有问题可以在下方评论或者直接联系我！</p>
<p><strong>当然，最重要最重要的是，记得尊重著作权，在文章最后或者文章某处留下原文链接</strong></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/07/android_marshmallow_change_detail/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[Android6.0 Marshmallow(棉花糖) 对开发者的影响]]></title>
                <content><![CDATA[<p>Android6.0 Marshmallow(棉花糖)<br>官方原文：<a href="https://developer.android.com/intl/zh-cn/about/versions/marshmallow/android-6.0.html" target="_blank" rel="external">https://developer.android.com/intl/zh-cn/about/versions/marshmallow/android-6.0.html</a></p>
<p>6.0新版本包含了许多对系统功能和API的变化，<br> 而我们作为开发者，也要考虑自己的程序需要做哪些兼容性的改变！</p>
<p><a href="http://tech.sina.com.cn/mobile/n/n/2015-09-30/doc-ifxieyms4231929.shtml" target="_blank" rel="external">优化为主提升体验 Android 6.0亮点解析 http://tech.sina.com.cn/mobile/n/n/2015-09-30/doc-ifxieyms4231929.shtml</a><br><a id="more"></a></p>
<h2 id="系统功能改变：">系统功能改变：</h2><h3 id="1，Doze_and_App_Standby：">1，Doze and App Standby：</h3><p> 也就是睡眠和app待机。<br> 从Android6.0开始，Android提供了两种延长电池使用寿命的功能：睡眠和app待机。<br> 当设备没有连接电源，进入Doze模式时，让应用程序处于待机状态以此减少电池的消耗<br> 据说，在nexus5和nexus6上测试，平均续航时间提高了30%。(亲儿子数据，仅供参考)<br> 系统进入睡眠状态后，会隔一段时间处理一下正在挂起任务，随着时间的推移，后面的间隔时间会越来越长，以此减少电量的消耗</p>
<h3 id="2，Runtime_Permissions：">2，Runtime Permissions：</h3><p> 也就是在程序请求要用的权限 的时候，系统会给一个弹框。提示用户，要不要给这个程序的某某权限。在6.0以前的Android系统上，<br> 是在安装之前把所有应用需要的权限全部展示给看，用户决定是否要安装这个App，之后App用权限的时候不会提示用户(有些手机会提示是因为系统定制的或者第三方软件的提示)。<br> 如果一个程序被静默安装了，用户不知道，也没有权限提示。那是非常不安全滴~<br> 那么6.0以后，不止在用户安装的时候会提示用户，程序在运行的时候，请求某种权限之前，系统也会弹出一个对话框，让用户决定是否给XX权限给XX软件。<br> 当然，如果是你不认识的App，请求某些比较隐私的权限。就可以果断卸载了。酱紫，就防止了很多app会泄露隐私了(哎。有些App的一些强盗行为拦都拦不住、不说了~)。</p>
<h3 id="3，Boring_SSL:">3，Boring SSL:</h3><p> Boring SSL 是更安全的SSL协议，在Android6.0以前使用的是open SSL协议。 升级为 Boring SSL（心脏出血漏洞、中间人攻击等漏洞修复）</p>
<h3 id="4，应用数据自动备份功能">4，应用数据自动备份功能</h3><p>（不过，听说是基于 Google 账号的自动备份~）</p>
<h2 id="系统增强">系统增强</h2><h3 id="1，访问硬件标识符">1，访问硬件标识符</h3><h3 id="2，APK内容修改签名认证">2，APK内容修改签名认证</h3><h3 id="3，USB连接">3，USB连接</h3><h3 id="4，App_Links">4，App Links</h3><h2 id="重点：API相关修改：">重点：API相关修改：</h2><h3 id="1，Apache_HTTP_Client去除">1，Apache HTTP Client去除</h3><p> HttpClient在6.0中已经去掉了,用OKhttp替代，如果要继续使用HttpClient。并且还想支持6.0的用户的话，就只能添加HttpClient的支持库了。<br> Eclipse的话在libs中加入<br> org.apache.http.legacy.jar<br> 上面的jar包在：**\android-sdk-windows\platforms\android-23\optional下（需要下载android 6.0的SDK），</p>
<p>AndroidStudio的话就容易多了。在Gradle中添加一句话就解决：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">useLibrary</span> <span class="string">'org.apache.http.legacy'</span></span><br></pre></td></tr></table></figure>
<h3 id="2，Notifycation的变更">2，Notifycation的变更</h3><p> 1，不要打扰模式（新的INTERRUPTION_FILTER_ALARMS过滤级别）<br> 2，添加新的category值CATEGORY REMINDER 用于区分CATEGORY_EVENT和CATEGORY_ALARM<br> 3，新的Icon类，你可以通过setSmallIcon() 和setLargeIcon() 修改Notifacations图标，同样的addAction() 方法现在接收一个Icon对象，不再是一个资源文件了。<br> 4，新的getActiveNotification()方法 允许你查找哪些应用的Notifications还活着</p>
<h3 id="3，删除全局支持书签（Browser_Bookmark_Changes）">3，删除全局支持书签（Browser Bookmark Changes）</h3><p> 读取历史书签和写入历史书签的权限也被去掉 只能内部存储书签<br>android.provider.Browser.getAllBookmarks() 和android.provider.Browser.saveBookmark()方法现在除去。同样，READ_HISTORY_BOOKMARKS和WRITE_HISTORY_BOOKMARKS权限被除去。如果您的应用目标的Android 6.0（API级别23）或更高，没有从全局供应商访问书签或使用书签的权限。相反，您的应用程序应该在内部存储书签数据。</p>
<h3 id="4，Voice_Interactions(语音交互)">4，Voice Interactions(语音交互)</h3><p>在应用中通过Voice Actions构建一个语音<br><a href="https://developer.android.com/intl/zh-cn/reference/android/app/VoiceInteractor.html" target="_blank" rel="external">VoiceInteractor</a></p>
<h3 id="5，Adoptable_Storage_Devices(存储设备)">5，Adoptable Storage Devices(存储设备)</h3><p>可以选择手机内部存储和外部SD卡存储</p>
<h3 id="6，手电筒">6，手电筒</h3><p>api的更新 可以直接使用setTouchMode()方法来开启或者关闭手电筒</p>
<h3 id="7，4K_Display_Mode">7，4K Display Mode</h3><p> 让高配手机得以4K呈现</p>
<h3 id="8，支持指纹认证">8，支持指纹认证</h3><p>提供原生指纹识别API <a href="https://developer.android.com/intl/zh-cn/reference/android/hardware/fingerprint/FingerprintManager.html" target="_blank" rel="external">FingerprintManager</a></p>
<p>当然少不了权限：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission</span><br><span class="line">android:<span class="property">name</span>=<span class="string">"android.permission.USE_FINGERPRINT"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>(还可以用模拟器模拟的哟，官方文档有介绍)</p>
<h2 id="API增强：">API增强：</h2><h3 id="1，蓝牙笔增强">1，蓝牙笔增强</h3><h3 id="2，蓝牙">2，蓝牙</h3><p>扫描  减少蓝牙扫描消耗 提升系统性能</p>
<h3 id="3，热点2-0支持">3，热点2.0支持</h3><p> 提供新的热点API 用于支持热点2.0 </p>
<h3 id="4，签名文件">4，签名文件</h3><p> Android新版本的秘钥库提供程序不再支持DSA</p>
<h3 id="5，相机服务更新">5，相机服务更新</h3><p> 访问共享资源的相机业务 已经从之前的先来先访问的服务方式，变为高优先级进程先访问模式</p>
<h3 id="6，WIFI_网络">6，WIFI 网络</h3><p> 只能修改你自己创建的WifiConfiguration相关状态</p>
<hr>
<pre><code>这里整理了大部分<span class="keyword">Android6.0相关的东西。
</span>我感觉对开发者影响总的来说不是很多，就一个HttpClient的去除可能影响较大，其他的相对较少吧~

原生支持指纹和语音的这个东西，这个感觉好处是有滴，但是有限。

其他的就只能算是优化了
</code></pre>]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/06/hexo-blog-encode-confusion-question/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[hexo博客出现乱码的问题]]></title>
                <content><![CDATA[<p>我blog之前的标题是Eagle，里面没有中文，所以一直没有发现这个问题。</p>
<p>现在修改标题里有中文后就乱码了。<br>在网上了解了下，将该中文所在的文件编码修改为UTF-8就行了。</p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/05/launcher-folder-click-close-folder-faild/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]深入理解Android（一）：Gradle详解]]></title>
                <content><![CDATA[<p>编者按：随着移动设备硬件能力的提升，Android系统开放的特质开始显现，各种开发的奇技淫巧、黑科技不断涌现，InfoQ特联合《深入理解Android》系列图书作者邓凡平，开设<a href="http://www.infoq.com/cn/android-in-depth" target="_blank" rel="external">深入理解Android</a>专栏，探索Android从框架到应用开发的奥秘。</p>
<a id="more"></a>
<p>Gradle是当前非常“劲爆”的构建工具。本篇文章就是专为讲解Gradle而来。介绍Gradle之前，先说点题外话。</p>
<h2 id="一、题外话">一、题外话</h2><p>说实话，我在索尼工作的时候，就见过Gradle。但是当时我一直不知道这是什么东西。而且索尼工具组的工程师还将其和Android Studio索尼版一起推送，偶一看就更没兴趣了。为什么那个时候如此不待见Gradle呢？因为我此前一直是做ROM开发。在这个层面上，我们用make，mm或者mmm就可以了。而且，编译耗时对我们来说也不是啥痛点，因为用组内吊炸天的神机服务器完整编译索尼的image也要耗费1个小时左右。所以，那个时侯Gradle完全不是我们的菜。</p>
<p>现在，搞APP开发居多，编译/打包等问题立即就成痛点了。比如：</p>
<ul>
<li>一个APP有多个版本，Release版、Debug版、Test版。甚至针对不同APP Store都有不同的版本。在以前ROM的环境下，虽然可以配置Android.mk，但是需要依赖整个Android源码，而且还不能完全做到满足条件，很多事情需要手动搞。一个app如果涉及到多个开发者，手动操作必然会带来混乱。</li>
<li>library工程我们需要编译成jar包，然后发布给其他开发者使用。以前是用eclipse的export，做一堆选择。要是能自动编译成jar包就爽了。</li>
</ul>
<p>上述问题对绝大部分APP开发者而言都不陌生，而<strong>Gradle</strong>作为一种很方便的的构建工具，可以非常轻松得解决构建过程中的各种问题。</p>
<h2 id="二、闲言构建">二、闲言构建</h2><p>构建，叫build也好，叫make也行。反正就是根据输入信息然后干一堆事情，最后得到几个产出物（Artifact）。</p>
<p>最最简单的构建工具就是make了。make就是根据Makefile文件中写的规则，执行对应的命令，然后得到目标产物。</p>
<p><strong>日常生活中，和构建最类似的一个场景就是做菜。输入各种食材，然后按固定的工序，最后得到一盘菜。当然，做同样一道菜，由于需求不同，做出来的东西也不尽相同。比如，宫保鸡丁这道菜，回民要求不能放大油、口淡的要求少放盐和各种油、辣不怕的男女汉子们可以要求多放辣子….总之，做菜包含固定的工序，但是对于不同条件或需求，需要做不同的处理。</strong></p>
<p>在Gradle爆红之前，常用的构建工具是ANT，然后又进化到Maven。ANT和Maven这两个工具其实也还算方便，现在还有很多地方在使用。但是二者都有一些缺点，所以让更懒得人觉得不是那么方便。比如，Maven编译规则是用XML来编写的。XML虽然通俗易懂，但是很难在xml中描述<strong>if{某条件成立，编译某文件}/else{编译其他文件}</strong>这样有不同条件的任务。</p>
<p>怎么解决？怎么解决好？对程序员而言，自然是编程解决，但是有几个小要求：</p>
<ul>
<li>这种“编程”不要搞得和程序员理解的编程那样复杂。寥寥几笔，轻轻松松把要做的事情描述出来就最好不过。所以，Gradle选择了Groovy。Groovy基于Java并拓展了Java。 Java程序员可以无缝切换到使用Groovy开发程序。<strong>Groovy说白了就是把写Java程序变得像写脚本一样简单。写完就可以执行，Groovy内部会将其编译成Java class然后启动虚拟机来执行。当然，这些底层的渣活不需要你管。</strong></li>
<li>除了可以用很灵活的语言来写构建规则外，Gradle另外一个特点就是它是一种DSL，即<strong>Domain Specific Language</strong>，领域相关语言。什么是DSL，说白了它是某个行业中的行话。还是不明白？徐克导演得《智取威虎山》中就有很典型的DSL使用描述，比如：</li>
</ul>
<blockquote>
<p>土匪：蘑菇，你哪路？什么价？（什么人？到哪里去？）</p>
<p>杨子荣：哈！想啥来啥，想吃奶来了妈妈，想娘家的人，孩子他舅舅来了。（找同行）</p>
<p>杨子荣：拜见三爷！</p>
<p>土匪：天王盖地虎！（你好大的胆！敢来气你的祖宗？）</p>
<p>杨子荣：宝塔镇河妖！（要是那样，叫我从山上摔死，掉河里淹死。）</p>
<p>土匪：野鸡闷头钻，哪能上天王山！（你不是正牌的。）</p>
<p>杨子荣：地上有的是米，喂呀，有根底！（老子是正牌的，老牌的。）</p>
</blockquote>
<p>Gradle中也有类似的行话，比如sourceSets代表源文件的集合等…..<strong>太多了，记不住</strong>。以后我们都会接触到这些行话。那么，对使用者而言，这些行话的好处是什么呢？这就是：</p>
<p><strong>一句行话可以包含很多意思，而且在这个行当里的人一听就懂，不用解释。另外，基于行话，我们甚至可以建立一个模板，使用者只要往这个模板里填必须要填的内容，Gradle就可以非常漂亮得完成工作，得到想要的东西。</strong></p>
<p>这就和现在的智能炒菜机器似的，只要选择菜谱，把食材准备好，剩下的事情就不用你操心了。吃货们对这种做菜方式肯定是以反感为主，太没有特色了。但是程序员对Gradle类似做法却热烈拥抱。</p>
<p>到此，大家应该明白要真正学会Gradle恐怕是离不开下面两个基础知识：</p>
<ul>
<li>Groovy，由于它基于Java，所以我们仅介绍Java之外的东西。了解Groovy语言是掌握Gradle的基础。</li>
<li>Gradle作为一个工具，它的行话和它“为人处事”的原则。</li>
</ul>
<h2 id="三、Groovy介绍">三、Groovy介绍</h2><p>Groovy是一种动态语言。这种语言比较有特点，它和Java一样，也运行于Java虚拟机中。恩？？对头，简单粗暴点儿看，你可以认为Groovy扩展了Java语言。比如，Groovy对自己的定义就是：<strong>Groovy是在 java平台上的、 具有像Python， Ruby 和 Smalltalk 语言特性的灵活动态语言， Groovy保证了这些特性像 Java语法一样被 Java开发者使用。</strong></p>
<p>除了语言和Java相通外，Groovy有时候又像一种脚本语言。前文也提到过，当我执行Groovy脚本时，Groovy会先将其编译成Java类字节码，然后通过Jvm来执行这个Java类。图1展示了Java、Groovy和Jvm之间的关系。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image001.png" alt=""></p>
<p> <strong>实际上，由于Groovy Code在真正执行的时候已经变成了Java字节码，所以JVM根本不知道自己运行的是Groovy代码</strong>。</p>
<p>下面我们将介绍Groovy。由于此文的主要目的是Gradle，所以我们不会过多讨论Groovy中细枝末节的东西，而是把知识点集中在以后和Gradle打交道时一些常用的地方上。</p>
<h3 id="3-1_Groovy开发环境">3.1  Groovy开发环境</h3><p>在学习本节的时候，最好部署一下Groovy开发环境。根据<a href="http://www.groovy-lang.org/download.html#gvm" target="_blank" rel="external">Groovy官网</a>的介绍，部署Groovy开发环境非常简单，在Ubuntu或者cygwin之类的地方：</p>
<ul>
<li>curl -s get.gvmtool.net | bash</li>
<li>source “$HOME/.gvm/bin/gvm-init.sh”</li>
<li>gvm install groovy</li>
<li><p>执行完最后一步，Groovy就下载并安装了。</p>
<p>然后，创建一个test.groovy文件，里边只有一行代码：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>  <span class="string">"hello groovy"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行groovy test.groovy，输出结果如图2所示：</li>
</ul>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image003.png" alt=""> </p>
<p>亲们，必须要完成上面的操作啊。做完后，有什么感觉和体会？</p>
<p><strong>最大的感觉可能就是groovy和shell脚本，或者python好类似。</strong></p>
<p>另外，除了可以直接使用JDK之外，Groovy还有一套<a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">GDK</a>。</p>
<p>说实话，看了这么多家API文档，还是Google的Android API文档做得好。其页面中右上角有一个搜索栏，在里边输入一些关键字，瞬间就能列出候选类，相关文档，方便得不得了啊…..</p>
<h3 id="3-2_一些前提知识">3.2  一些前提知识</h3><p>为了后面讲述方面，这里先介绍一些前提知识。初期接触可能有些别扭，看习惯就好了。</p>
<ul>
<li>Groovy注释标记和Java一样，支持<strong>//</strong>或者<strong>/</strong>/**</li>
<li>Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心</li>
<li>Groovy中支持动态类型，即<strong>定义变量的时候可以不指定其类型</strong>。Groovy中，变量定义可以使用关键字def。<strong>注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable1</span> =</span> <span class="number">1</span>   <span class="comment">//可以不使用分号结尾</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varable2</span> =</span> <span class="string">"I am a person"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">int</span> <span class="title">x</span> =</span> <span class="number">1</span>   <span class="comment">//变量定义时，也可以直接指定类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义时，参数的类型也可以不指定。比如</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">String</span> <span class="tag">testFunction</span>(arg1,arg2)&#123;<span class="comment">//无需指定参数类型</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如：</li>
</ul>
<p>//无类型的函数定义，必须使用def关键字</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def  <span class="title">nonReturnTypeFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">     last_line   <span class="comment">//最后一行代码的执行结果就是本函数的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定了函数返回类型，则可不必加def关键字来定义函数</span></span><br><span class="line"><span class="function">String  <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"I am a string"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上</p>
<ul>
<li>函数返回值：Groovy的函数里，可以不使用return xxx来设置xxx为函数返回值。如果不使用return语句的话，则函数里最后一句代码的执行结果被设置成返回值。比如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个函数的返回值是字符串"getSomething return value"</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">getSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">"getSomething return value"</span> <span class="comment">//如果这是最后一行代码，则返回类型为String</span></span><br><span class="line"></span><br><span class="line">      <span class="number">1000</span> <span class="comment">//如果这是最后一行代码，则返回类型为Integer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型，否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。</p>
<ul>
<li>Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点：</li>
</ul>
<p>1  单引号’’中的内容严格对应Java中的String，不对$符号进行转义</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> singleQuote=<span class="string">'I am $ dolloar'</span>  <span class="comment">//输出就是I am $ dolloar</span></span><br></pre></td></tr></table></figure>
<p>2  双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会<strong>$表达式</strong>先求值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleQuoteWithoutDollar</span> =</span> <span class="string">"I am one dollar"</span> <span class="comment">//输出 I am one dollar</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span> =</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleQuoteWithDollar</span> =</span> <span class="string">"I am $x dolloar"</span> <span class="comment">//输出I am 1 dolloar</span></span><br></pre></td></tr></table></figure>
<p>3 三个引号’’’xxx’’’中的字符串支持随意换行 比如</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multieLines</span></span> = <span class="string">''</span><span class="string">' begin</span><br><span class="line">  line  1 </span><br><span class="line">  line  2</span><br><span class="line">  end '</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">println</span><span class="params">(<span class="string">"test"</span>)</span></span> ---&gt; println <span class="string">"test"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSomething</span><span class="params">()</span>&#123;</span></span><br><span class="line">   <span class="string">"hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getSomething()   //如果不加括号的话，Groovy会误认为getSomething是一个变量。</p>
<p>所以，调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号。否则还是带括号。Groovy自己也没有太好的办法解决这个问题，只能<strong>兵来将挡水来土掩</strong>了。</p>
<p>好了，了解上面一些基础知识后，我们再介绍点深入的内容。</p>
<h3 id="3-3_Groovy中的数据类型">3.3  Groovy中的数据类型</h3><p>Groovy中的数据类型我们就介绍两种和Java不太一样的：</p>
<ul>
<li>一个是Java中的基本数据类型。</li>
<li>另外一个是Groovy中的容器类。</li>
<li>最后一个非常重要的是闭包。</li>
</ul>
<p>放心，这里介绍的东西都很简单</p>
<p><strong>3.3.1  基本数据类型</strong></p>
<p>作为动态语言，Groovy世界中的所有事物都是对象。所以，<strong>int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。</strong>比如下图中的代码执行结果：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image005.png" alt=""></p>
<p>图4  int实际上是Integer</p>
<p><strong>3.3.2  容器类</strong></p>
<p>Groovy中的容器类很简单，就三种：</p>
<ul>
<li>List：链表，其底层对应Java中的List接口，一般用ArrayList作为真正的实现类。</li>
<li>Map：键-值表，其底层对应Java中的LinkedHashMap。</li>
<li>Range：范围，它其实是List的一种拓展。</li>
</ul>
<p>对容器而言，我们最重要的是了解它们的用法。下面是一些简单的例子：</p>
<ol>
<li>List类</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">变量定义：<span class="built_in">List</span>变量由[]定义，比如</span><br><span class="line"></span><br><span class="line">def aList = [<span class="number">5</span>,<span class="string">'string'</span>,<span class="keyword">true</span>] <span class="comment">//List由[]定义，其元素可以是任何对象</span></span><br><span class="line"></span><br><span class="line">变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，<span class="built_in">List</span>会自动</span><br><span class="line">往该索引添加元素</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> aList[<span class="number">1</span>] == <span class="string">'string'</span></span><br><span class="line"><span class="keyword">assert</span> aList[<span class="number">5</span>] == <span class="keyword">null</span> <span class="comment">//第6个元素为空</span></span><br><span class="line">aList[<span class="number">100</span>] = <span class="number">100</span>  <span class="comment">//设置第101个元素的值为10</span></span><br><span class="line"><span class="keyword">assert</span> aList[<span class="number">100</span>] == <span class="number">100</span></span><br><span class="line"></span><br><span class="line">那么，aList到现在为止有多少个元素呢？</span><br><span class="line"></span><br><span class="line">println aList.size  ===&gt;结果是<span class="number">101</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Map类</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">容器变量定义</span><br><span class="line"></span><br><span class="line">变量定义：Map变量由[:]定义，比如</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> aMap = [<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="literal">true</span>] </span><br><span class="line"></span><br><span class="line">Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用<span class="string">''</span>或<span class="string">""</span>包起来，也可以不用引号包起来。比如</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> aNewMap = [<span class="string">key1:</span><span class="string">"value"</span>,<span class="string">key2:</span><span class="literal">true</span>] <span class="comment">//其中的key1和key2默认被</span></span><br><span class="line">处理成字符串<span class="string">"key1"</span>和<span class="string">"key2"</span></span><br><span class="line"></span><br><span class="line">不过Key要是不使用引号包起来的话，也会带来一定混淆，比如</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> key1=<span class="string">"wowo"</span></span><br><span class="line"><span class="keyword">def</span> aConfusedMap=[<span class="string">key1:</span><span class="string">"who am i?"</span>]</span><br><span class="line"></span><br><span class="line">aConfuseMap中的key1到底是<span class="string">"key1"</span>还是变量key1的值“wowo”？显然，答案是字符串<span class="string">"key1"</span>。如果要是<span class="string">"wowo"</span>的话，则aConfusedMap的定义必须设置成：</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> aConfusedMap=[(key1):<span class="string">"who am i?"</span>]</span><br><span class="line"></span><br><span class="line">Map中元素的存取更加方便，它支持多种方法：</span><br><span class="line"></span><br><span class="line">println aMap.keyName    &lt;==这种表达方法好像key就是aMap的一个成员变量一样</span><br><span class="line">println aMap[<span class="string">'keyName'</span>] &lt;==这种表达方法更传统一点</span><br><span class="line">aMap.anotherkey = <span class="string">"i am map"</span>  &lt;==为map添加新元素</span><br></pre></td></tr></table></figure>
<ol>
<li>Range类</li>
</ol>
<p>Range是Groovy对List的一种拓展，变量定义和大体的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def aRange = <span class="number">1.</span><span class="number">.5</span>  &lt;==Range类型的变量 由begin值+两个点+end值表示</span><br><span class="line">                      左边这个aRange包含<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>这<span class="number">5</span>个值</span><br><span class="line"></span><br><span class="line">如果不想包含最后一个元素，则</span><br><span class="line"></span><br><span class="line">def aRangeWithoutEnd = <span class="number">1.</span>.&lt;<span class="number">5</span>  &lt;==包含<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>这<span class="number">4</span>个元素</span><br><span class="line">println aRange.from</span><br><span class="line">println aRange.to</span><br></pre></td></tr></table></figure>
<p><strong>3.3.4  Groovy API的一些秘笈</strong></p>
<p>前面讲这些东西，主要是让大家了解Groovy的语法。实际上在coding的时候，是离不开SDK的。由于Groovy是动态语言，所以要使用它的SDK也需要掌握一些小诀窍。</p>
<p>Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></p>
<p>以上文介绍的Range为例，我们该如何更好得使用它呢？</p>
<ul>
<li><p>先定位到Range类。它位于groovy.lang包中：</p>
<p>有了API文档，你就可以放心调用其中的函数了。<strong>不过，不过，不过</strong>：我们刚才代码中用到了Range.from/to属性值，但翻看Range API文档的时候，其实并没有这两个成员变量。图6是Range的方法</p>
</li>
</ul>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image007.png" alt=""></p>
<p> 文档中并没有说明Range有from和to这两个属性，但是却有getFrom和getTo这两个函数。<strong>What happened？</strong>原来：</p>
<p>根据Groovy的原则，如果一个类中有名为xxyyzz这样的属性（其实就是成员变量），Groovy会自动为它添加getXxyyzz和setXxyyzz两个函数，用于获取和设置xxyyzz属性值。</p>
<p>注意，get和set后第一个字母是大写的</p>
<p>所以，当你看到Range中有getFrom和getTo这两个函数时候，就得知道潜规则下，Range有from和to这两个属性。当然，由于它们不可以被外界设置，所以没有公开setFrom和setTo函数。</p>
<h3 id="3-4_闭包">3.4  闭包</h3><p><strong>3.4.1  闭包的样子</strong></p>
<p>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！</p>
<p>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> aClosure = &#123;<span class="comment">//闭包是一段代码，所以需要用花括号括起来..  </span></span><br><span class="line">    Stringparam1, <span class="keyword">int</span> param2 -&gt;  <span class="comment">//这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </span></span><br><span class="line">    <span class="keyword">println</span><span class="string">"this is code"</span> <span class="comment">//这是代码，最后一句是返回值，  </span></span><br><span class="line">   <span class="comment">//也可以使用return，和Groovy中普通函数一样  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简而言之，Closure的定义格式是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span> =</span> &#123;paramters -&gt; code&#125;  <span class="comment">//或者  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span> =</span> &#123;无参数，纯code&#125;  这种<span class="keyword">case</span>不需要-&gt;符号</span><br></pre></td></tr></table></figure>
<p><strong>说实话，从C/C++语言的角度看，闭包和函数指针很像</strong>。闭包定义好后，要调用它的方法就是：</p>
<p>闭包对象.call(参数)  或者更像函数指针调用的方法：</p>
<p>闭包对象(参数)  </p>
<p>比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aClosure.<span class="function"><span class="title">call</span><span class="params">(<span class="string">"this is string"</span>,<span class="number">100</span>)</span></span>  或者  </span><br><span class="line"><span class="function"><span class="title">aClosure</span><span class="params">(<span class="string">"this is string"</span>, <span class="number">100</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>上面就是一个闭包的定义和使用。在闭包中，还需要注意一点：</p>
<p><strong>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。</strong></p>
<p>比如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span> = &#123; <span class="string">"Hello, $it!"</span> &#125;</span><br><span class="line">assert greeting(<span class="string">'Patrick'</span>) == <span class="string">'Hello, Patrick!'</span></span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span> = &#123; it -&gt; <span class="string">"Hello, $it!"</span> &#125;</span><br><span class="line">assert greeting(<span class="string">'Patrick'</span>) == <span class="string">'Hello, Patrick!'</span></span><br></pre></td></tr></table></figure>
<p>但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noParamClosure</span></span> = &#123; -&gt; <span class="keyword">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，我们就不能给noParamClosure传参数了！</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">noParamClosure </span>(<span class="string">"test"</span>)  &lt;==报错喔！</span><br></pre></td></tr></table></figure>
<p><strong>3.4.2  Closure使用中的注意点</strong></p>
<ol>
<li>省略圆括号</li>
</ol>
<p>闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; each(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">self</span>, Closure closure)</span><br></pre></td></tr></table></figure>
<p>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是，在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List</span></span><br><span class="line">iamList.each&#123;  <span class="comment">//调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了？</span></span><br><span class="line">      println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有两个知识点：</p>
<ul>
<li><strong>each函数调用的圆括号不见了</strong>！原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def  <span class="title">testClosure</span><span class="params">(<span class="keyword">int</span> a1,String b1, Closure closure)</span></span>&#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      closure() <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br><span class="line">那么调用的时候，就可以免括号！</span><br><span class="line">testClosure (<span class="number">4</span>, <span class="string">"test"</span>, &#123;</span><br><span class="line">   println <span class="string">"i am in closure"</span></span><br><span class="line">&#125; )  <span class="comment">//红色的括号可以不写..</span></span><br></pre></td></tr></table></figure>
<p>注意，这个特点非常关键，因为以后在Gradle中经常会出现图7这样的代码：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image008.png" alt=""></p>
<p>经常碰见图7这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我confuse（不知道其他人是否有同感），以doLast为例，完整的代码应该按下面这种写法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">doLast</span>(&#123;</span><br><span class="line">   <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有了圆括号，你会知道 doLast只是把一个Closure对象传了进去。很明显，它不代表这段脚本解析到doLast的时候就会调用println ‘Hello world!’ 。</p>
<p>但是把圆括号去掉后，就感觉好像println ‘Hello world!’立即就会被调用一样！</p>
<ol>
<li>如何确定Closure的参数</li>
</ol>
<p>另外一个比较让人头疼的地方是，Closure的参数该怎么搞？还是刚才的each函数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; each(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">self</span>, Closure closure)</span><br></pre></td></tr></table></figure>
<p>如何使用它呢？比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List变量</span></span><br><span class="line">iamList.each&#123;  <span class="comment">//调用它的each函数，只要传入一个Closure就可以了。</span></span><br><span class="line">  println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来很轻松，其实：</p>
<ul>
<li><strong>对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？</strong></li>
</ul>
<p>我们能写成下面这样吗？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iamList.each&#123;<span class="built_in">String</span> name,<span class="keyword">int</span> x -&gt;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;  <span class="comment">//运行的时候肯定报错！</span></span><br></pre></td></tr></table></figure>
<p>所以，Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？</p>
<p>此问题如何破解？只能通过查询API文档才能了解上下文语义。比如下图8：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image009.png" alt=""></p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image010.png" alt=""></p>
<p> 图8中：</p>
<ul>
<li>each函数说明中，将给指定的closure传递Set中的每一个item。所以，closure的参数只有一个。</li>
<li>findAll中，<strong>绝对抓瞎</strong>了。一个是没说明往Closure里传什么。另外没说明Closure的返回值是什么…..。</li>
</ul>
<p><strong>对Map的findAll而言，Closure可以有两个参数。findAll会将Key和Value分别传进去。并且，Closure返回true，表示该元素是自己想要的。返回false表示该元素不是自己要找的</strong>。示意代码如图9所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image011.png" alt=""></p>
<p> Closure的使用有点坑，很大程度上依赖于你对API的熟悉程度，所以最初阶段，SDK查询是少不了的。</p>
<h3 id="3-5_脚本类、文件I/O和XML操作">3.5  脚本类、文件I/O和XML操作</h3><p>最后，我们来看一下Groovy中比较高级的用法。</p>
<p><strong>3.5.1  脚本类</strong></p>
<ol>
<li>脚本中import其他类</li>
</ol>
<p>Groovy中可以像Java那样写package，然后写类。比如在文件夹com/cmbc/groovy/目录中放一个文件，叫Test.groovy，如图10所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image012.png" alt=""></p>
<p> 你看，图10中的Test.groovy和Java类就很相似了。当然，如果不声明public/private等访问权限的话，Groovy中类及其变量默认都是public的。</p>
<p>现在，我们在测试的根目录下建立一个test.groovy文件。其代码如下所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image013.png" alt=""></p>
<p> 你看，test.groovy先import了com.cmbc.groovy.Test类，然后创建了一个Test类型的对象，接着调用它的print函数。</p>
<p>这两个groovy文件的目录结构如图12所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image014.png" alt=""></p>
<p> 在groovy中，系统自带会加载当前目录/子目录下的xxx.groovy文件。所以，当执行groovy test.groovy的时候，test.groovy import的Test类能被自动搜索并加载到。</p>
<ol>
<li>脚本到底是什么</li>
</ol>
<p>Java中，我们最熟悉的是类。但是我们在Java的一个源码文件中，不能不写class（interface或者其他….），而Groovy可以像写脚本一样，把要做的事情都写在xxx.groovy中，而且可以通过groovy xxx.groovy直接执行这个脚本。这到底是怎么搞的？</p>
<p>既然是基于Java的，Groovy会先把xxx.groovy中的内容转换成一个Java类。比如：</p>
<p>test.groovy的代码是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span> <span class="string">'Groovy world!'</span></span><br></pre></td></tr></table></figure>
<p>Groovy把它转换成这样的Java类：</p>
<p>执行<strong> groovyc</strong> -d classes test.groovy</p>
<p><strong>groovyc</strong>是groovy的编译命令，-d classes用于将编译得到的class文件拷贝到classes文件夹下</p>
<p>图13是test.groovy脚本转换得到的java class。用jd-gui反编译它的代码：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image015.png" alt=""></p>
<p> 图13中：</p>
<ul>
<li>test.groovy被转换成了一个test类，它从script派生。</li>
<li>每一个脚本都会生成一个static main函数。这样，当我们groovy test.groovy的时候，其实就是用java去执行这个main函数</li>
<li><strong>脚本中的所有代码都会放到run函数中</strong>。比如，println ‘Groovy world’，这句代码实际上是包含在run函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在test类中。</li>
</ul>
<p><strong>groovyc</strong>是一个比较好的命令，读者要掌握它的用法。然后利用jd-gui来查看对应class的Java源码。</p>
<ol>
<li>脚本中的变量和作用域</li>
</ol>
<p>前面说了，xxx.groovy只要不是和Java那样的class，那么它就是一个脚本。而且脚本的代码其实都会被放到run函数中去执行。那么，在Groovy的脚本中，很重要的一点就是脚本中定义的<strong>变量和它的作用域</strong>。举例：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span></span> = <span class="number">1</span> &lt;==注意，这个x有<span class="function"><span class="keyword">def</span>（或者指明类型，比如 <span class="title">int</span></span> x = <span class="number">1</span>）  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printx</span></span>()&#123;  </span><br><span class="line">   println x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printx()  &lt;==报错，说x找不到</p>
<p>为什么？继续来看反编译后的class文件。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image016.png" alt=""></p>
<p> 图14中：</p>
<ul>
<li><strong>printx被定义成test类的成员函数</strong></li>
<li><strong>def x = 1</strong>，这句话是在run中创建的。所以，x=1从代码上看好像是在整个脚本中定义的，但实际上printx访问不了它。printx是test成员函数，除非x也被定义成test的成员函数，否则printx不能访问它。</li>
</ul>
<p>那么，如何使得printx能访问x呢？很简单，定义的时候不要加类型和def。即：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>  &lt;==注意，去掉<span class="function"><span class="keyword">def</span>或者类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printx</span><span class="params">()</span>&#123;</span></span><br><span class="line">   println x</span><br><span class="line">&#125;</span><br><span class="line">printx()  &lt;==<span class="constant">OK</span></span><br></pre></td></tr></table></figure>
<p>这次Java源码又变成什么样了呢？</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image017.png" alt=""></p>
<p> 图15中，x也没有被定义成test的成员函数，而是在run的执行过程中，将x作为一个属性添加到test实例对象中了。然后在printx中，先获取这个属性。</p>
<p>注意，Groovy的文档说 x = 1这种定义将使得x变成test的成员变量，但从反编译情况看，这是不对的…..</p>
<p>虽然printx可以访问x变量了，但是假如有其他脚本却无法访问x变量。因为它不是test的成员变量。</p>
<p>比如，我在测试目录下创建一个新的名为test1.groovy。这个test1将访问test.groovy中定义的printx函数：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image018.png" alt=""></p>
<p> 这种方法使得我们可以将代码分成模块来编写，<strong>比如将公共的功能放到test.groovy中，然后使用公共功能的代码放到test1.groovy中</strong>。</p>
<p>执行groovy test1.groovy，报错。说x找不到。这是因为x是在test的run函数动态加进去的。怎么办？</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> groovy.transform.Field;   //必须要先<span class="keyword">import</span></span></span><br><span class="line">@<span class="keyword">Field</span> x = <span class="number">1</span>  &lt;==在x前面加上@<span class="keyword">Field</span>标注，这样，x就彻彻底底是test的成员变量了。</span><br></pre></td></tr></table></figure>
<p>查看编译后的test.class文件，得到：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image019.png" alt=""></p>
<p> 这个时候，test.groovy中的x就成了test类的成员函数了。如此，我们可以在script中定义那些需要输出给外部脚本或类使用的变量了！</p>
<p><strong>3.5.2  文件I/O操作</strong></p>
<p>本节介绍下Groovy的文件I/O操作。直接来看例子吧，虽然比Java看起来简单，但要理解起来其实比较难。尤其是当你要自己查SDK并编写代码的时候。</p>
<p>整体说来，Groovy的I/O操作是在原有Java I/O操作上进行了更为简单方便的封装，并且使用Closure来简化代码编写。主要封装了如下一些了类：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image020.png" alt=""></p>
<ol>
<li>读文件</li>
</ol>
<p>Groovy中，文件读操作简单到令人发指：</p>
<p>def targetFile = new File(文件名)  &lt;==File对象还是要创建的。</p>
<p>然后打开<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></p>
<p>看看Groovy定义的API：</p>
<p>1 读该文件中的每一行：eachLine的唯一参数是一个Closure。Closure的参数是文件每一行的内容</p>
<p>   其内部实现肯定是Groovy打开这个文件，然后读取文件的一行，然后调用Closure…</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">targetFile.eachLine</span>&#123;   </span><br><span class="line">  <span class="keyword">StringoneLine </span>-&gt;  </span><br><span class="line">   printlnoneLine      </span><br><span class="line">  &lt;==是不是令人发指？？！</span><br></pre></td></tr></table></figure>
<p>2 直接得到文件内容</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetFile.<span class="function"><span class="title">getBytes</span><span class="params">()</span></span>  &lt;==文件内容一次性读出，返回类型为byte[]</span><br></pre></td></tr></table></figure>
<p> 注意前面提到的getter和setter函数，这里可以直接使用targetFile.bytes    //….</p>
<p>3 使用InputStream.InputStream的SDK在 <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def ism =  targetFile.<span class="function"><span class="title">newInputStream</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">//操作ism，最后记得关掉  </span></span><br><span class="line">ism.close</span><br></pre></td></tr></table></figure>
<p>4 使用闭包操作inputStream，以后在Gradle里会常看到这种搞法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> targetFile.withInputStream&#123; ism -&gt;</span><br><span class="line">   操作ism. 不用<span class="built_in">close</span>。Groovy会自动替你<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实够简单，令人发指。我当年死活也没找到withInputStream是个啥意思。所以，请各位开发者牢记Groovy I/O操作相关类的SDK地址：</p>
<ul>
<li>java.io.File: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></strong></li>
<li>java.io.InputStream: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a>       </strong></li>
<li>java.io.OutputStream: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></strong></li>
<li>java.io.Reader: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a></strong></li>
<li>java.io.Writer: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a></strong></li>
<li>java.nio.file.Path: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a></strong></li>
</ul>
<ol>
<li>写文件</li>
</ol>
<p>和读文件差不多。不再啰嗦。这里给个例子，告诉大家如何copy文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> srcFile = <span class="keyword">new</span> <span class="keyword">File</span>(源文件名)  </span><br><span class="line"><span class="keyword">def</span> targetFile = <span class="keyword">new</span> <span class="keyword">File</span>(目标文件名)  </span><br><span class="line">targetFile.withOutputStream&#123; os-&gt;  </span><br><span class="line">  srcFile.withInputStream&#123; ins-&gt;  </span><br><span class="line">      os &lt;&lt; ins   <span class="comment">//利用OutputStream的&lt;&lt;操作符重载，完成从inputstream到OutputStream  </span></span><br><span class="line">       <span class="comment">//的输出  </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于OutputStream的&lt;&lt;操作符重载，查看SDK文档后可知：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image021.png" alt=""></p>
<p> 再一次向极致简单致敬。但是，SDK恐怕是离不开手了…</p>
<p><strong>3.5.3  XML操作</strong></p>
<p>除了I/O异常简单之外，Groovy中的XML操作也极致得很。Groovy中，XML的解析提供了和XPath类似的方法，名为GPath。这是一个类，提供相应API。关于XPath，请看<a href="https://en.wikipedia.org/wiki/XPath" target="_blank" rel="external">Wiki</a>。</p>
<p>GPath功能包括：给个例子好了，来自Groovy官方文档。</p>
<p>test.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">response</span> <span class="attribute">version-api</span>=<span class="value">"2.0"</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="title">books</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"20"</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>  </span><br><span class="line">                   <span class="tag">&lt;<span class="title">title</span>&gt;</span>Don Xijote<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                   <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>Manuel De Cervantes<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"14"</span> <span class="attribute">id</span>=<span class="value">"2"</span>&gt;</span>  </span><br><span class="line">                   <span class="tag">&lt;<span class="title">title</span>&gt;</span>Catcher in the Rye<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"2"</span>&gt;</span>JD Salinger<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"13"</span> <span class="attribute">id</span>=<span class="value">"3"</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Alice in Wonderland<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"3"</span>&gt;</span>Lewis Carroll<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"5"</span> <span class="attribute">id</span>=<span class="value">"4"</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Don Xijote<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"4"</span>&gt;</span>Manuel De Cervantes<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;/<span class="title">books</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="title">response</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>现在来看怎么玩转GPath：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，创建XmlSlurper类  </span></span><br><span class="line">def xparser = new <span class="function"><span class="title">XmlSlurper</span><span class="params">()</span></span>  </span><br><span class="line">def targetFile = new <span class="function"><span class="title">File</span><span class="params">(<span class="string">"test.xml"</span>)</span></span>  </span><br><span class="line"><span class="comment">//轰轰的GPath出场  </span></span><br><span class="line">GPathResult gpathResult =xparser.<span class="function"><span class="title">parse</span><span class="params">(targetFile)</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//开始玩test.xml。现在我要访问id=4的book元素。  </span></span><br><span class="line"><span class="comment">//下面这种搞法，gpathResult代表根元素response。通过e1.e2.e3这种  </span></span><br><span class="line"><span class="comment">//格式就能访问到各级子元素....  </span></span><br><span class="line">def book4 = gpathResult<span class="class">.value</span><span class="class">.books</span><span class="class">.book</span>[<span class="number">3</span>]  </span><br><span class="line"><span class="comment">//得到book4的author元素  </span></span><br><span class="line">def author = book4<span class="class">.author</span>  </span><br><span class="line"><span class="comment">//再来获取元素的属性和textvalue  </span></span><br><span class="line">assert author.<span class="function"><span class="title">text</span><span class="params">()</span></span> == <span class="string">' Manuel De Cervantes '</span>  </span><br><span class="line">获取属性更直观  </span><br><span class="line">author.@id == <span class="string">'4'</span> 或者 author[<span class="string">'@id'</span>] == <span class="string">'4'</span>  </span><br><span class="line">属性一般是字符串，可通过toInteger转换成整数  </span><br><span class="line">author.@id.<span class="function"><span class="title">toInteger</span><span class="params">()</span></span> == <span class="number">4</span>  </span><br><span class="line">好了。GPath就说到这。再看个例子。我在使用Gradle的时候有个需求，就是获取AndroidManifest.xml版本号（versionName）。有了GPath，一行代码搞定，请看：  </span><br><span class="line">def androidManifest = <span class="function"><span class="title">newXmlSlurper</span><span class="params">()</span></span>.<span class="function"><span class="title">parse</span><span class="params">(<span class="string">"AndroidManifest.xml"</span>)</span></span>  </span><br><span class="line">println androidManifest[<span class="string">'@android:versionName'</span>]  </span><br><span class="line">或者  </span><br><span class="line">println androidManifest.@<span class="string">'android:versionName'</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6_更多">3.6  更多</h3><p>作为一门语言，Groovy是复杂的，是需要深入学习和钻研的。一本厚书甚至都无法描述Groovy的方方面面。</p>
<p>Anyway，从使用角度看，尤其是又限定在Gradle这个领域内，能用到的都是Groovy中一些简单的知识。</p>
<h2 id="四、Gradle介绍">四、Gradle介绍</h2><p>现在正式进入Gradle。Gradle是一个工具，同时它也是一个编程框架。前面也提到过，使用这个工具可以完成app的编译打包等工作。当然你也可以用它干其他的事情。</p>
<p>Gradle是什么？学习它到什么地步就可以了？</p>
<p>=====&gt;看待问题的时候，所站的角度非常重要。</p>
<p>–&gt;当你把Gradle当工具看的时候，我们只想着如何用好它。会写、写好配置脚本就OK</p>
<p>–&gt;当你把它当做编程框架看的时候，你可能需要学习很多更深入的内容。</p>
<p>另外，今天我们把它当工具看，明天因为需求发生变化，我们可能又得把它当编程框架看。</p>
<h3 id="4-1_Gradle开发环境部署">4.1  Gradle开发环境部署</h3><p>Gradle的官网：<strong><a href="http://gradle.org/" target="_blank" rel="external">http://gradle.org/</a></strong></p>
<p>文档位置：<a href="https://docs.gradle.org/current/release-notes。其中的**_User" target="_blank" rel="external">https://docs.gradle.org/current/release-notes。其中的**_User</a> Guide_<strong>和</strong><em>DSL Reference</em>**很关键。User Guide就是介绍Gradle的一本书，而DSL Reference是Gradle API的说明。</p>
<p>以Ubuntu为例，下载Gradle：<strong><a href="http://gradle.org/gradle-download/" target="_blank" rel="external">http://gradle.org/gradle-download/</a></strong>  选择<strong>Complete distribution</strong>和<strong>Binary only distribution</strong>都行。然后解压到指定目录。</p>
<p>最后，设置~/.bashrc，把Gradle加到PATH里，如图20所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image022.png" alt=""></p>
<p><strong>执行source ~/.bashrc，初始化环境</strong>。</p>
<p><strong>执行gradle –version，如果成功运行就OK了</strong>。</p>
<p>注意，为什么说Gradle是一个编程框架？来看它提供的API文档：</p>
<p><strong><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></strong></p>
<p>原来，我们编写所谓的编译脚本，其实就是玩Gradle的API….所以它从更底层意义上看，是一个编程框架！</p>
<p>既然是编程框架，我在讲解Gradle的时候，尽量会从API的角度来介绍。有些读者肯定会不耐烦，为嘛这么费事？</p>
<p><strong>从我个人的经历来看：因为我从网上学习到的资料来看，几乎全是从脚本的角度来介绍Gradle，结果学习一通下来，只记住参数怎么配置，却不知道它们都是函数调用，都是严格对应相关API的。</strong></p>
<p>而从API角度来看待Gradle的话，有了SDK文档，你就可以编程。编程是靠记住一行行代码来实现的吗？不是，是在你掌握大体流程，然后根据SDK+API来完成的！</p>
<p>其实，Gradle自己的User Guide也明确说了：</p>
<p><strong>Build scripts are code</strong></p>
<h3 id="4-2_基本组件">4.2  基本组件</h3><p>Gradle是一个框架，它定义一套自己的游戏规则。我们要玩转Gradle，必须要遵守它设计的规则。下面我们来讲讲Gradle的基本组件：</p>
<p>Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：<strong>Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等</strong>。</p>
<p>一个Project到底包含多少个Task，其实是由编译脚本指定的插件决定。插件是什么呢？插件就是用来定义Task，并具体执行这些Task的东西。</p>
<p>刚才说了，Gradle是一个框架，作为框架，它负责定义流程和规则。而具体的编译工作则是通过插件的方式来完成的。比如<strong>编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android Library插件</strong></p>
<p>好了。到现在为止，你知道Gradle中每一个待编译的工程都是一个Project，一个具体的编译过程是由一个一个的Task来定义和执行的。</p>
<p><strong>4.2.1  一个重要的例子</strong></p>
<p>下面我们来看一个实际的例子。这个例子非常有代表意义。图22是一个名为posdevice的目录。这个目录里包含3个Android Library工程，2个Android APP工程。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image024.png" alt=""></p>
<p> 在图22的例子中：</p>
<ul>
<li>CPosDeviceSdk、CPosSystemSdk、CPosSystemSdkxxxImpl是Android Library。<strong>其中，CPosSystemSdkxxxImpl依赖CPosSystemSdk</strong></li>
<li>CPosDeviceServerApk和CPosSdkDemo是Android APP。这些App和SDK有依赖关系。CPosDeviceServerApk依赖CPosDeviceSdk，而CPosSdkDemo依赖所有的Sdk Library。</li>
</ul>
<p>请回答问题，在上面这个例子中，有多少个Project？</p>
<p>答案是：每一个Library和每一个App都是单独的Project。根据Gradle的要求，每一个Project在其根目录下都需要有一个build.gradle。build.gradle文件就是该Project的编译脚本，类似于Makefile。</p>
<p>看起来好像很简单，但是请注意：posdevice虽然包含5个独立的Project，但是要独立编译他们的话，得：</p>
<ol>
<li>cd  某个Project的目录。比如 cd CPosDeviceSdk</li>
<li>然后执行 gradle  xxxx（xxx是任务的名字。对Android来说，assemble这个Task会生成最终的产物，所以gradle assemble）</li>
</ol>
<p>这很麻烦啊，有10个独立Project，就得重复执行10次这样的命令。更有甚者，所谓的独立Project其实有依赖关系的。比如我们这个例子。</p>
<p>那么，我想在posdevice目录下，直接执行gradle assemble，是否能把这5个Project的东西都编译出来呢？</p>
<p>答案自然是可以。在Gradle中，这叫<strong>Multi-Projects Build</strong>。把posdevice改造成支持Gradle的Multi-Projects Build很容易，需要：</p>
<ul>
<li>在posdevice下也添加一个build.gradle。这个build.gradle一般干得活是：配置其他子Project的。比如为子Project添加一些属性。这个build.gradle有没有都无所属。</li>
<li>在posdevice下添加一个名为settings.gradle。这个文件很重要，名字必须是settings.gradle。它里边用来告诉Gradle，这个multiprojects包含多少个子Project。</li>
</ul>
<p>来看settings.gradle的内容，最关键的内容就是告诉Gradle这个multiprojects包含哪些子projects:</p>
<p>[settings.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过include函数，将子Project的名字（其文件夹名）包含进来  </span></span><br><span class="line"><span class="keyword">include</span>  <span class="string">'CPosSystemSdk'</span> ,<span class="string">'CPosDeviceSdk'</span> ,  </span><br><span class="line">       <span class="string">'CPosSdkDemo'</span>,<span class="string">'CPosDeviceServerApk'</span>,<span class="string">'CPosSystemSdkWizarPosImpl'</span></span><br></pre></td></tr></table></figure>
<p>强烈建议：</p>
<p>如果你确实只有一个Project需要编译，我也建议你在目录下添加一个settings.gradle。我们团队内部的所有单个Project都已经改成支持Multiple-Project Build了。改得方法就是添加settings.gradle，然后include对应的project名字。</p>
<p>另外，settings.gradle除了可以include外，还可以设置一些函数。这些函数会在gradle构建整个工程任务的时候执行，所以，可以在settings做一些初始化的工作。比如：我的settings.gradle的内容：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为initMinshengGradleEnvironment的函数。该函数内部完成一些初始化操作</span></span><br><span class="line"><span class="comment">//比如创建特定的目录，设置特定的参数等</span></span><br><span class="line"><span class="keyword">def</span> initMinshengGradleEnvironment()&#123;  </span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment ....."</span>  </span><br><span class="line">    ......<span class="comment">//干一些special的私活....  </span></span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment completes..."</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//settings.gradle加载的时候，会执行initMinshengGradleEnvironment  </span></span><br><span class="line">initMinshengGradleEnvironment()  </span><br><span class="line"><span class="comment">//include也是一个函数：  </span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'CPosSystemSdk'</span> , <span class="string">'CPosDeviceSdk'</span> ,  </span><br><span class="line">      <span class="string">'CPosSdkDemo'</span>,<span class="string">'CPosDeviceServerApk'</span>,<span class="string">'CPosSystemSdkWizarPosImpl'</span></span><br></pre></td></tr></table></figure>
<p><strong>4.2.2  gradle命令介绍</strong></p>
<ol>
<li>gradle projects查看工程信息</li>
</ol>
<p>到目前为止，我们了解了Gradle什么呢？</p>
<ul>
<li><strong>每一个Project都必须设置一个build.gradle文件。至于其内容，我们留到后面再说</strong>。</li>
<li><strong>对于multi-projects build，需要在根目录下也放一个build.gradle，和一个settings.gradle</strong>。</li>
<li><strong>一个Project是由若干tasks来组成的，当gradle xxx的时候，实际上是要求gradle执行xxx任务。这个任务就能完成具体的工作</strong>。</li>
<li>当然，具体的工作和不同的插件有关系。编译Java要使用Java插件，编译Android APP需要使用Android APP插件。这些我们都留待后续讨论</li>
</ul>
<p>gradle提供一些方便命令来查看和Project，Task相关的信息。比如在posdevice中，我想看这个multi projects到底包含多少个子Project：</p>
<p>执行 gradle projects，得到图23：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image025.png" alt=""></p>
<p> 你看，multi projects的情况下，posdevice这个目录对应的build.gradle叫Root Project，它包含5个子Project。</p>
<p>如果你修改settings.gradle，使得include只有一个参数，则gradle projects的子project也会变少，比如图24：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image026.png" alt=""></p>
<ol>
<li>gradle tasks查看任务信息</li>
</ol>
<p>查看了Project信息，这个还比较简单，直接看settings.gradle也知道。那么Project包含哪些Task信息，怎么看呢？图23,24中最后的输出也告诉你了，想看某个Project包含哪些Task信息，只要执行：</p>
<p><strong>gradle project-path:tasks</strong>  就行。注意，<strong>project-path</strong>是目录名，后面必须跟冒号。</p>
<p>对于Multi-project，在根目录中，需要指定你想看哪个poject的任务。不过你要是已经cd到某个Project的目录了，则不需指定Project-path。</p>
<p>来看图25：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image027.png" alt=""></p>
<p> 图25是gradle CPosSystemSdk:tasks的结果。</p>
<ul>
<li>cd CPossystemSdk</li>
<li>gradle tasks 得到同样的结果</li>
</ul>
<p>CPosSystemSdk是一个Android Library工程，Android Library对应的插件定义了好多Task。每种插件定义的Task都不尽相同，这就是所谓的Domain Specific，需要我们对相关领域有比较多的了解。</p>
<p>这些都是后话，我们以后会详细介绍。</p>
<ol>
<li>gradle task-name执行任务</li>
</ol>
<p>图25中列出了好多任务，这时候就可以通过 gradle 任务名来执行某个任务。这和make xxx很像。比如：</p>
<ul>
<li>gradle clean是执行清理任务，和make clean类似。</li>
<li>gradle properites用来查看所有属性信息。</li>
</ul>
<p>gradle tasks会列出每个任务的描述，通过描述，我们大概能知道这些任务是干什么的…..。然后gradle task-name执行它就好。</p>
<p>这里要强调一点：Task和Task之间往往是有关系的，<strong>这就是所谓的依赖关系。比如，assemble task就依赖其他task先执行，assemble才能完成最终的输出</strong>。</p>
<p>依赖关系对我们使用gradle有什么意义呢？</p>
<p>如果知道Task之间的依赖关系，那么开发者就可以添加一些定制化的Task。比如我为assemble添加一个SpecialTest任务，并指定assemble依赖于SpecialTest。当assemble执行的时候，就会先处理完它依赖的task。自然，SpecialTest就会得到执行了…</p>
<p>大家先了解这么多，等后面介绍如何写gradle脚本的时候，这就是调用几个函数的事情，Nothing Special!</p>
<h3 id="4-3_Gradle工作流程">4.3  Gradle工作流程</h3><p>Gradle的工作流程其实蛮简单，用一个图26来表达：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image028.png" alt=""></p>
<p> 图26告诉我们，Gradle工作包含三个阶段：</p>
<ul>
<li>首先是初始化阶段。对我们前面的multi-project build而言，就是执行settings.gradle</li>
<li>Initiliazation phase的下一个阶段是Configration阶段。</li>
<li>Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过API来添加的。</li>
<li>Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。恩？前面说过，一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。所以，我们可以添加一个HOOK，即当Task关系图建立好后，执行一些操作。</li>
<li><p>最后一个阶段就是执行任务了。当然，任务执行完后，我们还可以加Hook。</p>
<p>我在：</p>
</li>
<li><p>settings.gradle加了一个输出。</p>
</li>
<li>在posdevice的build.gradle加了图25中的beforeProject函数。</li>
<li>在CPosSystemSdk加了taskGraph whenReady函数和buidFinished函数。</li>
</ul>
<p>好了，Hook的代码怎么写，估计你很好奇，而且肯定会埋汰，怎么就还没告诉我怎么写Gradle。马上了！</p>
<p>最后，关于Gradle的工作流程，你只要记住：</p>
<ul>
<li>Gradle有一个初始化流程，这个时候settings.gradle会执行。</li>
<li>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。</li>
<li>然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</li>
</ul>
<p><strong>下面来告诉你怎么写代码！</strong></p>
<h3 id="4-4_Gradle编程模型及API实例详解">4.4  Gradle编程模型及API实例详解</h3><p><strong>希望你在进入此节之前，一定花时间把前面内容看一遍！！！</strong></p>
<p><strong><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a></strong>  &lt;==这个文档很重要</p>
<p>Gradle基于Groovy，Groovy又基于Java。所以，Gradle执行的时候和Groovy一样，会把脚本转换成Java对象。Gradle主要有三种对象，这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对端：</p>
<ul>
<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>
<li>Project对象：每一个build.gradle会转换成一个Project对象。</li>
<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>
</ul>
<p>注意，对于其他gradle文件，除非定义了class，否则会转换成一个实现了Script接口的对象。这一点和3.5节中Groovy的脚本类相似</p>
<p>当我们执行gradle的时候，gradle首先是按顺序解析各个gradle文件。这里边就有所所谓的生命周期的问题，即先解析谁，后解析谁。图27是Gradle文档中对生命周期的介绍：结合上一节的内容，相信大家都能看明白了。<strong>现在只需要看红框里的内容：</strong></p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image030.png" alt=""></p>
<p><strong>4.4.1  Gradle对象</strong></p>
<p>我们先来看Gradle对象，它有哪些属性呢？如图28所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image031.png" alt=""></p>
<p> 我在posdevice build.gradle中和settings.gradle中分别加了如下输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在settings.gradle中，则输出"In settings,gradle id is"  </span></span><br><span class="line">println <span class="string">"In posdevice, gradle id is "</span> +gradle.<span class="function"><span class="title">hashCode</span><span class="params">()</span></span>  </span><br><span class="line">println <span class="string">"Home Dir:"</span> + gradle<span class="class">.gradleHomeDir</span>  </span><br><span class="line">println <span class="string">"User Home Dir:"</span> + gradle<span class="class">.gradleUserHomeDir</span>  </span><br><span class="line">println <span class="string">"Parent: "</span> + gradle.parent</span><br></pre></td></tr></table></figure>
<p>得到结果如图29所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image032.png" alt=""></p>
<ul>
<li>你看，在settings.gradle和posdevice build.gradle中，我们得到的gradle实例对象的hashCode是一样的（都是791279786）。</li>
<li>HomeDir是我在哪个目录存储的gradle可执行程序。</li>
<li>User Home Dir：是gradle自己设置的目录，里边存储了一些配置文件，以及编译过程中的缓存文件，生成的类文件，编译中依赖的插件等等。</li>
</ul>
<p>Gradle的函数接口在文档中也有。</p>
<p><strong>4.4.2  Project对象</strong></p>
<p>每一个build.gradle文件都会转换成一个Project对象。在Gradle术语中，Project对象对应的是<strong>Build Script</strong>。</p>
<p>Project包含若干Tasks。另外，由于Project对应具体的工程，所以需要为Project加载所需要的插件，比如为Java工程加载Java插件。<strong>其实，一个Project包含多少Task往往是插件决定的。</strong></p>
<p>所以，在Project中，我们要：</p>
<ul>
<li>加载插件。</li>
<li>不同插件有不同的行话，即不同的配置。我们要在Project中配置好，这样插件就知道从哪里读取源文件等</li>
<li>设置属性。</li>
</ul>
<ol>
<li>加载插件</li>
</ol>
<p>Project的API位于<strong><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></strong>。加载插件是调用它的apply函数.apply其实是Project实现的PluginAware接口定义的：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image033.png" alt=""></p>
<p> 来看代码：</p>
<p>[apply函数的用法]</p>
<p>apply是一个函数，此处调用的是图30中最后一个apply函数。注意，Groovy支持函数调用的时候通过  参数名1:参数值2，参数名2：参数值2 的方式来传递参数</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span>    &lt;==如果是编译Library，则加载此插件</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span>  &lt;==如果是编译Android APP，则加载此插件</span><br></pre></td></tr></table></figure>
<p>除了加载二进制的插件（上面的插件其实都是下载了对应的jar包，这也是通常意义上我们所理解的插件），还可以加载一个gradle文件。为什么要加载gradle文件呢？</p>
<p><strong>其实这和代码的模块划分有关。一般而言，我会把一些通用的函数放到一个名叫utils.gradle文件里。然后在其他工程的build.gradle来加载这个utils.gradle。这样，通过一些处理，我就可以调用utils.gradle中定义的函数了。</strong></p>
<p>加载utils.gradle插件的代码如下：</p>
<p>utils.gradle是我封装的一个gradle脚本，里边定义了一些方便函数，比如读取AndroidManifest.xml中</p>
<p>的versionName，或者是copy jar包/APK包到指定的目录</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: rootProject.<span class="function"><span class="title">getRootDir</span><span class="params">()</span></span>.<span class="function"><span class="title">getAbsolutePath</span><span class="params">()</span></span> + <span class="string">"/utils.gradle"</span></span><br></pre></td></tr></table></figure>
<p>也是使用apply的最后一个函数。那么，apply最后一个函数到底支持哪些参数呢？还是得看图31中的API说明：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image034.png" alt=""></p>
<p> 我这里不遗余力的列出API图片，就是希望大家在写脚本的时候，碰到不会的，一定要去查看API文档！</p>
<ol>
<li>设置属性</li>
</ol>
<p>如果是单个脚本，则不需要考虑属性的跨脚本传播，但是Gradle往往包含不止一个build.gradle文件，比如我设置的utils.gradle，settings.gradle。如何在多个脚本中设置属性呢？</p>
<p>Gradle提供了一种名为<strong>extra property</strong>的方法。<strong>extra property</strong>是额外属性的意思，在第一次定义该属性的时候需要通过ext前缀来标示它是一个额外的属性。定义好之后，后面的存取就不需要ext前缀了。ext属性支持Project和Gradle对象。即Project和Gradle对象都可以设置ext属性</p>
<p>举个例子：</p>
<p>我在settings.gradle中想为Gradle对象设置一些外置属性，所以在initMinshengGradleEnvironment函数中</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> initMinshengGradleEnvironment()&#123;  </span><br><span class="line">    <span class="comment">//属性值从local.properites中读取  </span></span><br><span class="line">    Propertiesproperties = <span class="keyword">new</span> Properties()  </span><br><span class="line">    FilepropertyFile = <span class="keyword">new</span> <span class="keyword">File</span>(rootDir.getAbsolutePath() +<span class="string">"/local.properties"</span>)  </span><br><span class="line">   properties.load(propertyFile.newDataInputStream())  </span><br><span class="line">    <span class="comment">//gradle就是gradle对象。它默认是Settings和Project的成员变量。可直接获取  </span></span><br><span class="line">   <span class="comment">//ext前缀，表明操作的是外置属性。api是一个新的属性名。前面说过，只在  </span></span><br><span class="line">   <span class="comment">//第一次定义或者设置它的时候需要ext前缀  </span></span><br><span class="line">    gradle.ext.api =properties.getProperty(<span class="string">'sdk.api'</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">println</span> gradle.api  <span class="comment">//再次存取api的时候，就不需要ext前缀了  </span></span><br><span class="line">    ......  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再来一个例子强化一下：</p>
<p>我在utils.gradle中定义了一些函数，然后想在其他build.gradle中调用这些函数。那该怎么做呢？</p>
<p>[utils.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utils.gradle中定义了一个获取AndroidManifests.xmlversionName的函数  </span></span><br><span class="line"><span class="keyword">def</span>  getVersionNameAdvanced()&#123;  </span><br><span class="line">  下面这行代码中的<span class="keyword">project</span>是谁？  </span><br><span class="line">   defxmlFile = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">"AndroidManifest.xml"</span>)  </span><br><span class="line">   defrootManifest = <span class="keyword">new</span> XmlSlurper().parse(xmlFile)  </span><br><span class="line">   returnrootManifest[<span class="string">'@android:versionName'</span>]    </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//现在，想把这个API输出到各个Project。由于这个utils.gradle会被每一个Project Apply，所以  </span></span><br><span class="line"><span class="comment">//我可以把getVersionNameAdvanced定义成一个closure，然后赋值到一个外部属性  </span></span><br><span class="line">  下面的ext是谁的ext？  </span><br><span class="line">ext&#123; <span class="comment">//此段花括号中代码是闭包  </span></span><br><span class="line">    <span class="comment">//除了ext.<span class="label">xxx=value这种定义方法外，还可以使用ext&#123;&#125;这种书写方法。  </span></span></span><br><span class="line">    <span class="comment">//ext&#123;&#125;不是ext(Closure)对应的函数调用。但是ext&#123;&#125;中的&#123;&#125;确实是闭包。  </span></span><br><span class="line">    getVersionNameAdvanced = <span class="keyword">this</span>.&amp;getVersionNameAdvanced  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中有两个问题：</p>
<ul>
<li><p>project是谁？</p>
</li>
<li><p>ext是谁的ext？</p>
</li>
</ul>
<p>上面两个问题比较关键，我也是花了很长时间才搞清楚。这两个问题归结到一起，其实就是：</p>
<p><strong>加载utils.gradle的Project对象和utils.gradle本身所代表的Script对象到底有什么关系？</strong></p>
<p>我们在Groovy中也讲过怎么在一个Script中import另外一个Script中定义的类或者函数（见<strong>3.5 脚本类、文件I/O和XML操作一节</strong>）。在Gradle中，这一块的处理比Groovy要复杂，具体怎么搞我还没完全弄清楚，但是Project和utils.gradle对于的Script的对象的关系是：</p>
<ul>
<li>当一个Project apply一个gradle文件的时候，这个gradle文件会转换成一个Script对象。这个，相信大家都已经知道了。</li>
<li>Script中有一个delegate对象，这个delegate默认是加载（即调用apply）它的Project对象。但是，在apply函数中，有一个from参数，还有一个to参数（参考<strong>图31</strong>）。通过to参数，你可以把delegate对象指定为别的东西。</li>
<li>delegate对象是什么意思？当你在Script中操作一些不是Script自己定义的变量，或者函数时候，gradle会到Script的delegate对象去找，看看有没有定义这些变量或函数。</li>
</ul>
<p>现在你知道问题1,2和答案了：</p>
<ul>
<li>问题1：project就是加载utils.gradle的project。由于posdevice有5个project，所以utils.gradle会分别加载到5个project中。所以，getVersionNameAdvanced才不用区分到底是哪个project。反正一个project有一个utils.gradle对应的Script。</li>
<li>问题2：ext：自然就是Project对应的ext了。此处为Project添加了一些closure。那么，在Project中就可以调用getVersionNameAdvanced函数了</li>
</ul>
<p>比如：我在posdevice每个build.gradle中都有如下的代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks.getByName(<span class="string">"assemble"</span>)&#123;  </span><br><span class="line">   it.<span class="keyword">doLast</span>&#123;  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"$project.name: After assemble, jar libs are copied tolocal repository"</span>  </span><br><span class="line">        copyOutput(<span class="keyword">true</span>)  <span class="comment">//copyOutput是utils.gradle输出的closure  </span></span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过这种方式，我将一些常用的函数放到utils.gradle中，然后为加载它的Project设置ext属性。最后，Project中就可以调用这种赋值函数了！</strong></p>
<p>注意：此处我研究的还不是很深，而且我个人感觉：</p>
<ol>
<li>在Java和Groovy中：我们会把常用的函数放到一个辅助类和公共类中，然后在别的地方import并调用它们。</li>
<li><p>但是在Gradle，更正规的方法是在xxx.gradle中定义插件。然后通过添加Task的方式来完成工作。gradle的user guide有详细介绍如何实现自己的插件。</p>
</li>
<li><p>Task介绍</p>
</li>
</ol>
<p>Task是Gradle中的一种数据类型，它代表了一些要执行或者要干的工作。不同的插件可以添加不同的Task。每一个Task都需要和一个Project关联。</p>
<p>Task的API文档位于<strong><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</a></strong>。关于Task，我这里简单介绍下build.gradle中怎么写它，以及Task中一些常见的类型</p>
<p>关于Task。来看下面的例子：</p>
<p>[build.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Task是和Project关联的，所以，我们要利用Project的task函数来创建一个Task  </span></span><br><span class="line"><span class="keyword">task</span> myTask  &lt;==myTask是新建<span class="keyword">Task</span>的名字  </span><br><span class="line"><span class="keyword">task</span> myTask &#123; configure closure &#125;  </span><br><span class="line"><span class="keyword">task</span> myType &lt;&lt; &#123; <span class="keyword">task</span> action &#125; &lt;==注意，&lt;&lt;符号是<span class="keyword">doLast</span>的缩写  </span><br><span class="line"><span class="keyword">task</span> myTask(type: SomeType)  </span><br><span class="line"><span class="keyword">task</span> myTask(type: SomeType) &#123; configure closure &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中都用了Project的一个函数，名为task，注意：</p>
<ul>
<li>一个Task包含若干Action。所以，Task有doFirst和doLast两个函数，用于添加需要最先执行的Action和需要和需要最后执行的Action。Action就是一个闭包。</li>
<li>Task创建的时候可以指定Type，通过<strong>type:名字</strong>表达。这是什么意思呢？其实就是告诉Gradle，这个新建的Task对象会从哪个基类Task派生。比如，Gradle本身提供了一些通用的Task，最常见的有Copy 任务。Copy是Gradle中的一个类。当我们：<strong>task myTask(type:Copy)</strong>的时候，创建的Task就是一个Copy Task。</li>
<li>当我们使用 <strong>task myTask{ xxx}</strong>的时候。花括号是一个closure。这会导致gradle在创建这个Task之后，返回给用户之前，会先执行closure的内容。</li>
<li>当我们使用<strong>task myTask &lt;&lt; {xxx}</strong>的时候，我们创建了一个Task对象，同时把closure做为一个action加到这个Task的action队列中，并且告诉它“最后才执行这个closure”（<strong>注意，&lt;&lt;符号是doLast的代表</strong>）。</li>
</ul>
<p>图32是Project中关于task函数说明：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image035.png" alt=""></p>
<p> 陆陆续续讲了这么些内容，我自己感觉都有点烦了。是得，Gradle用一整本书来讲都嫌不够呢。</p>
<p>anyway，到目前为止，我介绍的都是一些比较基础的东西，还不是特别多。但是后续例子该涉及到的知识点都有了。下面我们直接上例子。这里有两个例子：</p>
<ul>
<li>posdevice的例子</li>
<li>另外一个是单个project的例子</li>
</ul>
<p><strong>4.4.3  posdevice实例</strong></p>
<p>现在正是开始通过例子来介绍怎么玩gradle。这里要特别强调一点，根据Gradle的哲学。gradle文件中包含一些所谓的<strong>Script Block</strong>（<strong>姑且这么称它</strong>）。<strong>Script Block</strong>作用是让我们来配置相关的信息。不同的<strong>SB</strong>有不同的需要配置的东西。这也是我最早说的行话。比如，源码对应的SB，就需要我们配置源码在哪个文件夹里。关于SB，我们后面将见识到！</p>
<p>posdevice是一个multi project。下面包含5个Project。对于这种Project，请大家回想下我们该创建哪些文件？</p>
<ul>
<li>settings.gradle是必不可少的</li>
<li>根目录下的build.gradle。这个我们没讲过，因为posdevice的根目录本身不包含代码，而是包含其他5个子project。</li>
<li>每个project目录下包含对于的build.gradle</li>
<li>另外，我把常用的函数封装到一个名为utils.gradle的脚本里了。</li>
</ul>
<p>马上一个一个来看它们。</p>
<ol>
<li>utils.gradle</li>
</ol>
<p>utils.gradle是我自己加的，为我们团队特意加了一些常见函数。主要代码如下：</p>
<p>[utils.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.util.XmlSlurper  <span class="comment">//解析XML时候要引入这个groovy的package  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> copyFile(String srcFile,dstFile)&#123;  </span><br><span class="line">     ......<span class="comment">//拷贝文件函数，用于将最后的生成物拷贝到指定的目录  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">def</span> rmFile(String targetFile)&#123;  </span><br><span class="line">    .....<span class="comment">//删除指定目录中的文件  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> cleanOutput(<span class="keyword">boolean</span> bJar = <span class="keyword">true</span>)&#123;  </span><br><span class="line">    ....<span class="comment">//clean的时候清理  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> copyOutput(<span class="keyword">boolean</span> bJar = <span class="keyword">true</span>)&#123;  </span><br><span class="line">    ....<span class="comment">//copyOutput内部会调用copyFile完成一次build的产出物拷贝  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> getVersionNameAdvanced()&#123;<span class="comment">//老朋友  </span></span><br><span class="line">   defxmlFile = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">"AndroidManifest.xml"</span>)  </span><br><span class="line">   defrootManifest = <span class="keyword">new</span> XmlSlurper().parse(xmlFile)  </span><br><span class="line">   returnrootManifest[<span class="string">'@android:versionName'</span>]    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//对于android library编译，我会disable所有的debug编译任务  </span></span><br><span class="line"><span class="keyword">def</span> disableDebugBuild()&#123;  </span><br><span class="line">  <span class="comment">//project.tasks包含了所有的tasks，下面的findAll是寻找那些名字中带debug的Task。  </span></span><br><span class="line">  <span class="comment">//返回值保存到targetTasks容器中  </span></span><br><span class="line">  <span class="keyword">def</span> targetTasks = <span class="keyword">project</span>.tasks.<span class="keyword">findAll</span>&#123;<span class="keyword">task</span> -&gt;  </span><br><span class="line">     <span class="keyword">task</span>.name.contains(<span class="string">"Debug"</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//对满足条件的task，设置它为disable。如此这般，这个Task就不会被执行  </span></span><br><span class="line"> targetTasks.<span class="keyword">each</span>&#123;  </span><br><span class="line">     <span class="keyword">println</span><span class="string">"disable debug task  :$&#123;it.name&#125;"</span>  </span><br><span class="line">    it.setEnabled <span class="keyword">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//将函数设置为extra属性中去，这样，加载utils.gradle的Project就能调用此文件中定义的函数了  </span></span><br><span class="line">ext&#123;  </span><br><span class="line">    copyFile= <span class="keyword">this</span>.©<span class="keyword">File</span>  </span><br><span class="line">    rmFile =<span class="keyword">this</span>.&amp;rmFile  </span><br><span class="line">   cleanOutput = <span class="keyword">this</span>.&amp;cleanOutput  </span><br><span class="line">   copyOutput = <span class="keyword">this</span>.©Output  </span><br><span class="line">   getVersionNameAdvanced = <span class="keyword">this</span>.&amp;getVersionNameAdvanced  </span><br><span class="line">   disableDebugBuild = <span class="keyword">this</span>.&amp;disableDebugBuild  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图33展示了被disable的Debug任务的部分信息：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image036.png" alt=""></p>
<ol>
<li>settings.gradle</li>
</ol>
<p>这个文件中我们该干什么？调用include把需要包含的子Project加进来。代码如下：</p>
<p>[settings.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们团队内部建立的编译环境初始化函数 </span><br><span class="line">  这个函数的目的是 </span><br><span class="line">  1  解析一个名为local.properties的文件，读取AndroidSDK和NDK的路径 </span><br><span class="line">  2  获取最终产出物目录的路径。这样，编译完的apk或者jar包将拷贝到这个最终产出物目录中 </span><br><span class="line">  3 获取Android SDK指定编译的版本 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="keyword">def</span> initMinshengGradleEnvironment()&#123;  </span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment ....."</span>  </span><br><span class="line">   Properties properties = <span class="keyword">new</span> Properties()  </span><br><span class="line">   <span class="comment">//local.properites也放在posdevice目录下  </span></span><br><span class="line">    FilepropertyFile = <span class="keyword">new</span> <span class="keyword">File</span>(rootDir.getAbsolutePath()+ <span class="string">"/local.properties"</span>)  </span><br><span class="line">   properties.load(propertyFile.newDataInputStream())  </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">      根据Project、Gradle生命周期的介绍，settings对象的创建位于具体Project创建之前 </span><br><span class="line">      而Gradle底对象已经创建好了。所以，我们把local.properties的信息读出来后，通过 </span><br><span class="line">     extra属性的方式设置到gradle对象中 </span><br><span class="line">      而具体Project在执行的时候，就可以直接从gradle对象中得到这些属性了！ </span><br><span class="line">    */</span>  </span><br><span class="line">    gradle.ext.api =properties.getProperty(<span class="string">'sdk.api'</span>)  </span><br><span class="line">    gradle.ext.sdkDir =properties.getProperty(<span class="string">'sdk.dir'</span>)  </span><br><span class="line">     gradle.ext.ndkDir =properties.getProperty(<span class="string">'ndk.dir'</span>)  </span><br><span class="line">     gradle.ext.localDir =properties.getProperty(<span class="string">'local.dir'</span>)  </span><br><span class="line">    <span class="comment">//指定debugkeystore文件的位置，debug版apk签名的时候会用到  </span></span><br><span class="line">    gradle.ext.debugKeystore= properties.getProperty(<span class="string">'debug.keystore'</span>)  </span><br><span class="line">     ......  </span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment completes..."</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//初始化  </span></span><br><span class="line">initMinshengGradleEnvironment()  </span><br><span class="line"><span class="comment">//添加子Project信息  </span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'CPosSystemSdk'</span> , <span class="string">'CPosDeviceSdk'</span> ,<span class="string">'CPosSdkDemo'</span>,<span class="string">'CPosDeviceServerApk'</span>, <span class="string">'CPosSystemSdkWizarPosImpl'</span></span><br></pre></td></tr></table></figure>
<p>注意，对于Android来说，local.properties文件是必须的，它的内容如下：</p>
<p>[local.properties]</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local.dir=<span class="regexp">/home/innost</span><span class="regexp">/workspace/minsheng</span>-flat-dir/  </span><br><span class="line"><span class="regexp">//</span>注意，根据<span class="constant">Android</span> <span class="constant">Gradle</span>的规范，只有下面两个属性是必须的，其余都是我自己加的  </span><br><span class="line">sdk.dir=<span class="regexp">/home/innost</span><span class="regexp">/workspace/android</span>-aosp-sdk/  </span><br><span class="line">ndk.dir=<span class="regexp">/home/innost</span><span class="regexp">/workspace/android</span>-aosp-ndk/  </span><br><span class="line">debug.keystore=<span class="regexp">/home/innost</span><span class="regexp">/workspace/tools</span><span class="regexp">/mykeystore.jks  </span><br><span class="line">sdk.api=android-19</span></span><br></pre></td></tr></table></figure>
<p>再次强调，<strong>sdk.dir</strong>和<strong>ndk.dir</strong>是Android Gradle必须要指定的，其他都是我自己加的属性。当然。不编译<strong>ndk</strong>，就不需要<strong>ndk.dir</strong>属性了。</p>
<ol>
<li>posdevice build.gradle</li>
</ol>
<p>作为multi-project根目录，一般情况下，它的build.gradle是做一些全局配置。来看我的build.gradle</p>
<p>[posdevice build.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个subprojects&#123;&#125;就是一个Script Block  </span></span><br><span class="line"><span class="keyword">subprojects</span> &#123;  </span><br><span class="line">  <span class="keyword">println</span><span class="string">"Configure for $project.name"</span> <span class="comment">//遍历子Project，project变量对应每个子Project  </span></span><br><span class="line">  <span class="keyword">buildscript</span> &#123;  <span class="comment">//这也是一个SB  </span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;<span class="comment">//repositories是一个SB  </span></span><br><span class="line">       <span class="comment">///jcenter是一个函数，表示编译过程中依赖的库，所需的插件可以在jcenter仓库中  </span></span><br><span class="line">       <span class="comment">//下载。  </span></span><br><span class="line">       jcenter()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">dependencies</span> &#123; <span class="comment">//SB  </span></span><br><span class="line">        <span class="comment">//dependencies表示我们编译的时候，依赖android开发的gradle插件。插件对应的  </span></span><br><span class="line">       <span class="comment">//class path是com.android.tools.build。版本是1.2.3  </span></span><br><span class="line">        <span class="keyword">classpath</span><span class="string">'com.android.tools.build:gradle:1.2.3'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="comment">//为每个子Project加载utils.gradle 。当然，这句话可以放到buildscript花括号之后  </span></span><br><span class="line">   applyfrom: rootProject.getRootDir().getAbsolutePath() + <span class="string">"/utils.gradle"</span>  </span><br><span class="line"> &#125;<span class="comment">//buildscript结束  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉解释得好苍白，SB在Gradle的API文档中也是有的。先来看Gradle定义了哪些SB。如图34所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image037.png" alt=""></p>
<p> 你看，subprojects、dependencies、repositories都是SB。那么SB到底是什么？它是怎么完成所谓配置的呢？</p>
<p>仔细研究，你会发现SB后面都需要跟一个花括号，而花括号，恩，我们感觉里边可能一个Closure。由于图34说，这些SB的Description都有“Configure xxx for this project”，<strong>所以很可能subprojects是一个函数，然后其参数是一个Closure。是这样的吗？</strong></p>
<p>Absolutely right。只是这些函数你直接到Project API里不一定能找全。不过要是你好奇心重，不妨到<strong><a href="https://docs.gradle.org/current/javadoc/" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/</a></strong>，选择<strong>Index</strong>这一项，然后<strong>ctrl+f</strong>，输入图34中任何一个Block，你都会找到对应的函数。比如我替你找了几个API，如图35所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image038.png" alt=""></p>
<p> 特别提示：当你下次看到一个不认识的SB的时候，就去看API吧。</p>
<p>下面来解释代码中的各个SB：</p>
<ul>
<li>subprojects：它会遍历posdevice中的每个子Project。在它的Closure中，默认参数是子Project对应的Project对象。由于其他SB都在subprojects花括号中，所以相当于对每个Project都配置了一些信息。</li>
<li>buildscript：它的closure是在一个类型为ScriptHandler的对象上执行的。主意用来所依赖的classpath等信息。通过查看ScriptHandler API可知，在buildscript SB中，你可以调用ScriptHandler提供的repositories(Closure )、dependencies(Closure)函数。这也是为什么repositories和dependencies两个SB为什么要放在buildscript的花括号中的原因。<strong>明白了？这就是所谓的行话，得知道规矩。不知道规矩你就乱了。记不住规矩，又不知道查SDK，那么就彻底抓瞎，只能到网上到处找答案了！</strong></li>
<li>关于repositories和dependencies，大家直接看API吧。后面碰到了具体代码我们再来介绍</li>
</ul>
<ol>
<li>CPosDeviceSdk build.gradle</li>
</ol>
<p>CPosDeviceSdk是一个Android Library。按Google的想法，Android Library编译出来的应该是一个AAR文件。但是我的项目有些特殊，我需要发布CPosDeviceSdk.jar包给其他人使用。jar在编译过程中会生成，但是它不属于Android Library的标准输出。在这种情况下，我需要在编译完成后，主动copy jar包到我自己设计的产出物目录中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Library工程必须加载此插件。注意，加载了Android插件就不要加载Java插件了。因为Android  </span></span><br><span class="line"><span class="comment">//插件本身就是拓展了Java插件  </span></span><br><span class="line">apply plugin: <span class="string">'com.android.library'</span>   </span><br><span class="line"><span class="comment">//android的编译，增加了一种新类型的ScriptBlock--&gt;android  </span></span><br><span class="line">android &#123;  </span><br><span class="line">       <span class="comment">//你看，我在local.properties中设置的API版本号，就可以一次设置，多个Project使用了  </span></span><br><span class="line">      <span class="comment">//借助我特意设计的gradle.ext.api属性  </span></span><br><span class="line">       compileSdkVersion =gradle.api  <span class="comment">//这两个红色的参数必须设置  </span></span><br><span class="line">       buildToolsVersion  = <span class="string">"22.0.1"</span>  </span><br><span class="line">       <span class="keyword">sourceSets</span>&#123; <span class="comment">//配置源码路径。这个sourceSets是Java插件引入的  </span></span><br><span class="line">       main&#123; <span class="comment">//main：Android也用了  </span></span><br><span class="line">           manifest.srcFile <span class="string">'AndroidManifest.xml'</span> <span class="comment">//这是一个函数，设置manifest.srcFile  </span></span><br><span class="line">           aidl.srcDirs=[<span class="string">'src'</span>] <span class="comment">//设置aidl文件的目录  </span></span><br><span class="line">           java.srcDirs=[<span class="string">'src'</span>] <span class="comment">//设置java文件的目录  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">   <span class="keyword">dependencies</span> &#123;  <span class="comment">//配置依赖关系  </span></span><br><span class="line">      <span class="comment">//compile表示编译和运行时候需要的jar包，fileTree是一个函数，  </span></span><br><span class="line">     <span class="comment">//dir:'libs'，表示搜索目录的名称是libs。include:['*.jar']，表示搜索目录下满足*.jar名字的jar  </span></span><br><span class="line">     <span class="comment">//包都作为依赖jar文件  </span></span><br><span class="line">       <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  <span class="comment">//android SB配置完了  </span></span><br><span class="line"><span class="comment">//clean是一个Task的名字，这个Task好像是Java插件（这里是Android插件）引入的。  </span></span><br><span class="line"><span class="comment">//dependsOn是一个函数，下面这句话的意思是 clean任务依赖cposCleanTask任务。所以  </span></span><br><span class="line"><span class="comment">//当你gradle clean以执行clean Task的时候，cposCleanTask也会执行  </span></span><br><span class="line">clean.dependsOn <span class="string">'cposCleanTask'</span>  </span><br><span class="line"><span class="comment">//创建一个Task，  </span></span><br><span class="line"><span class="keyword">task</span> cposCleanTask() &lt;&lt;&#123;  </span><br><span class="line">    cleanOutput(<span class="keyword">true</span>)  <span class="comment">//cleanOutput是utils.gradle中通过extra属性设置的Closure  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//前面说了，我要把jar包拷贝到指定的目录。对于Android编译，我一般指定gradle assemble  </span></span><br><span class="line"><span class="comment">//它默认编译debug和release两种输出。所以，下面这个段代码表示：  </span></span><br><span class="line"><span class="comment">//tasks代表一个Projects中的所有Task，是一个容器。getByName表示找到指定名称的任务。  </span></span><br><span class="line"><span class="comment">//我这里要找的assemble任务，然后我通过doLast添加了一个Action。这个Action就是copy  </span></span><br><span class="line"><span class="comment">//产出物到我设置的目标目录中去  </span></span><br><span class="line">tasks.getByName(<span class="string">"assemble"</span>)&#123;  </span><br><span class="line">   it.<span class="keyword">doLast</span>&#123;  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"$project.name: After assemble, jar libs are copied tolocal repository"</span>  </span><br><span class="line">        copyOutput(<span class="keyword">true</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span><br><span class="line">  因为我的项目只提供最终的release编译出来的Jar包给其他人，所以不需要编译debug版的东西 </span><br><span class="line">  当Project创建完所有任务的有向图后，我通过afterEvaluate函数设置一个回调Closure。在这个回调 </span><br><span class="line">  Closure里，我disable了所有Debug的Task </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="keyword">project</span>.afterEvaluate&#123;  </span><br><span class="line">    disableDebugBuild()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android自己定义了好多ScriptBlock。Android定义的DSL参考文档在</p>
<p><strong><a href="https://developer.android.com/tools/building/plugin-for-gradle.html" target="_blank" rel="external">https://developer.android.com/tools/building/plugin-for-gradle.html</a></strong>下载。注意，它居然没有提供在线文档。</p>
<p>图36所示为Android的DSL参考信息。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image039.png" alt=""></p>
<p>图37为<strong>buildToolsVersion</strong>和<strong>compileSdkVersion</strong>的说明：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image040.png" alt=""></p>
<p> 从图37可知，这两个变量是必须要设置的…..</p>
<ol>
<li>CPosDeviceServerApk build.gradle</li>
</ol>
<p>再来看一个APK的build，它包含NDK的编译，并且还要签名。根据项目的需求，我们只能签debug版的，而release版的签名得发布unsigned包给领导签名。另外，CPosDeviceServerAPK依赖CPosDeviceSdk。</p>
<p>虽然我可以先编译CPosDeviceSdk，得到对应的jar包，然后设置CPosDeviceServerApk直接依赖这个jar包就好。但是我更希望CPosDeviceServerApk能直接依赖于CPosDeviceSdk这个工程。这样，整个posdevice可以做到这几个Project的依赖关系是最新的。</p>
<p>[build.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span>  <span class="comment">//APK编译必须加载这个插件  </span></span><br><span class="line">android &#123;  </span><br><span class="line">      compileSdkVersion gradle.api  </span><br><span class="line">      buildToolsVersion <span class="string">"22.0.1"</span>  </span><br><span class="line">      <span class="keyword">sourceSets</span>&#123;  <span class="comment">//差不多的设置  </span></span><br><span class="line">       main&#123;  </span><br><span class="line">           manifest.srcFile <span class="string">'AndroidManifest.xml'</span>  </span><br><span class="line">          <span class="comment">//通过设置jni目录为空，我们可不使用apk插件的jni编译功能。为什么？因为据说  </span></span><br><span class="line">         <span class="comment">//APK插件的jni功能好像不是很好使....晕菜  </span></span><br><span class="line">          jni.srcDirs = []   </span><br><span class="line">           jniLibs.srcDir <span class="string">'libs'</span>  </span><br><span class="line">            aidl.srcDirs=[<span class="string">'src'</span>]  </span><br><span class="line">           java.srcDirs=[<span class="string">'src'</span>]  </span><br><span class="line">           res.srcDirs=[<span class="string">'res'</span>]  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//main结束  </span></span><br><span class="line">   signingConfigs &#123; <span class="comment">//设置签名信息配置  </span></span><br><span class="line">       debug &#123;  <span class="comment">//如果我们在local.properties设置使用特殊的keystore，则使用它  </span></span><br><span class="line">           <span class="comment">//下面这些设置，无非是函数调用....请务必阅读API文档  </span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">project</span>.gradle.debugKeystore != <span class="keyword">null</span>)&#123;  </span><br><span class="line">              storeFile <span class="keyword">file</span>(<span class="string">"file://$&#123;project.gradle.debugKeystore&#125;"</span>)  </span><br><span class="line">              storePassword <span class="string">"android"</span>  </span><br><span class="line">              keyAlias <span class="string">"androiddebugkey"</span>  </span><br><span class="line">              keyPassword <span class="string">"android"</span>  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;<span class="comment">//signingConfigs结束  </span></span><br><span class="line">     buildTypes &#123;  </span><br><span class="line">       debug &#123;  </span><br><span class="line">           signingConfig signingConfigs.debug  </span><br><span class="line">           jniDebuggable <span class="keyword">false</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//buildTypes结束  </span></span><br><span class="line">   <span class="keyword">dependencies</span> &#123;  </span><br><span class="line">        <span class="comment">//compile：project函数可指定依赖multi-project中的某个子project  </span></span><br><span class="line">       <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':CPosDeviceSdk'</span>)  </span><br><span class="line">       <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])  </span><br><span class="line">   &#125; <span class="comment">//dependices结束  </span></span><br><span class="line">  <span class="keyword">repositories</span>&#123;  </span><br><span class="line">   <span class="keyword">flatDir</span> &#123;<span class="comment">//flatDir：告诉gradle，编译中依赖的jar包存储在dirs指定的目录  </span></span><br><span class="line">           name <span class="string">"minsheng-gradle-local-repository"</span>  </span><br><span class="line">            dirsgradle.LOCAL_JAR_OUT <span class="comment">//LOCAL_JAR_OUT是我存放编译出来的jar包的位置  </span></span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;<span class="comment">//repositories结束  </span></span><br><span class="line">&#125;<span class="comment">//android结束  </span></span><br><span class="line"><span class="comment">/* </span><br><span class="line">   创建一个Task，类型是Exec，这表明它会执行一个命令。我这里让他执行ndk的 </span><br><span class="line">   ndk-build命令，用于编译ndk。关于Exec类型的Task，请自行脑补Gradle的API </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="comment">//注意此处创建task的方法，是直接&#123;&#125;喔，那么它后面的tasks.withType(JavaCompile)  </span></span><br><span class="line"><span class="comment">//设置的依赖关系，还有意义吗？Think！如果你能想明白，gradle掌握也就差不多了  </span></span><br><span class="line"><span class="keyword">task</span> buildNative(type: Exec, <span class="keyword">description</span>: <span class="string">'CompileJNI source via NDK'</span>) &#123;  </span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">project</span>.gradle.ndkDir == <span class="keyword">null</span>) <span class="comment">//看看有没有指定ndk.dir路径  </span></span><br><span class="line">          <span class="keyword">println</span> <span class="string">"CANNOT Build NDK"</span>  </span><br><span class="line">       <span class="keyword">else</span>&#123;  </span><br><span class="line">            commandLine <span class="string">"/$&#123;project.gradle.ndkDir&#125;/ndk-build"</span>,  </span><br><span class="line">               <span class="string">'-C'</span>, <span class="keyword">file</span>(<span class="string">'jni'</span>).absolutePath,  </span><br><span class="line">               <span class="string">'-j'</span>, <span class="keyword">Runtime</span>.<span class="keyword">runtime</span>.availableProcessors(),  </span><br><span class="line">               <span class="string">'all'</span>, <span class="string">'NDK_DEBUG=0'</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"> tasks.withType(JavaCompile) &#123;  </span><br><span class="line">       compileTask -&gt; compileTask.dependsOn buildNative  </span><br><span class="line">  &#125;  </span><br><span class="line">  ......    </span><br><span class="line"> <span class="comment">//对于APK，除了拷贝APK文件到指定目录外，我还特意为它们加上了自动版本命名的功能  </span></span><br><span class="line"> tasks.getByName(<span class="string">"assemble"</span>)&#123;  </span><br><span class="line">       it.<span class="keyword">doLast</span>&#123;  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"$project.name: After assemble, jar libs are copied tolocal repository"</span>  </span><br><span class="line">       <span class="keyword">project</span>.ext.versionName = android.defaultConfig.versionName  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"\t versionName = $versionName"</span>  </span><br><span class="line">       copyOutput(<span class="keyword">false</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>结果展示</li>
</ol>
<p>在posdevice下执行gradle assemble命令，最终的输出文件都会拷贝到我指定的目录，结果如图38所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image041.png" alt=""></p>
<p> 图38所示为posdevice<strong> gradle assemble</strong>的执行结果：</p>
<ul>
<li>library包都编译release版的，copy到xxx/javaLib目录下</li>
<li>apk编译debug和release-unsigned版的，copy到apps目录下</li>
<li>所有产出物都自动从AndroidManifest.xml中提取versionName。</li>
</ul>
<p><strong>4.4.4  实例2</strong></p>
<p>下面这个实例也是来自一个实际的APP。这个APP对应的是一个单独的Project。但是根据我前面的建议，我会把它改造成支持Multi-Projects Build的样子。即在工程目录下放一个settings.build。</p>
<p>另外，这个app有一个特点。它有三个版本，分别是debug、release和demo。这三个版本对应的代码都完全一样，但是在运行的时候需要从assets/runtime_config文件中读取参数。参数不同，则运行的时候会跳转到debug、release或者demo的逻辑上。</p>
<p>注意：我知道assets/runtime_config这种做法不decent，但，这是一个既有项目，我们只能做小范围的适配，而不是伤筋动骨改用更好的方法。另外，从未来的需求来看，暂时也没有大改的必要。</p>
<p>引入gradle后，我们该如何处理呢？</p>
<p>解决方法是：在编译build、release和demo版本前，在build.gradle中自动设置runtime_config的内容。代码如下所示：</p>
<p>[build.gradle]</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="symbol">'com</span>.android.application'  <span class="comment">//加载APP插件  </span></span><br><span class="line"><span class="comment">//加载utils.gradle  </span></span><br><span class="line">apply from:rootProject.getRootDir().getAbsolutePath() + <span class="string">"/utils.gradle"</span>  </span><br><span class="line"><span class="comment">//buildscript设置android app插件的位置  </span></span><br><span class="line">buildscript &#123;  </span><br><span class="line">   repositories &#123; jcenter() &#125;  </span><br><span class="line">   dependencies &#123; classpath <span class="symbol">'com</span>.android.tools.build:gradle:<span class="number">1.2</span><span class="number">.3</span>' &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//androidScriptBlock  </span></span><br><span class="line">android &#123;  </span><br><span class="line">   compileSdkVersion gradle.api  </span><br><span class="line">   buildToolsVersion <span class="string">"22.0.1"</span>  </span><br><span class="line">   sourceSets&#123;<span class="comment">//源码设置SB  </span></span><br><span class="line">        main&#123;  </span><br><span class="line">           manifest.srcFile <span class="symbol">'AndroidManifest</span>.xml'  </span><br><span class="line">           jni.srcDirs = []  </span><br><span class="line">           jniLibs.srcDir <span class="symbol">'lib</span>s'  </span><br><span class="line">           aidl.srcDirs=[<span class="symbol">'sr</span>c']  </span><br><span class="line">           java.srcDirs=[<span class="symbol">'sr</span>c']  </span><br><span class="line">           res.srcDirs=[<span class="symbol">'re</span>s']  </span><br><span class="line">           assets.srcDirs = [<span class="symbol">'asset</span>s'] <span class="comment">//多了一个assets目录  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   signingConfigs &#123;<span class="comment">//签名设置  </span></span><br><span class="line">       debug &#123;  <span class="comment">//debug对应的SB。注意  </span></span><br><span class="line">           <span class="keyword">if</span>(project.gradle.debugKeystore != <span class="literal">null</span>)&#123;  </span><br><span class="line">               storeFile file(<span class="string">"file://$&#123;project.gradle.debugKeystore&#125;"</span>)  </span><br><span class="line">               storePassword <span class="string">"android"</span>  </span><br><span class="line">               keyAlias <span class="string">"androiddebugkey"</span>  </span><br><span class="line">               keyPassword <span class="string">"android"</span>  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     最关键的内容来了： buildTypesScriptBlock. </span><br><span class="line">     buildTypes和上面的signingConfigs，当我们在build.gradle中通过&#123;&#125;配置它的时候， </span><br><span class="line">     其背后的所代表的对象是NamedDomainObjectContainer&lt;BuildType&gt; 和 </span><br><span class="line">     NamedDomainObjectContainer&lt;SigningConfig&gt; </span><br><span class="line">     注意，NamedDomainObjectContainer&lt;BuildType/或者SigningConfig&gt;是一种容器， </span><br><span class="line">     容器的元素是BuildType或者SigningConfig。我们在debug&#123;&#125;要填充BuildType或者 </span><br><span class="line">    SigningConfig所包的元素，比如storePassword就是SigningConfig类的成员。而proguardFile等 </span><br><span class="line">    是BuildType的成员。 </span><br><span class="line">    那么，为什么要使用NamedDomainObjectContainer这种数据结构呢？因为往这种容器里 </span><br><span class="line">    添加元素可以采用这样的方法： 比如signingConfig为例 </span><br><span class="line">    signingConfig&#123;//这是一个NamedDomainObjectContainer&lt;SigningConfig&gt; </span><br><span class="line">       test1&#123;//新建一个名为test1的SigningConfig元素，然后添加到容器里 </span><br><span class="line">         //在这个花括号中设置SigningConfig的成员变量的值 </span><br><span class="line">       &#125; </span><br><span class="line">      test2&#123;//新建一个名为test2的SigningConfig元素，然后添加到容器里 </span><br><span class="line">         //在这个花括号中设置SigningConfig的成员变量的值 </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    在buildTypes中，Android默认为这几个NamedDomainObjectContainer添加了 </span><br><span class="line">    debug和release对应的对象。如果我们再添加别的名字的东西，那么gradleassemble的时候 </span><br><span class="line">    也会编译这个名字的apk出来。比如，我添加一个名为test的buildTypes，那么gradle assemble </span><br><span class="line">    就会编译一个xxx-test-yy.apk。在此，test就好像debug、release一样。 </span><br><span class="line">   */</span>  </span><br><span class="line">   buildTypes&#123;  </span><br><span class="line">        debug&#123; <span class="comment">//修改debug的signingConfig为signingConfig.debug配置  </span></span><br><span class="line">           signingConfig signingConfigs.debug  </span><br><span class="line">        &#125;  </span><br><span class="line">        demo&#123; <span class="comment">//demo版需要混淆  </span></span><br><span class="line">           proguardFile <span class="symbol">'proguard</span>-project.txt'  </span><br><span class="line">           signingConfig signingConfigs.debug  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="comment">//release版没有设置，所以默认没有签名，没有混淆  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      ......<span class="comment">//其他和posdevice 类似的处理。来看如何动态生成runtime_config文件  </span></span><br><span class="line">   <span class="function"><span class="keyword">def</span>  <span class="title">runtime_config_file</span> =</span> <span class="symbol">'assets</span>/runtime_config'  </span><br><span class="line">   <span class="comment">/* </span><br><span class="line">   我们在gradle解析完整个任务之后，找到对应的Task，然后在里边添加一个doFirst Action </span><br><span class="line">   这样能确保编译开始的时候，我们就把runtime_config文件准备好了。 </span><br><span class="line">   注意，必须在afterEvaluate里边才能做，否则gradle没有建立完任务有向图，你是找不到 </span><br><span class="line">   什么preDebugBuild之类的任务的 </span><br><span class="line">   */</span>  </span><br><span class="line">   project.afterEvaluate&#123;  </span><br><span class="line">      <span class="comment">//找到preDebugBuild任务，然后添加一个Action   </span></span><br><span class="line">      tasks.getByName(<span class="string">"preDebugBuild"</span>)&#123;  </span><br><span class="line">           it.doFirst&#123;  </span><br><span class="line">               println <span class="string">"generate debug configuration for $&#123;project.name&#125;"</span>  </span><br><span class="line">               <span class="function"><span class="keyword">def</span> <span class="title">configFile</span> =</span> <span class="keyword">new</span> <span class="type">File</span>(runtime_config_file)  </span><br><span class="line">               configFile.withOutputStream&#123;os-&gt;  </span><br><span class="line">                   os &lt;&lt; <span class="type">I</span> am <span class="type">Debug</span>\n'  <span class="comment">//往配置文件里写 I am Debug  </span></span><br><span class="line">                &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="comment">//找到preReleaseBuild任务  </span></span><br><span class="line">       tasks.getByName(<span class="string">"preReleaseBuild"</span>)&#123;  </span><br><span class="line">           it.doFirst&#123;  </span><br><span class="line">               println <span class="string">"generate release configuration for $&#123;project.name&#125;"</span>  </span><br><span class="line">               <span class="function"><span class="keyword">def</span> <span class="title">configFile</span> =</span> <span class="keyword">new</span> <span class="type">File</span>(runtime_config_file)  </span><br><span class="line">               configFile.withOutputStream&#123;os-&gt;  </span><br><span class="line">                   os &lt;&lt; <span class="type">I</span> am release\n'  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="comment">//找到preDemoBuild。这个任务明显是因为我们在buildType里添加了一个demo的元素  </span></span><br><span class="line">      <span class="comment">//所以Android APP插件自动为我们生成的  </span></span><br><span class="line">       tasks.getByName(<span class="string">"preDemoBuild"</span>)&#123;  </span><br><span class="line">           it.doFirst&#123;  </span><br><span class="line">               println <span class="string">"generate offlinedemo configuration for$&#123;project.name&#125;"</span>  </span><br><span class="line">               <span class="function"><span class="keyword">def</span> <span class="title">configFile</span> =</span> <span class="keyword">new</span> <span class="type">File</span>(runtime_config_file)  </span><br><span class="line">               configFile.withOutputStream&#123;os-&gt;  </span><br><span class="line">                   os &lt;&lt; <span class="type">I</span> am <span class="type">Demo</span>\n'  </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> .....<span class="comment">//copyOutput</span></span><br></pre></td></tr></table></figure>
<p>最终的结果如图39所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image042.png" alt=""></p>
<p> 几个问题，为什么我知道有preXXXBuild这样的任务？</p>
<p><strong>答案：gradle tasks –all查看所有任务。然后，多尝试几次，直到成功</strong></p>
<p>五、总结</p>
<p>到此，我个人觉得Gradle相关的内容都讲完了。很难相信我仅花了1个小时不到的时间就为实例2添加了gradle编译支持。在一周以前，我还觉得这是个心病。回想学习gradle的一个月时间里，走过不少弯路，求解问题的思路也和最开始不一样：</p>
<ul>
<li>最开始的时候，我一直把gradle当做脚本看。然后到处到网上找怎么配置gradle。可能能编译成功，但是完全不知道为什么。比如NameDomainObjectContainer，为什么有debug、release。能自己加别的吗？不知道怎么加，没有章法，没有参考。出了问题只能google，找到一个解法，试一试，成功就不管。这么搞，心里不踏实。</li>
<li>另外，对语法不熟悉，尤其是Groovy语法，虽然看了下快速教材，但总感觉一到gradle就看不懂。主要问题还是闭包，比如Groovy那一节写得文件拷贝的例子中的withOutputStream，还有gradle中的withType，都是些啥玩意啊？</li>
<li>所以后来下决心先把Groovy学会，主要是把自己暴露在闭包里边。另外，Groovy是一门语言，总得有SDK说明吧。写了几个例子，慢慢体会到Groovy的好处，也熟悉Groovy的语法了。</li>
<li>接着开始看Gradle。Gradle有几本书，我看过Gradle in Action。说实话，看得非常痛苦。现在想起来，Gradle其实比较简单，知道它的生命周期，知道它怎么解析脚本，知道它的API，几乎很快就能干活。而Gradle In Action一上来就很细，而且没有从API角度介绍。说个很有趣的事情，书中有个类似下面的例子</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> myTask  &lt;&lt;  &#123;</span><br><span class="line">   <span class="keyword">println</span> <span class="string">' I am myTask'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书中说，如果代码没有加&lt;&lt;，则这个任务在脚本<strong>initialization</strong>（也就是你无论执行什么任务，这个任务都会被执行，<strong>I am myTask</strong>都会被输出）的时候执行，如果加了<strong>&lt;&lt;</strong>，则在gradle myTask后才执行。</p>
<p>我开始完全不知道为什么，死记硬背。<strong>现在你明白了吗？？？？</strong></p>
<p>这和我们调用task这个函数的方式有关！如果没有&lt;&lt;，则闭包在task函数返回前会执行，而如果加了&lt;&lt;，则变成调用myTask.doLast添加一个Action了，自然它会等到grdle myTask的时候才会执行！</p>
<p>现在想起这个事情我还是很愤怒，API都说很清楚了……而且，如果你把Gradle当做编程框架来看，对于我们这些程序员来说，写这几百行代码，那还算是事嘛？？</p>
<p>转自：<a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank" rel="external">http://www.infoq.com/cn/articles/android-in-depth-gradle</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/11/29/about-github-create-self-blog/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[关于用Github搭建个人博客的记录]]></title>
                <content><![CDATA[<p>一些搭建博客过程中遇到的问题和技巧</p>
<p> 刚开始的时候以为不是自己的空间，会有一些Github或者其他的网站的推广的一些东西，要知道那些东西是会让我有那么点不爽的存在~<br><br><br>当然，后来事实证明我是错的==<br><a id="more"></a></p>
<h2 id="初识">初识</h2><p>  起初是<a href="http://www.xiaoduanguoguo.com/" target="_blank" rel="external">小段果果</a>给我说的这个东西<br><br><br>  刚开始的时候以为不是自己的空间，会有一些Github或者其他的网站的推广的一些东西，要知道那些东西是会让我有那么点不爽的存在~<br><br><br>当然，后来事实证明我是错的==</p>
<h2 id="开始">开始</h2><p>根据<a href="http://www.xiaoduanguoguo.com/" target="_blank" rel="external">小段果果</a>给的网站<a href="http://www.jianshu.com/p/5368aa49e193" title="使用Github建立个人博客" target="_blank" rel="external">【使用Github建立个人博客】</a>，准备开始搭建个人博客。<br><br><br>开始按照那篇文章中的步骤一步步来做。我这里只是再对那个文档进行一些补充。不会很详细的讲解每个步骤。<br></p>
<h3 id="注册Github账号">注册Github账号</h3><p><a href="https://github.com/" target="_blank" rel="external">注册Github</a>(之前已经有了就可免去此步骤)<br></p>
<h3 id="安装本机所需环境">安装本机所需环境<br></h3><p> 官方：<br><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a><br><br> <a href="http://git-scm.com/" target="_blank" rel="external">Git</a><br></p>
<p>百度云：<br><a href="http://pan.baidu.com/s/15JnVw" target="_blank" rel="external">Node.js下载</a> 密码：os3g<br><br><a href="http://pan.baidu.com/s/1ntMrMYX" target="_blank" rel="external">Git下载</a> 密码：g4cx<br></p>
<p>两个东西的安装都是一路下一步就可以的。（友情提示：最好先安装Node.js，然后再安装Git。)<br></p>
<h3 id="安装hexo">安装hexo</h3><p>两个东西都安装完之后，在某个地方创建一个文件夹(这个文件夹可以理解为你以后的工作空间，尽量取名为hexo吧~在下文中称这个目录为“本地空间”)，然后刚创建的文件夹内点击鼠标右键，会有一个Git Bash选项(右键菜单中没有git bash选项，可以进入开始菜单找到git bash，然后通过cd进入相应目录执行命令。)，选择Git Bash；之后会弹出一个类似命令行的窗口，在那个命令行窗口里输入下面这条命令来安装hexo(下文中的“执行命令”，都是在这样的方式里打开的命令行窗口里执行)：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p>
<p><br>（如果提示找不到npm，可能是因为你先安装的git，然后安装的Node.js造成的。也有可能Node.js版本不对。可以将你电脑上的GitheNode.js都卸载掉，然后下载我给的两个地址下载，之后先安装Node.js，最后安装Git；或许会解决问题）<br><br>安装完hexo之后还要继续输入命令对hexo进行初始化：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p>
<p>咱们一般都不会重复的造轮子，所以安装依赖包啥的其他步骤请参照<a href="http://www.jianshu.com/p/5368aa49e193" title="使用Github建立个人博客" target="_blank" rel="external">【使用Github建立个人博客】</a></p>
<p>博客中的：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>这两个命令可以直接用： <br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>替代</p>
<h3 id="SSH配置">SSH配置</h3><p>跟着步骤生成一个ssh-key就好</p>
<h2 id="连接Github">连接Github</h2><h3 id="先在Github上创建一个仓库">先在Github上创建一个仓库</h3><p>仓库名字是由固定格式的：<br><br><br> 用户名.github.io<br><br>例如我的用户名是w1216220482，新建的仓库就必须是：w1216220482.github.io<br><br>这个仓库名新建好后同时也是一个二级域名。而且能正常访问的。<br><br>相关资料：<a href="https://help.github.com/articles/using-jekyll-with-pages/#troubleshooting" target="_blank" rel="external">Github Page help！</a></p>
<h3 id="给项目添加ssh-key">给项目添加ssh-key</h3><p>找不到添加地方的童鞋，在右上角你的头像的处点击出的下拉菜单里有个setting，点进去后就能看到SSH keys这个项了。<br>把id_rsa.pub里的所有内容复制到key的文本框里，标题不用填写，最后点击Add key就OK了</p>
<h3 id="配置hexo中github地址">配置hexo中github地址</h3><p>在本地空间根目录下有_config.yml文件，找到里面的deploy字段(如果没有就添加)，我们需要配置该字段的三个属性：type、repository、branch<br><br><code>注意：在_config.yml配置文件中的所有字段后面都要加空格，否则可能会出一些问题！</code><br><br><br>例如我的用户名是w1216220482，则配置为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: http://github.com/w1216220482/w1216220482.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>关于type属性，我之前看网上是用的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: github</span><br></pre></td></tr></table></figure></p>
<p>但是使用时发现不能成功连接上github，所以用了另一个方法：<br><br>将github修改为git，然后在本地工作空间右键Git Bash，输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>可成功连接Github。(猜测可能是缺少github插件，这个方法是将github插件修改为了git插件。可能不用修改为git，但是需要输入命令：npm install –save hexo-github才能正常使用~但是没看到教程说过，所以也没试)</p>
<p>酱紫之后呢，应该就能成功的连接上Github了，测试测试：<br><br>之前创建仓库的时候是空的，现在在本地空间右键Git Bash出来的命令窗口里输入hexo clean，执行成功后输入hexo g，等待执行完成，然后输入hexo d，等待上传，过程中会让你输入账户名和密码，依次输入账户名和密码就ok，(我输入的是github的账户名和密码，因为我配置ssh的时候用的是github的账户名和密码，所以不会搞错，但是SSH配置的是其他账户名密码的童鞋就自己测试吧！~看看是哪个用户名密码，知道的好心人可以顺便在下方评论！(网上说是配置SSH时输入的的密码))<br>执行结束后在浏览器里查看那个创建的项目中是否有了数据，如果有了，就说明成功连上了，如果没有~检查下哪里出了问题！重新测试下！</p>
<h2 id="博客相关设置">博客相关设置</h2><h3 id="主题挑选">主题挑选</h3><p>之前初始化hexo的时候就默认自带了一套主题，如果不喜欢，可以在<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo主题库</a>中进行挑选。(点击图片是预览，点击名称是到github上)<br></p>
<h3 id="更换主题">更换主题</h3><p>在上一步挑选完毕之后，点击你选上的那个主题的名称，进入该主题的github，里面都会有该主题的安装方式和说明。<br>例如我用的主题是<a href="https://github.com/wuchong/jacman" target="_blank" rel="external">jacman</a>，里面会有它的一些安装、配置和说明！<br>我想要从默认主题切换为jacman主题，就需要在hexo(本地工作空间)根目录的_config.yml文件中配置博客使用的主题，找到文件中theme字段，将后面的主题名称(默认是landscape)更改为jacman，你可以在你的本地空间中看到themes目录，里面是你所拥有的主题。文件夹的名称就是主题的名称。</p>
<h3 id="本地预览你的博客效果">本地预览你的博客效果</h3><p>执行命令开启本地服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>然后在浏览器输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 查看效果（这个地址是默认的配置地址，如果修改过相关的配置，就不一样(都会修改，地址肯定自己也知道)）；</p>
<h3 id="整站配置文件说明">整站配置文件说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 博客标题</span><br><span class="line">subtitle: 次标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">email: 邮箱</span><br><span class="line">language: zh-CN</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line">url: http://www.freehao123.com <span class="comment">#域名</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/ <span class="comment">#URL结构</span></span><br><span class="line">tag_dir: tags <span class="comment">#标签</span></span><br><span class="line">archive_dir: archives <span class="comment">#汇总</span></span><br><span class="line">category_dir: categories <span class="comment">#分类</span></span><br><span class="line">code_dir: downloads/code</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line">new_post_name: :title.md <span class="comment"># 新的文章名</span></span><br><span class="line">default_layout: post <span class="comment">#New的默认</span></span><br><span class="line">auto_spacing: <span class="literal">false</span> <span class="comment"># Add spaces between asian     characters and western characters</span></span><br><span class="line">titlecase: <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line">external_link: <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">max_open_file: <span class="number">100</span></span><br><span class="line">multi_thread: <span class="literal">true</span></span><br><span class="line">filename_<span class="keyword">case</span>: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="literal">false</span></span><br><span class="line">highlight: <span class="comment">#代码高亮</span></span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  line_number: <span class="literal">true</span></span><br><span class="line"> tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag #分类与标签</span></span><br><span class="line">default_category: uncategorized </span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Archives </span></span><br><span class="line"><span class="comment">## 2: Enable pagination #激活分页</span></span><br><span class="line"><span class="comment">## 1: Disable pagination #禁止分页</span></span><br><span class="line"><span class="comment">## 0: Fully Disable #全部禁止</span></span><br><span class="line">archive: <span class="number">1</span></span><br><span class="line">category: <span class="number">1</span></span><br><span class="line">tag: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">port: <span class="number">4000</span> <span class="comment">#预览端口</span></span><br><span class="line">logger: <span class="literal">false</span></span><br><span class="line">logger_format:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format #时间格式</span></span><br><span class="line">date_format: MMM D YYYY</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination #分页数</span></span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus #Disqus评论</span></span><br><span class="line">disqus_shortname: freehao123 </span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line">theme: jacman  <span class="comment">#主题</span></span><br><span class="line">exclude_generator:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment #上传</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git <span class="comment">#上传方式</span></span><br><span class="line">  repository: http://github.com/w1216220482/w1216220482.github.io.git <span class="comment">#仓库地址</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h2 id="扩展：绑定域名">扩展：绑定域名</h2><p>当然，此步骤不是必须的，只是作为扩展了解。因为你现在已经可以通过 你的Github用户名.github.io 来访问你的博客了！所以这个不是必要步骤=</p>
<h3 id="前奏">前奏</h3><p>我记得我应该在上文某个犄角旮旯里说过。新建的仓库，<font color="red"><strong>必须</strong></font>按照那个格式来建。<br>为啥乳此的强调这个呢，这个故事有点长，就不说了(NND，LZ当初搞了一上午没找到原因~C)</p>
<h3 id="准备">准备</h3><p>1，能正常解析的域名一个<br><br>2，已经搞定的Github二级域名博客一个<br><br>3，那啥那啥那啥<br><br>好，有了这三样东西，你就可以开始你的独立域名之旅了~</p>
<h3 id="域名解析">域名解析</h3><p>域名相关的知识，这里就不过多的阐述了。<br><br>将你的博客域名解析一个CNAME类型的，地址为你在github的博客地址(用户名.github.io)。记得去掉http://。<br></p>
<h3 id="配置Github仓库">配置Github仓库</h3><p>解析完成后在你的博客所在仓库的根目录点击+号，新建一个文件<br><img src="http://i.imgur.com/ejEWzI5.png" alt=""><br><br>文件名叫CNAME，然后文件的内容是你刚解析到你博客地址的域名（解析的那个域名就写哪个域名，是二级域名就填写二级域名，例如：github.eagleweb.xyz）</p>
<p>乳此完成之后，等待一会儿，访问你刚才的域名。如果看到了你的博客，就说明成功了，如果看到说连接错误，那就是失败了。</p>
<p><br></p>
<p>每次写完博客提交之后，CNAME文件总是会消失的问题：<br>解决办法：将CNAME文件放到主题包的source目录下面。(答案来自<a href="http://wdbaoge.com/" target="_blank" rel="external">无敌小包哥</a>)</p>
<h2 id="博客插件的安装与卸载">博客插件的安装与卸载</h2><p><a href="https://hexo.io/plugins/" target="_blank" rel="external">插件库</a><br><br>安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 插件名称 --save</span><br></pre></td></tr></table></figure></p>
<p>卸载插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 插件名称 --save</span><br></pre></td></tr></table></figure></p>
<h2 id="博客搭建相关资料">博客搭建相关资料</h2><h3 id="搭建前准备">搭建前准备</h3><p><a href="https://github.com" target="_blank" rel="external">Github</a><br><br></p>
<h3 id="hexo相关">hexo相关</h3><p><a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">hexo系列指南</a><br><br><a href="http://www.jianshu.com/p/5368aa49e193" target="_blank" rel="external">使用Github建立个人博客</a><br><br><a href="http://www.freehao123.com/hexo-node-js/" target="_blank" rel="external">Hexo免费静态博客安装和使用方法-基于Node.js高效率静态博客程序</a><br><br><br><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客</a><br><br><br><a href="http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.html" target="_blank" rel="external">一步步在Github上创建博客主页-最新版</a><br></p>
<h3 id="博客配置相关">博客配置相关</h3><p><a href="https://hexo.io/plugins/" target="_blank" rel="external">插件库</a><br><br><br><a href="https://hexo.io/themes/" target="_blank" rel="external">主题库</a><br><br><br><a href="http://zn.baidu.com" target="_blank" rel="external">百度站内搜索</a><br><br><a href="http://tongji.baidu.com" target="_blank" rel="external">百度统计</a><br><br><a href="http://www.jiathis.com/" target="_blank" rel="external">jiathis分享</a><br><br><a href="http://duoshuo.com/" target="_blank" rel="external">多说社会化评论</a><br></p>
<h3 id="Markdown快速入门">Markdown快速入门</h3><p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown快速入门</a><br></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	
	
	   
	<url>
        <loc>http://github.eagleweb.xyz/tags/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[tags]]></title>
                <content><![CDATA[<p>.</p>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/search/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title></title>
                <content><![CDATA[<script type="text/javascript">(function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=13039785338213961459' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();</script>

<p><div id="bdcs-frame-box"></div></p>
<script type="text/javascript">
var bdcsFrameSid="13039785338213961459";
var bdcsFrameWidth = 552;
var bdcsFrameWt = 1;
var bdcsFrameHt = 1;
var bdcsFrameResultNum = 10;
var bdcsFrameBgColor = "#ffffff";
</script>
<script type="text/javascript" src="http://zhannei.baidu.com/static/js/iframe.js"></script>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/googlee6fab509e0e3c496.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title></title>
                <content><![CDATA[google-site-verification: googlee6fab509e0e3c496.html]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/categories/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[categories]]></title>
                <content><![CDATA[<p>.</p>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/about/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[菜鹰帅帅]]></title>
                <content><![CDATA[<p>大家好，我是菜鹰帅帅。</p>
<p>————— 游戏 才刚刚开始！<br><br><br><br><br></p>
<p>正在进行的作品：</p>
<p><a href="http://www.mumayi.com/android-9.html" target="_blank" rel="external">M桌面 http://www.mumayi.com/android-9.html</a><br><br></p>
<p>个人无聊编写的小玩意：<br><br>暂不公布</p>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/404.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title></title>
                <content><![CDATA[
<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://github.eagleweb.xyz/" homepagename="回到我的主页"></script>]]></content>
            </display>
        </data>
    </url>
    
  
</urlset>