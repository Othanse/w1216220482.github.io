<?xml version="1.0" encoding="UTF-8"?>
<urlset>
	 
	 
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/13/%E7%BC%96%E7%A8%8B%E7%9A%84%E6%99%BA%E6%85%A7/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[编程的智慧]]></title>
                <content><![CDATA[<p>编程是一种创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而由于软件行业喜欢标新立异，喜欢把简单的事情搞复杂，我希望这些文字<a id="more"></a>能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。</p>

<h3 id="反复推敲代码">反复推敲代码</h3><p>既然“天才是百分之一的灵感，百分之九十九的汗水”，那我先来谈谈这汗水的部分吧。有人问我，提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。</p>

<p>在IU的时候，由于Dan Friedman的严格教导，我们以写出冗长复杂的代码为耻。如果你代码多写了几行，这老顽童就会大笑，说：“当年我解决这个问题，只写了5行代码，你回去再想想吧……” 当然，有时候他只是夸张一下，故意刺激你的，其实没有人能只用5行代码完成。然而这种提炼代码，减少冗余的习惯，却由此深入了我的骨髓。</p>

<p>有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量，其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。</p>

<p>有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。</p>

<p>就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。</p>

<p>所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。</p>

<h3 id="写优雅的代码">写优雅的代码</h3><p>人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。</p>

<p>如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。</p>

<p>优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句，它看起来就会像这个样子：</p>

<pre><code>if (...) {
  if (...) {
    ...
  } else {
    ...
  }
} else if (...) {
  ...
} else {
  ...
}
</code></pre>

<p>注意到了吗？在我的代码里面，if语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且else分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么if语句最好有两个分支。</p>

<h3 id="写模块化的代码">写模块化的代码</h3><p>有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的VCS repo里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。</p>

<p>真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。</p>

<p>想要达到很好的模块化，你需要做到以下几点：</p>

<ul><br><li><p>避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过40行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是50行。我可以一目了然的看见一个40行的函数，而不需要滚屏。只有40行而不是50行的原因是，我的眼球不转的话，最大的视角只看得到40行代码。</p><br><br><p>如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。</p></li><br><li><p>制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。</p><br><br><p>有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种过时的观念。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。</p><br><br><p>同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种过时的观念。在早期的C语言编译器里，只有宏是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。</p></li><br><li><p>每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数：</p><br><br><pre><code>void foo() {<br>  if (getOS().equals(“MacOS”)) {<br>    a();<br>  } else {<br>    b();<br>  }<br>  c();<br>  if (getOS().equals(“MacOS”)) {<br>    d();<br>  } else {<br>    e();<br>  }<br>}<br></code></pre><br><br><p>写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有<code>c()</code>是两种系统共有的，而其它的<code>a()</code>, <code>b()</code>, <code>d()</code>, <code>e()</code>都属于不同的分支。</p><br><br><p>这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数：</p><br><br><pre><code>void fooMacOS() {<br>  a();<br>  c();<br>  d();<br>}<br></code></pre><br><br><p>和</p><br><br><pre><code>void fooOther() {<br>  b();<br>  c();<br>  e();<br>}<br></code></pre><br><br><p>如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样：</p><br><br><pre><code>void foo() {<br>  a();<br>  b()<br>  c();<br>  if (getOS().equals(“MacOS”)) {<br>    d();<br>  } else {<br>    e();<br>  }<br>}<br></code></pre><br><br><p>其中<code>a()</code>，<code>b()</code>，<code>c()</code>都是一样的，只有<code>d()</code>和<code>e()</code>根据系统有所不同。那么你可以把<code>a()</code>，<code>b()</code>，<code>c()</code>提取出去：</p><br><br><pre><code>void preFoo() {<br>  a();<br>  b()<br>  c();<br></code></pre><br><br><p>然后制造两个函数：</p><br><br><pre><code>void fooMacOS() {<br>  preFoo();<br>  d();<br>}<br></code></pre><br><br><p>和</p><br><br><pre><code>void fooOther() {<br>  preFoo();<br>  e();<br>}<br></code></pre><br><br><p>这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。</p></li><br><li><p>避免使用全局变量和类成员（class member）来传递信息，尽量使用局部变量和参数。有些人写代码，经常用类成员来传递信息，就像这样：</p><br><br><pre><code class="`"> class A {<br>   String x;<br><br>   void findX() {<br>      …<br>      x = …;<br>   }<br><br>   void foo() {<br>     findX();<br>     …<br>     print(x);<br>   }<br> }<br></code></pre><br><br><p> 首先，他使用<code>findX()</code>，把一个值写入成员<code>x</code>。然后，使用<code>x</code>的值。这样，<code>x</code>就变成了<code>findX</code>和<code>print</code>之间的数据通道。由于<code>x</code>属于<code>class A</code>，这样程序就失去了模块化的结构。由于这两个函数依赖于成员x，它们不再有明确的输入和输出，而是依赖全局的数据。<code>findX</code>和<code>foo</code>不再能够离开<code>class A</code>而存在，而且由于类成员还有可能被其他代码改变，代码变得难以理解，难以确保正确性。</p><br><br><p> 如果你使用局部变量而不是类成员来传递信息，那么这两个函数就不需要依赖于某一个class，而且更加容易理解，不易出错：</p><br><br><pre><code class="`"> String findX() {<br>    …<br>    x = …;<br>    return x;<br> }<br> void foo() {<br>   int x = findX();<br>   print(x);<br> }<br></code></pre></li><br></ul>


<h3 id="写可读的代码">写可读的代码</h3><p>有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。</p>

<p>实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。</p>

<p>有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。</p>

<p>如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：</p>

<ol><br><li><p>使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：</p><br><br><pre><code>// put elephant1 into fridge2<br>put(elephant1, fridge2);<br></code></pre><br><br><p>由于我的函数名<code>put</code>，加上两个有意义的变量名<code>elephant1</code>和<code>fridge2</code>，已经说明了这是在干什么（把大象放进冰箱），所以上面那句注释完全没有必要。</p></li><br><li><p>局部变量应该尽量接近使用它的地方。有些人喜欢在函数最开头定义很多局部变量，然后在下面很远的地方使用它，就像这个样子：</p><br><br><pre><code>void foo() {<br>  int index = …;<br>  …<br>  …<br>  bar(index);<br>  …<br>}<br></code></pre><br><br><p>由于这中间都没有使用过<code>index</code>，也没有改变过它所依赖的数据，所以这个变量定义，其实可以挪到接近使用它的地方：</p><br><br><pre><code>void foo() {<br>  …<br>  …<br>  int index = …;<br>  bar(index);<br>  …<br>}<br></code></pre><br><br><p>这样读者看到<code>bar(index)</code>，不需要向上看很远就能发现<code>index</code>是如何算出来的。而且这种短距离，可以加强读者对于这里的“计算顺序”的理解。否则如果index在顶上，读者可能会怀疑，它其实保存了某种会变化的数据，或者它后来又被修改过。如果index放在下面，读者就清楚的知道，index并不是保存了什么可变的值，而且它算出来之后就没变过。</p><br><br><p>如果你看透了局部变量的本质——它们就是电路里的导线，那你就能更好的理解近距离的好处。变量定义离用的地方越近，导线的长度就越短。你不需要摸着一根导线，绕来绕去找很远，就能发现接收它的端口，这样的电路就更容易理解。</p></li><br><li><p>局部变量名字应该简短。这貌似跟第一点相冲突，简短的变量名怎么可能有意义呢？注意我这里说的是局部变量，因为它们处于局部，再加上第2点已经把它放到离使用位置尽量近的地方，所以根据上下文你就会容易知道它的意思：</p><br><br><p>比如，你有一个局部变量，表示一个操作是否成功：</p><br><br><pre><code>boolean successInDeleteFile = deleteFile(“foo.txt”);<br>if (successInDeleteFile) {<br>  …<br>} else {<br>  …<br>}<br></code></pre><br><br><p>这个局部变量<code>successInDeleteFile</code>大可不必这么啰嗦。因为它只用过一次，而且用它的地方就在下面一行，所以读者可以轻松发现它是<code>deleteFile</code>返回的结果。如果你把它改名为<code>success</code>，其实读者根据一点上下文，也知道它表示”success in deleteFile”。所以你可以把它改成这样：</p><br><br><pre><code>boolean success = deleteFile(“foo.txt”);<br>if (success) {<br>  …<br>} else {<br>  …<br>}<br></code></pre><br><br><p>这样的写法不但没漏掉任何有用的语义信息，而且更加易读。<code>successInDeleteFile</code>这种”<a href="https://en.wikipedia.org/wiki/CamelCase" target="_blank" rel="external">camelCase</a>“，如果超过了三个单词连在一起，其实是很碍眼的东西，所以如果你能用一个单词表示同样的意义，那当然更好。</p></li><br><li><p>不要重用局部变量。很多人写代码不喜欢定义新的局部变量，而喜欢“重用”同一个局部变量，通过反复对它们进行赋值，来表示完全不同意思。比如这样写：</p><br><br><pre><code>String msg;<br>if (…) {<br>  msg = “succeed”;<br>  log.info(msg);<br>} else {<br>  msg = “failed”;<br>  log.info(msg);<br>}<br></code></pre><br><br><p>虽然这样在逻辑上是没有问题的，然而却不易理解，容易混淆。变量<code>msg</code>两次被赋值，表示完全不同的两个值。它们立即被<code>log.info</code>使用，没有传递到其它地方去。这种赋值的做法，把局部变量的作用域不必要的增大，让人以为它可能在将来改变，也许会在其它地方被使用。更好的做法，其实是定义两个变量：</p><br><br><pre><code>if (…) {<br>  String msg = “succeed”;<br>  log.info(msg);<br>} else {<br>  String msg = “failed”;<br>  log.info(msg);<br>}<br></code></pre><br><br><p>由于这两个<code>msg</code>变量的作用域仅限于它们所处的if语句分支，你可以很清楚的看到这两个<code>msg</code>被使用的范围，而且知道它们之间没有任何关系。</p></li><br><li><p>把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子：</p><br><br><pre><code>…<br>// put elephant1 into fridge2<br>openDoor(fridge2);<br>if (elephant1.alive()) {<br>  …<br>} else {<br>   …<br>}<br>closeDoor(fridge2);<br>…<br></code></pre><br><br><p>如果你把这片代码提出去定义成一个函数：</p><br><br><pre><code>void put(Elephant elephant, Fridge fridge) {<br>  openDoor(fridge);<br>  if (elephant.alive()) {<br>    …<br>  } else {<br>     …<br>  }<br>  closeDoor(fridge);<br>}<br></code></pre><br><br><p>这样原来的代码就可以改成：</p><br><br><pre><code>…<br>put(elephant1, fridge2);<br>…<br></code></pre><br><br><p>更加清晰，而且注释也没必要了。</p></li><br><li><p>把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里使用大量嵌套的函数。像这样：</p><br><br><pre><code>Pizza pizza = makePizza(crust(salt(), butter()),<br>   topping(onion(), tomato(), sausage()));<br></code></pre><br><br><p>这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样：</p><br><br><pre><code>Crust crust = crust(salt(), butter());<br>Topping topping = topping(onion(), tomato(), sausage());<br>Pizza pizza = makePizza(crust, topping);<br></code></pre><br><br><p>这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。</p></li><br><li><p>在合理的地方换行。对于绝大部分的程序语言，代码的逻辑是和空白字符无关的，所以你可以在几乎任何地方换行，你也可以不换行。这样的语言设计，是一个好东西，因为它给了程序员自由控制自己代码格式的能力。然而，它也引起了一些问题，因为很多人不知道如何合理的换行。</p></li><br></ol>


<p>  有些人喜欢利用IDE的自动换行机制，编辑之后用一个热键把整个代码重新格式化一遍，IDE就会把超过行宽限制的代码自动折行。可是这种自动这行，往往没有根据代码的逻辑来进行，不能帮助理解代码。自动换行之后可能产生这样的代码：</p>

<pre><code class="```">   if (someLongCondition1() &amp;&amp; someLongCondition2() &amp;&amp; someLongCondition3() &amp;&amp; 
     someLongCondition4()) {
     ...
   }
</code></pre>

<p>   由于<code>someLongCondition4()</code>超过了行宽限制，被编辑器自动换到了下面一行。虽然满足了行宽限制，换行的位置却是相当任意的，它并不能帮助人理解这代码的逻辑。这几个boolean表达式，全都用<code>&amp;&amp;</code>连接，所以它们其实处于平等的地位。为了表达这一点，当需要折行的时候，你应该把每一个表达式都放到新的一行，就像这个样子：</p>

<pre><code class="```">   if (someLongCondition1() &amp;&amp; 
       someLongCondition2() &amp;&amp; 
       someLongCondition3() &amp;&amp; 
       someLongCondition4()) {
     ...
   }
</code></pre>

<p>   这样每一个条件都对齐，里面的逻辑就很清楚了。再举个例子：</p>

<pre><code class="```">   log.info("failed to find file {} for command {}, with exception {}", file, command,
     exception);
</code></pre>

<p>   这行因为太长，被自动折行成这个样子。<code>file</code>，<code>command</code>和<code>exception</code>本来是同一类东西，却有两个留在了第一行，最后一个被折到第二行。它就不如手动换行成这个样子：</p>

<pre><code class="```">   log.info("failed to find file {} for command {}, with exception {}",
     file, command, exception);
</code></pre>

<p>   把格式字符串单独放在一行，而把它的参数一并放在另外一行，这样逻辑就更加清晰。</p>

<p>   为了避免IDE把这些手动调整好的换行弄乱，很多IDE（比如IntelliJ）的自动格式化设定里都有“保留原来的换行符”的设定。如果你发现IDE的换行不符合逻辑，你可以修改这些设定，然后在某些地方保留你自己的手动换行。</p>

<p>说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫Chai的JavaScript测试工具，可以让你这样写代码：</p>

<pre><code>expect(foo).to.be.a('string');
expect(foo).to.equal('bar');
expect(foo).to.have.length(3);
expect(tea).to.have.property('flavors').with.length(3);
</code></pre>

<p>这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。</p>

<h3 id="写简单的代码">写简单的代码</h3><p>程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。</p>

<p>并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信奈的那一套。</p>

<p>现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。</p>

<ul><br><li><p>避免使用自增减表达式（i++，++i，i–，–i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。</p><br><br><p>其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。比如，如果你想写<code>foo(i++)</code>，你完全可以把它拆成<code>int t = i; i += 1; foo(t);</code>。如果你想写<code>foo(++i)</code>，可以拆成<code>i += 1; foo(i);</code> 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。</p><br><br><p>有人也许以为i++或者++i的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在for循环的update部分，比如<code>for(int i = 0; i &lt; 5; i++)</code>。另一种情况是写成单独的一行，比如<code>i++;</code>。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如<code>foo(i++)</code>，<code>foo(++i) + foo(i)</code>，…… 没有人应该知道，或者去追究这些是什么意思。</p></li><br><li><p>永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如C，Java都允许你在if语句里面只有一句话的时候省略掉花括号：</p><br><br><pre><code>if (…)<br>  action1();<br></code></pre><br><br><p>咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话<code>action2()</code>到这个if里面，于是你就把代码改成：</p><br><br><pre><code>if (…)<br>  action1();<br>  action2();<br></code></pre><br><br><p>为了美观，你很小心的使用了<code>action1()</code>的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在if的条件为真的时候执行，然而<code>action2()</code>却其实在if外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。</p><br><br><p>那么你问，谁会这么傻，我在加入<code>action2()</code>的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把<code>action2()</code>去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的if有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是if-else语句，把花括号全都打上，就可以想都不用想了，就当C和Java没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。</p><br><br><p>有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。</p></li><br><li><p>合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于<code>1 + 2 <em> 3</em></code>这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出<code>2 &lt;&lt; 7 - 2  3</code>这样的表达式，而完全不用括号。</p><br><br><p>这里的问题，在于移位操作<code>&lt;&lt;</code>的优先级，是很多人不熟悉，而且是违反常理的。由于<code>x &lt;&lt; 1</code>相当于把<code>x</code>乘以2，很多人误以为这个表达式相当于<code>(2 &lt;&lt; 7) - (2 <em> 3)</em></code>，所以等于250。然而实际上<code>&lt;&lt;</code>的优先级比加法<code>+</code>还要低，所以这表达式其实相当于<code>2 &lt;&lt; (7 - 2  3)</code>，所以等于4！</p><br><br><p>解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成<code>2 &lt;&lt; (7 - 2 * 3)</code>。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记<code>&lt;&lt;</code>的优先级就能理解代码。</p></li><br><li><p>避免使用continue和break。循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。</p><br><br><p>出现continue或者break的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。改写循环的办法有多种：</p><br><br><ol><br><li>如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。</li><br><li>如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。</li><br><li>有时候你可以把break替换成return，从而去掉break。</li><br><li>如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。</li><br></ol><br><br><br><p>下面我对这些情况举一些例子。</p><br><br><p>情况1：下面这段代码里面有一个continue：</p><br><br><pre><code>List&lt;String&gt; goodNames = new ArrayList&lt;&gt;();<br>for (String name: names) {<br>  if (name.contains(“bad”)) {<br>    continue;<br>  }<br>  goodNames.add(name);<br>  …<br>}<br></code></pre><br><br><p>它说：“如果name含有’bad’这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚continue会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有continue和break的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。</p><br><br><p>其实，我们只需要把continue的条件反向，这段代码就可以很容易的被转换成等价的，不含continue的代码：</p><br><br><pre><code>List&lt;String&gt; goodNames = new ArrayList&lt;&gt;();<br>for (String name: names) {<br>  if (!name.contains(“bad”)) {<br>    goodNames.add(name);<br>    …<br>  }<br>}<br></code></pre><br><br><p><code>goodNames.add(name);</code>和它之后的代码全部被放到了if里面，多了一层缩进，然而continue却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在name不含有’bad’这个词的时候，把它加到goodNames的链表里面……”</p><br><br><p>情况2：for和while头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉break。</p><br><br><p>比如下面这段代码：</p><br><br><pre><code>while (condition1) {<br>  …<br>  if (condition2) {<br>    break;<br>  }<br>}<br></code></pre><br><br><p>当condition成立的时候，break会退出循环。其实你只需要把condition2反转之后，放到while头部的终止条件，就可以去掉这种break语句。改写后的代码如下：</p><br><br><pre><code>while (condition1 &amp;&amp; !condition2) {<br>  …<br>}<br></code></pre><br><br><p>这种情况表面上貌似只适用于break出现在循环开头或者末尾的时候，然而其实大部分时候，break都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。</p><br><br><p>情况3：很多break退出循环之后，其实接下来就是一个return。这种break往往可以直接换成return。比如下面这个例子：</p><br><br><pre><code>public boolean hasBadName(List&lt;String&gt; names) {<br>    boolean result = false;<br><br>    for (String name: names) {<br>        if (name.contains(“bad”)) {<br>            result = true;<br>            break;<br>        }<br>    }<br>    return result;<br>}<br></code></pre><br><br><p>这个函数检查names链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个break语句。这个函数可以被改写成：</p><br><br><pre><code>public boolean hasBadName(List&lt;String&gt; names) {<br>    for (String name: names) {<br>        if (name.contains(“bad”)) {<br>            return true;<br>        }<br>    }<br>    return false;<br>}<br></code></pre><br><br><p>改进后的代码，在name里面含有“bad”的时候，直接用<code>return true</code>返回，而不是对result变量赋值，break出去，最后才返回。如果循环结束了还没有return，那就返回false，表示没有找到这样的名字。使用return来代替break，这样break语句和result这个变量，都一并被消除掉了。</p><br><br><p>我曾经见过很多其他使用continue和break的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的break和continue，都可以通过替换成return语句，或者翻转if条件的方式来消除掉。剩下的1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。</p></li><br></ul>


<h3 id="写直观的代码">写直观的代码</h3><p>我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix命令行有一种“巧妙”的写法是这样：</p>

<pre><code>command1 &amp;&amp; command2 &amp;&amp; command3
</code></pre>

<p>由于Shell语言的逻辑操作<code>a &amp;&amp; b</code>具有“短路”的特性，如果<code>a</code>等于false，那么<code>b</code>就没必要执行了。这就是为什么当command1成功，才会执行command2，当command2成功，才会执行command3。同样，</p>

<pre><code>command1 || command2 || command3
</code></pre>

<p>操作符<code>||</code>也有类似的特性。上面这个命令行，如果command1成功，那么command2和command3都不会被执行。如果command1失败，command2成功，那么command3就不会被执行。</p>

<p>这比起用if语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码：</p>

<pre><code>if (action1() || action2() &amp;&amp; action3()) {
  ...
}
</code></pre>

<p>你看得出来这代码是想干什么吗？action2和action3什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果action1失败了，执行action2，如果action2成功了，执行action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了<code>||</code>的语义里面，你需要知道<code>||</code>的短路特性，以及逻辑或的语义才能知道这里面在说“如果action1失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。</p>

<p>其实，这种写法是滥用了逻辑操作<code>&amp;&amp;</code>和<code>||</code>的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替if语句的。也就是说，它们只是碰巧可以达到某些if语句的效果，但你不应该因此就用它来代替if语句。如果你这样做了，就会让代码晦涩难懂。</p>

<p>上面的代码写成笨一点的办法，就会清晰很多：</p>

<pre><code>if (!action1()) {
  if (action2()) {
    action3();
  }
}
</code></pre>

<p>这里我很明显的看出这代码在说什么，想都不用想：如果action1()失败了，那么执行action2()，如果action2()成功了，执行action3()。你发现这里面的一一对应关系吗？<code>if</code>=如果，<code>!</code>=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。</p>

<h3 id="写无懈可击的代码">写无懈可击的代码</h3><p>在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的if语句。我写出的if语句，大部分都有两个分支，所以我的代码很多看起来是这个样子：</p>

<pre><code>if (...) {
  if (...) {
    ...
    return false;
  } else {
    return true;
  }
} else if (...) {
  ...
  return false;
} else {
  return true;
}
</code></pre>

<p>使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。</p>

<p>很多人写if语句喜欢省略else的分支，因为他们觉得有些else分支的代码重复了。比如我的代码里，两个else分支都是<code>return true</code>。为了避免重复，他们省略掉那两个else分支，只在最后使用一个<code>return true</code>。这样，缺了else分支的if语句，控制流自动“掉下去”，到达最后的<code>return true</code>。他们的代码看起来像这个样子：</p>

<pre><code>if (...) {
  if (...) {
    ...
    return false;
  } 
} else if (...) {
  ...
  return false;
} 
return true;
</code></pre>

<p>这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的if语句省略了一些else，依靠语句的“控制流”来处理else的情况，是很难正确的分析和推理的。如果你的if条件里使用了<code>&amp;&amp;</code>和<code>||</code>之类的逻辑运算，就更难看出是否涵盖了所有的情况。</p>

<p>由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。</p>

<p>另外一种省略else分支的情况是这样：</p>

<pre><code>String s = "";
if (x &lt; 5) {
  s = "ok";
}
</code></pre>

<p>写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。<code>s</code>缺省为null，如果x&lt;5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当<code>x&lt;5</code>不成立的时候，你需要往上面看，才能知道s的值是什么。这还是你运气好的时候，因为s就在上面不远。很多人写这种代码的时候，s的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。</p>

<p>现在比较一下我的写法：</p>

<pre><code>String s;
if (x &lt; 5) {
  s = "ok";
} else {
  s = "";
}
</code></pre>

<p>这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了<code>x&lt;5</code>不成立的时候，s的值是什么。它就摆在那里，它是<code>“”</code>（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s的值。s一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。</p>

<p>如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。</p>

<p>当然，由于这个情况比较简单，你还可以把它写成这样：</p>

<pre><code>String s = x &lt; 5 ? "ok" : "";
</code></pre>

<p>对于更加复杂的情况，我建议还是写成if语句为好。</p>

<h3 id="正确处理错误">正确处理错误</h3><p>使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。</p>

<p>程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。</p>

<p>错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix的系统API手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux的<a href="http://man7.org/linux/man-pages/man2/read.2.html" target="_blank" rel="external">read</a>系统调用手册里面有如下内容：</p>

<pre>RETURN VALUE&nbsp;
On success, the number of bytes read is returned... 

On error, -1 is returned, and errno is set appropriately.
<p>
ERRORS

EAGAIN, EBADF, EFAULT, EINTR, EINVAL, ...
</p></pre>


<p>很多初学者，都会忘记检查<code>read</code>的返回值是否为-1，觉得每次调用<code>read</code>都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。</p>

<p>对于Java来说，这相对方便一些。Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。比如：</p>

<pre><code>String foo() throws MyException {
  ...
}
</code></pre>

<p>这里MyException是一个错误返回。你可以认为这个函数返回一个union类型：<code>{String, MyException}</code>。任何调用<code>foo</code>的代码，必须对MyException作出合理的处理，才有可能确保程序的正确运行。Union类型是一种相当先进的类型，目前只有极少数语言（比如Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个union类型系统，这样使用普通的语言也能写出可靠的代码。</p>

<p>由于Java的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些Java程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有catch这个foo函数可能出现的异常”时，有些人想都不想，直接把代码改成这样：</p>

<pre><code>try {
  foo();
} catch (Exception e) {}
</code></pre>

<p>或者最多在里面放个log，或者干脆把自己的函数类型上加上<code>throws Exception</code>，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。</p>

<p>如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。</p>

<p>catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。这种bug，有时候甚至使用debugger都难以发现。</p>

<p>如果你在自己函数的类型加上<code>throws Exception</code>，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着<code>throws Exception</code>，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。</p>

<p>另外，try { … } catch里面，应该包含尽量少的代码。比如，如果<code>foo</code>和<code>bar</code>都可能产生异常A，你的代码应该尽可能写成：</p>

<pre><code>try {
  foo();
} catch (A e) {...}

try {
  bar();
} catch (A e) {...}
</code></pre>

<p>而不是</p>

<pre><code>try {
  foo();
  bar();
} catch (A e) {...}
</code></pre>

<p>第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的catch代码里面包含log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。</p>

<h3 id="正确处理null指针">正确处理null指针</h3><p>穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理null指针。</p>

<p>首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于null的处理，其实是完全错误的。这个错误源自于<a href="https://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="external">Tony Hoare</a>最早的设计，Hoare把这个错误称为自己的“<a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="external">billion dollar mistake</a>”，因为由于它所产生的财产和人力损失，远远超过十亿美元。</p>

<p>这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则：</p>

<ul><br><li><p>尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。虽然写法上有点别扭，然而Java的异常，和函数的返回值合并在一起，基本上可以当成union类型来用。比如，如果你有一个函数find，可以帮你找到一个String，也有可能什么也找不到，你可以这样写：</p><br><br><pre><code>public String find() throws NotFoundException {<br>  if (…) {<br>    return …;<br>  } else {<br>    throw new NotFoundException();<br>  }<br>}<br></code></pre><br><br><p>Java的类型系统会强制你catch这个NotFoundException，所以你不可能像漏掉检查null一样，漏掉这种情况。Java的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。</p><br><br><p>Java的try…catch语法相当的繁琐和蹩脚，所以如果你足够小心的话，像<code>find</code>这类函数，也可以返回null来表示“没找到”。这样稍微好看一些，因为你调用的时候不必用try…catch。很多人写的函数，返回null来表示“出错了”，这其实是对null的误用。“出错了”和“没有”，其实完全是两码事。“没有”是一种很常见，正常的情况，比如查哈希表没找到，很正常。“出错了”则表示罕见的情况，本来正常情况下都应该存在有意义的值，偶然出了问题。如果你的函数要表示“出错了”，应该使用异常，而不是null。</p></li><br><li><p>不要把null放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。</p><br><br><p>解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。</p><br><br><p>需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。比如：</p><br><br><pre><code>class A {<br>  String name = null;<br>  …<br>}<br></code></pre><br><br><p>之所以可以这样，是因为null只可能在A对象的name成员里出现，你不用怀疑其它的成员因此成为null。所以你每次访问name成员时，检查它是否是null就可以了，不需要对其他成员也做同样的检查。</p></li><br><li><p>函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”。有时候它表示“出错了”，“失败了”。有时候它甚至可以表示“成功了”，…… 这其中有很多误用之处，不过无论如何，你必须理解每一个null的意义，不能给混淆起来。</p><br><br><p>如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。比如，上述的函数<code>find</code>，返回null表示“没找到”，那么调用<code>find</code>的代码就应该在它返回的第一时间，检查返回值是否是null，并且对“没找到”这种情况，作出有意义的处理。</p><br><br><p>“有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法：</p><br><br><pre><code>public String foo() {<br>  String found = find();<br>  if (found == null) {<br>    return null;<br>  }<br>}<br></code></pre><br><br><p>当看到find()返回了null，foo自己也返回null。这样null就从一个地方，游走到了另一个地方，而且它表示另外一个意思。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现null。到后来为了保护自己，你的每个函数都会写成这样：</p><br><br><pre><code>public void foo(A a, B b, C c) {<br>  if (a == null) { … }<br>  if (b == null) { … }<br>  if (c == null) { … }<br>  …<br>}<br></code></pre></li><br><li><p>函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。如果调用者使用了null作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。</p><br><br><p>上面的例子之所以成为问题，就在于人们对于null的“容忍态度”。这种“保护式”的写法，试图“容错”，试图“优雅的处理null”，其结果是让调用者更加肆无忌惮的传递null给你的函数。到后来，你的代码里出现一堆堆nonsense的情况，null可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了null是什么意思，该做什么，所有人都把null踢给其他人。最后这null像瘟疫一样蔓延开来，到处都是，成为一场噩梦。</p><br><br><p>正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责。至于调用者代码里有null怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。</p><br><br><p>采用强硬态度一个很简单的做法是使用<code>Objects.requireNonNull()</code>。它的定义很简单：</p><br><br><pre><code>public static &lt;T&gt; T requireNonNull(T obj) {<br>  if (obj == null) {<br>    throw new NullPointerException();<br>  } else {<br>    return obj;<br>  }<br>}<br></code></pre><br><br><p>你可以用这个函数来检查不想接受null的每一个参数，只要传进来的参数是null，就会立即触发<code>NullPointerException</code>崩溃掉，这样你就可以有效地防止null指针不知不觉传递到其它地方去。</p></li><br><li><p>使用@NotNull和@Nullable标记。IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较简洁可靠地防止null指针的出现。IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现<code>NullPointerException</code>的地方。在运行时，会在null指针不该出现的地方产生<code>IllegalArgumentException</code>，即使那个null指针你从来没有deference。这样你可以在尽量早期发现并且防止null指针的出现。</p></li><br><li><p>使用Optional类型。Java 8和Swift之类的语言，提供了一种叫Optional的类型。正确的使用这种类型，可以在很大程度上避免null的问题。null指针的问题之所以存在，是因为你可以在没有“检查”null的情况下，“访问”对象的成员。</p><br><br><p>Optional类型的设计原理，就是把“检查”和“访问”这两个操作合二为一，成为一个“原子操作”。这样你没法只访问，而不进行检查。这种做法其实是ML，Haskell等语言里的模式匹配（pattern matching）的一个特例。模式匹配使得类型判断和访问成员这两种操作合二为一，所以你没法犯错。</p><br><br><p>比如，在Swift里面，你可以这样写：</p><br><br><pre><code>let found = find()<br>if let content = found {<br>  print(“found: “ + content)<br>}<br></code></pre><br><br><p>你从<code>find()</code>函数得到一个Optional类型的值<code>found</code>。假设它的类型是<code>String?</code>，那个问号表示它可能包含一个String，也可能是nil。然后你就可以用一种特殊的if语句，同时进行null检查和访问其中的内容。这个if语句跟普通的if语句不一样，它的条件不是一个Bool，而是一个变量绑定<code>let content = found</code>。</p><br><br><p>我不是很喜欢这语法，不过这整个语句的含义是：如果found是nil，那么整个if语句被略过。如果它不是nil，那么变量content被绑定到found里面的值（unwrap操作），然后执行<code>print(“found: “ + content)</code>。由于这种写法把检查和访问合并在了一起，你没法只进行访问而不检查。</p><br><br><p>Java 8的做法比较蹩脚一些。如果你得到一个Optional<string>类型的值found，你必须使用“函数式编程”的方式，来写这之后的代码：</string></p><br><br><pre><code>Optional&lt;String&gt; found = find();<br>found.ifPresent(content -&gt; System.out.println(“found: “ + content));<br></code></pre><br><br><p>这段Java代码跟上面的Swift代码等价，它包含一个“判断”和一个“取值”操作。ifPresent先判断found是否有值（相当于判断是不是null）。如果有，那么将其内容“绑定”到lambda表达式的content参数（unwrap操作），然后执行lambda里面的内容，否则如果found没有内容，那么ifPresent里面的lambda不执行。</p><br><br><p>Java的这种设计有个问题。判断null之后分支里的内容，全都得写在lambda里面。在函数式编程里，这个lambda叫做“<a href="https://en.wikipedia.org/wiki/Continuation" target="_blank" rel="external">continuation</a>”，Java把它叫做<br>“<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html" target="_blank" rel="external">Consumer</a>”，它表示“如果found不是null，拿到它的值，然后应该做什么”。由于lambda是个函数，你不能在里面写<code>return</code>语句返回出外层的函数。比如，如果你要改写下面这个函数（含有null）：</p><br><br><pre><code>public static String foo() {<br>  String found = find();<br>  if (found != null) {<br>    return found;<br>  } else {<br>    return “”;<br>  }<br>}<br></code></pre><br><br><p>就会比较麻烦。因为如果你写成这样：</p><br><br><pre><code>public static String foo() {<br>  Optional&lt;String&gt; found = find();<br>  found.ifPresent(content -&gt; {<br>    return content;    // can’t return from foo here<br>  });<br>  return “”;<br>}<br></code></pre><br><br><p>里面的<code>return a</code>，并不能从函数<code>foo</code>返回出去。它只会从lambda返回，而且由于那个lambda（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/Consumer.html#accept-T-" target="_blank" rel="external">Consumer.accept</a>）的返回类型必须是<code>void</code>，编译器会报错，说你返回了String。由于Java里closure的自由变量是只读的，你没法对lambda外面的变量进行赋值，所以你也不能采用这种写法：</p><br><br><pre><code>public static String foo() {<br>  Optional&lt;String&gt; found = find();<br>  String result = “”;<br>  found.ifPresent(content -&gt; {<br>    result = content;    // can’t assign to result<br>  });<br>  return result;<br>}<br></code></pre><br><br><p>所以，虽然你在lambda里面得到了found的内容，如何使用这个值，如何返回一个值，却让人摸不着头脑。你平时的那些Java编程手法，在这里几乎完全废掉了。实际上，判断null之后，你必须使用Java 8提供的一系列古怪的<a href="http://www.oracle.com/technetwork/articles/java/java8-optional-2175753.html" target="_blank" rel="external">函数式编程操作</a>：<code>map</code>, <code>flatMap</code>, <code>orElse</code>之类，想法把它们组合起来，才能表达出原来代码的意思。比如之前的代码，只能改写成这样：</p><br><br><pre><code>public static String foo() {<br>  Optional&lt;String&gt; found = find();<br>  return found.orElse(“”);<br>}<br></code></pre><br><br><p>这简单的情况还好。复杂一点的代码，我还真不知道怎么表达，我怀疑Java 8的Optional类型的方法，到底有没有提供足够的表达力。那里面少数几个东西表达能力不咋的，论工作原理，却可以扯到functor，continuation，甚至monad等高深的理论…… 仿佛用了Optional之后，这语言就不再是Java了一样。</p><br><br><p>所以Java虽然提供了Optional，但我觉得可用性其实比较低，难以被人接受。相比之下，Swift的设计更加简单直观，接近普通的过程式编程。你只需要记住一个特殊的语法<code>if let content = found {…}</code>，里面的代码写法，跟普通的过程式语言没有任何差别。</p><br><br><p>总之你只要记住，使用Optional类型，要点在于“原子操作”，使得null检查与取值合二为一。这要求你必须使用我刚才介绍的特殊写法。如果你违反了这一原则，把检查和取值分成两步做，还是有可能犯错误。比如在Java 8里面，你可以使用<code>found.get()</code>这样的方式直接访问found里面的内容。在Swift里你也可以使用<code>found!</code>来直接访问而不进行检查。</p><br><br><p>你可以写这样的Java代码来使用Optional类型：</p><br><br><pre><code>Option&lt;String&gt; found = find();<br>if (found.isPresent()) {<br>  System.out.println(“found: “ + found.get());<br>}<br></code></pre><br><br><p>如果你使用这种方式，把检查和取值分成两步做，就可能会出现运行时错误。<code>if (found.isPresent())</code>本质上跟普通的null检查，其实没什么两样。如果你忘记判断<code>found.isPresent()</code>，直接进行<code>found.get()</code>，就会出现<code>NoSuchElementException</code>。这跟<code>NullPointerException</code>本质上是一回事。所以这种写法，比起普通的null的用法，其实换汤不换药。如果你要用Optional类型而得到它的益处，请务必遵循我之前介绍的“原子操作”写法。</p></li><br></ul>


<h3 id="防止过度工程">防止过度工程</h3><p>人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。</p>

<p>过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……</p>

<p>这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。</p>

<p>另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。</p>

<p>过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多bug。</p>

<p>世界上有两种“没有bug”的代码。一种是“没有明显的bug的代码”，另一种是“明显没有bug的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有bug。你喜欢哪一种“没有bug”的代码呢？</p>

<p>根据这些，我总结出来的防止过度工程的原则如下：</p>

<ol><br><li>先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。</li><br><li>先写出可用的代码，反复推敲，再考虑是否需要重用的问题。</li><br><li>先写出可用，简单，明显没有bug的代码，再考虑测试的问题。</li><br></ol>



<p>本文转自：<a href="http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy/" target="_blank" rel="external">编程的智慧</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/10/%E8%BD%AC-%E5%85%B3%E4%BA%8EANT%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]关于ANT的一些总结]]></title>
                <content><![CDATA[<p>使用ant好久了，但是说实话基本对ANT立面的属性什么的都很不熟悉，其实就是个用，其余的啥也不知道。</p>
<p>project、target、task等等的很多的属性其实都不知道是干什么用的，最近闲下来了需要好好研究研究这玩意也算是个技术储备。</p>
<a id="more"></a>
<p>ant 是apache 工程的一个子工程，是一个基于java的build工具。ant类似于make工具，但没有传统的make工具的缺点。</p>
<p>传统的make往往只能限制在某一平台上使用，ant本身用java类实现，要构建的工程的配置文件用<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=xml%E6%A0%BC%E5%BC%8F" target="_blank" rel="external">xml格式</a>描述，可以很方便实现多平台编译,非常适合build大型工程。</p>
<p>首先我们知道ant构建的形式是<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=xml" target="_blank" rel="external">xml</a>文件格式，一般的文件名称都是build.xml，</p>
<h3 id="1-&lt;project&gt;标签">1.&lt;project&gt;标签</h3><p> peoject ：是构建文件的跟标签，</p>
<p>&lt;project default=”main” basedir=”.” name=”ruyicai_android” &gt;—&gt;这个是我自己项目的project</p>
<p>就如代码中所示，其各个属性的含义分别如下。&nbsp;<br>(1) default表示默认的运行目标，这个属性是必须的。&nbsp;<br>(2) basedir表示项目的基准目录。就是表示工程基路径，如果设置成”.”则表示build.xml文件的所在路径。<br>(3) name表示项目名。&nbsp;<br>(4)&nbsp;<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=description" target="_blank" rel="external">description</a>表示项目的描述。&nbsp;<br>每个构建文件都对应于一个项目，但是大型项目经常包含大量的子项目，每一个子项目都可以有&nbsp;<br>自己的构建文件。</p>
<h3 id="2-&lt;target&gt;标签">2.&lt;target&gt;标签</h3><p>&lt;target name=”init”&gt;—&gt;这个是我自己项目的target</p>
<p>一个项目标签下可以有一个或多个target标签。一个target标签可以依赖其他的target标签。例&nbsp;<br>如，有一个target用于<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">编译程序</a>，另一个target用于声称可执行文件。在生成可执行文件之前必&nbsp;<br>须先编译该文件，因策可执行文件的target依赖于编译程序的target。Target的所有属性如下。&nbsp;<br>(1).name表示标明，这个属性是必须的。&nbsp;<br>(2).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=depends" target="_blank" rel="external">depends</a>表示依赖的目标。&nbsp;<br>(3)if表示仅当属性设置时才执行。&nbsp;<br>(4)unless表示当属性没有设置时才执行。&nbsp;<br>(5)description表示项目的描述。&nbsp;<br>Ant的depends属性指定了target的执行顺序。Ant会依照depends属性中target出现顺序依次执行&nbsp;<br>每个target。在执行之前，首先需要执行它所依赖的target。</p>
<p>Z.B：</p>
<p>&lt;target name=”run” depends=”complie”&gt;</p>
<p>&lt;target name=”complie” depends=”prepare”&gt;</p>
<p>&lt;target name=”prepare”&gt;</p>
<p>程序中的名为run的target的&nbsp;<br>depends属性compile，而名为compile的target的depends属性是prepare，所以这几个target执&nbsp;<br>行的顺序是prepare-&gt;compile-&gt;run。&nbsp;<br>一个target只能被执行一次，即使有多个target依赖于它。如果没有if或unless属性，target总&nbsp;<br>会被执行。</p>
<h3 id="3-&lt;mkdir&gt;标签">3.&lt;mkdir&gt;标签</h3><p>该标签用于创建一个目录，它有一个属性dir用来指定所创建的目录名，其代码如下：&nbsp;<br>&lt;mkdir dir=”out”/&gt;&nbsp;<br>通过以上代码就创建了一个目录，这个目录已经被前面的property标签所指定。</p>
<h3 id="4&lt;jar&gt;标签">4&lt;jar&gt;标签</h3><p>该标签用来生成一个<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=JAR" target="_blank" rel="external">JAR</a>文件，其属性如下。&nbsp;<br>(1) destfile表示JAR文件名。&nbsp;<br>(2) basedir表示被归档的文件名。&nbsp;<br>(3)&nbsp;<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=include" target="_blank" rel="external">include</a>s表示别归档的<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E6%96%87%E4%BB%B6%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">文件模式</a>。&nbsp;<br>(4) exchudes表示被排除的文件模式。</p>
<h3 id="5．&lt;javac标签&gt;">5．&lt;javac标签&gt;</h3><p>该标签用于编译一个或一组java文件，其属性如下。&nbsp;<br>(1).srcdir表示<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E6%BA%90%E7%A8%8B%E5%BA%8F" target="_blank" rel="external">源程序</a>的目录。&nbsp;<br>(2).destdir表示<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=class%E6%96%87%E4%BB%B6" target="_blank" rel="external">class文件</a>的输出目录。&nbsp;<br>(3).include表示被编译的文件的模式。&nbsp;<br>(4).excludes表示被排除的文件的模式。&nbsp;<br>(5).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=classpath" target="_blank" rel="external">classpath</a>表示所使用的类路径。&nbsp;<br>(6).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=debug" target="_blank" rel="external">debug</a>表示包含的调试信息。&nbsp;<br>(7).optimize表示是否使用优化。&nbsp;<br>(8).verbose 表示提供详细的输出信息。&nbsp;<br>(9).fileonerror表示当碰到错误就自动停止。</p>
<h3 id="6．&lt;java&gt;标签">6．&lt;java&gt;标签</h3><p>该标签用来执行编译生成的.class文件，其属性如下。&nbsp;<br>(1).classname 表示将执行的类名。&nbsp;<br>(2).jar表示包含该类的JAR文件名。&nbsp;<br>(3).classpath所表示用到的类路径。&nbsp;<br>(4).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=fork" target="_blank" rel="external">fork</a>表示在一个新的<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="external">虚拟机</a>中运行该类。&nbsp;<br>(5).failonerror表示当出现错误时自动停止。&nbsp;<br>(6).output 表示输出文件。&nbsp;<br>(7).<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=append" target="_blank" rel="external">append</a>表示追加或者覆盖默认文件。</p>
<h3 id="7-&lt;delete&gt;标签">7.&lt;delete&gt;标签</h3><p>该标签用于删除一个文件或一组文件，去属性如下。&nbsp;<br>(1)/file表示要删除的文件。&nbsp;<br>(2).dir表示要删除的目录。&nbsp;<br>(3).includeEmptyDirs 表示指定是否要删除空目录，默认值是删除。&nbsp;<br>(4).failonerror 表示指定当碰到错误是否停止，默认值是自动停止。&nbsp;<br>(5).verbose表示指定是否列出所删除的文件，默认值为不列出。</p>
<h3 id="8-&lt;copy&gt;标签">8.&lt;copy&gt;标签</h3><p>该标签用于文件或文件集的拷贝，其属性如下。<br>(1).file 表示源文件。<br>(2).tofile 表示<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6" target="_blank" rel="external">目标文件</a>。<br>(3).todir 表示目标目录。&nbsp;<br>(4).overwrite 表示指定是否覆盖目标文件，默认值是不覆盖。&nbsp;<br>(5).includeEmptyDirs 表示制定是否拷贝空目录，默认值为拷贝。&nbsp;<br>(6).failonerror 表示指定如目标没有发现是否自动停止，默认值是停止。<br>(7).verbose 表示制定是否显示详细信息，默认值不显示。</p>
<h3 id="9-&lt;exec&gt;执行文件：">9<strong>.&lt;exec&gt;执行文件</strong>：</h3><p>&lt;property name=”<a href="http://so.fx114.net/cse/search?s=5712359222851038195&amp;entry=1&amp;q=aapt" target="_blank" rel="external">aapt</a>“ value=”E:\Android TOOL\android-sdk-windows\platform-tools\aapt.exe”/&gt;<font color="#ff0000" style="margin: 0px; padding: 0px;">&nbsp;<br></font>&lt;exec executable=”${aapt}” &gt;</p>
<p>&lt;/exec&gt;</p>
<h3 id="10-&lt;property&gt;标签：">10.&lt;property&gt;标签：</h3><p>property任务用来设置属性，一个工程可以设置很多属性，属性有名字和值，属性设置后可以在后面引用。<br>&lt;property name=”aapt” value=”E:\Android TOOL\android-sdk-windows\platform-tools\aapt.exe”/&gt;<font color="#ff0000" style="margin: 0px; padding: 0px;">&nbsp;<br></font></p>
<p>设置一个名字为aapt，它的值是一个路径用value来设置这里写的是绝对路径（可以写相对路径但是还不会）。</p>
<p>当然也可以使用location这个值来设定路径&nbsp;<br>&lt;property name=”aapt” location=”E:\Android TOOL\android-sdk-windows\platform-tools\aapt.exe”/&gt;</p>
<p>在网上找的结果是value可以设定相对路径，但是在平台间必须转换“\”和”/”。</p>
<p>使用location则不需要，但是必须是绝对路径。</p>
<p>Ant的 location属性专门设计用于以平台无关的方式包含文件系统路径。所以应该用location来代&nbsp;<br>替value,此时用/或是\都会在不同的平台转换为正确的分隔符</p>
<p>用我自己的项目中的代码来说明下：</p>
<p>&lt;property name=”apk-name” value=”ruyicai” /&gt;这里的apk-name是我以后创建的文件夹的名称和生成的apk文件名的一部分，这样写是没有问题的在其他地方引用—&gt;${apk-name}就OK了。</p>
<p>但是如果&lt;property name=”apk-name” location=”ruyicai” /&gt;会报出如下的错误。</p>
<p>[echo] start initing …</p>
<p>BUILD FAILED&nbsp;<br>E:\workspace\ruyicai_android_2.4\build.xml:30: Directory E:\workspace\ruyicai_android_2.4\build\E:\workspace\ruyicai_android_2.4\ruyicai creation was not successful for an unknown reason</p>
<p>Total time: 0 seconds&nbsp;<br>这是我第三十行的&nbsp; &lt;mkdir dir=”build/${apk-name}” /&gt;</p>
<p>明显如果使用location那么就会去寻找当前项目绝对路径下的ruyicai文件夹。</p>
<p>那么就有一个问题这里为什么是这个路径？</p>
<p>E:\workspace\ruyicai_android_2.4\</p>
<p>很明显是根据project中的basedir的属性有关系，上面说过了如果basedir的属性是“.”表示build.xml的路径，而builid.xml的路径正好是E:\workspace\ruyicai_android_2.4\这个路径。</p>
<p>OK先总结这些，总的来说ant没有那么难，但是也绝对不是那么简单需要下一番功夫的</p>
<p>转自： <a href="http://www.fx114.net/qa-186-78040.aspx" target="_blank" rel="external">http://www.fx114.net/qa-186-78040.aspx</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/10/%E8%BD%AC-%E5%85%B3%E4%BA%8EAndroid%E6%89%93%E5%8C%85%E9%82%A3%E4%BA%9B%E4%BA%8B/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]关于Android打包那些事]]></title>
                <content><![CDATA[<p>使用gradle打包apk已经成为当前主流趋势，我也在这个过程中经历了各种需求，并不断结合gradle新的支持，一一改进。在此，把这些相关的东西记录，做一总结。</p>
<a id="more"></a>
<h2 id="1-_替换AndroidManifest中的占位符">1. 替换AndroidManifest中的占位符</h2><p>我想把其中的${app_label}替换为@string/app_name</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    defaultConfig&#123;</span><br><span class="line">        manifestPlaceholders = [app_label:<span class="string">"@string/app_name"</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果只想替换debug版本：</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">	          manifestPlaceholders = [app_label:<span class="string">"@string/app_name_debug"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更多的需求是替换渠道编号：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        // 把dev产品型号的apk的AndroidManifest中的channel替换dev</span><br><span class="line">        <span class="string">"dev"</span>&#123;</span><br><span class="line">            manifestPlaceholders = [channel:<span class="string">"dev"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-_独立配置签名信息">2. 独立配置签名信息</h2><p>对于签名相关的信息,直接写在gradle当然不好,特别是一些开源项目，可以添加到gradle.properties:</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">RELEASE_KEY_PASSWORD=<span class="value">xxxx</span></span></span><br><span class="line"><span class="setting">RELEASE_KEY_ALIAS=<span class="value">xxx</span></span></span><br><span class="line"><span class="setting">RELEASE_STORE_PASSWORD=<span class="value">xxx</span></span></span><br><span class="line"><span class="setting">RELEASE_STORE_FILE=<span class="value">../.keystore/xxx.jks</span></span></span><br></pre></td></tr></table></figure>
<p>然后在build.gradle中引用即可：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">signingConfigs</span> &#123;</span><br><span class="line">        <span class="title">release</span> &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果不想提交到版本库，可以添加到local.properties中，然后在build.gradle中读取。</p>
<h2 id="3-_多渠道打包">3. 多渠道打包</h2><p>多渠道打包的关键之处在于，定义不同的product flavor, 并把AndroiManifest中的channel渠道编号替换为对应的flavor标识：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        dev&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"dev"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        official&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"official"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ... ...</span></span><br><span class="line">        wandoujia&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"wandoujia"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        xiaomi&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"xiaomi"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">"360"</span>&#123;</span><br><span class="line">            manifestPlaceholders = [<span class="string">channel:</span><span class="string">"360"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意一点，这里的flavor名如果是数字开头，必须用引号引起来。<br>构建一下，就能生成一系列的Build Variant了:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">devDebug</span><br><span class="line">devRelease</span><br><span class="line">officialDebug</span><br><span class="line">officialRelease</span><br><span class="line">wandoujiaDebug</span><br><span class="line">wandoujiaRelease</span><br><span class="line">xiaomiDebug</span><br><span class="line">xiaomiRelease</span><br><span class="line"><span class="number">360</span>Debug</span><br><span class="line"><span class="number">360</span>Release</span><br></pre></td></tr></table></figure></p>
<p>其中debug, release是gradle默认自带的两个build type, 下一节还会继续说明。<br>选择一个，就能编译出对应渠道的apk了。</p>
<h2 id="4-_自定义Build_Type">4. 自定义Build Type</h2><p>前面说到默认的build type有两种debug和release，区别如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// release版本生成的BuildConfig特性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"release"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// debug版本生成的BuildConfig特性信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"debug"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在有一种需求，增加一种build type，介于debug和release之间，就是和release版本一样，但是要保留debug状态（如果做过rom开发的话，类似于user debug版本），我们称为preview版本吧。<br>其实很简单：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">    <span class="title">signingConfigs</span> &#123;</span><br><span class="line">        <span class="title">debug</span> &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        preview &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="title">storeFile</span> file(RELEASE_STORE_FILE)</span><br><span class="line">            storePassword RELEASE_STORE_PASSWORD</span><br><span class="line">            keyAlias RELEASE_KEY_ALIAS</span><br><span class="line">            keyPassword RELEASE_KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        <span class="title">debug</span> &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_debug"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        preview&#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_preview"</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，build type还有一个好处，如果想要一次性生成所有的preview版本，执行assemblePreview即可，debug和releae版本同理。</p>
<h2 id="5-_build_type中的定制参数">5. build type中的定制参数</h2><p>上面我们在不同的build type替换${app_label}为不同的字符串，这样安装到手机上就能明显的区分出不同build type的版本。<br>除此之外，可能还可以配置一些参数，我这里列几个我在工作中用到的：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">android</span> &#123;</span><br><span class="line">        <span class="title">debug</span> &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_debug"</span>]</span><br><span class="line">            applicationIdSuffix <span class="string">".debug"</span></span><br><span class="line">            minifyEnabled <span class="built_in">false</span></span><br><span class="line">            signingConfig signingConfigs.<span class="built_in">debug</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name"</span>]</span><br><span class="line">            minifyEnabled <span class="built_in">true</span></span><br><span class="line">            shrinkResources <span class="built_in">true</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">        preview&#123;</span><br><span class="line">            <span class="title">manifestPlaceholders</span> = [app_label:<span class="string">"<span class="variable">@string</span>/app_name_preview"</span>]</span><br><span class="line">            applicationIdSuffix <span class="string">".preview"</span></span><br><span class="line">            debuggable <span class="built_in">true</span> // 保留<span class="built_in">debug</span>信息</span><br><span class="line">            minifyEnabled <span class="built_in">true</span></span><br><span class="line">            shrinkResources <span class="built_in">true</span></span><br><span class="line">            signingConfig signingConfigs.preview</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些都用的太多了，稍微解释一下：<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minifyEnabled 混淆处理</span></span><br><span class="line"><span class="comment">// shrinkResources 去除无用资源</span></span><br><span class="line"><span class="comment">// signingConfig 签名</span></span><br><span class="line"><span class="comment">// proguardFiles 混淆配置</span></span><br><span class="line"><span class="comment">// applicationIdSuffix 增加APP ID的后缀</span></span><br><span class="line"><span class="comment">// debuggable 是否保留调试信息</span></span><br><span class="line"><span class="comment">// ... ...</span></span><br></pre></td></tr></table></figure></p>
<h2 id="6-_多工程全局配置">6. 多工程全局配置</h2><p>随着产品渠道的铺开，往往一套代码需要支持多个产品形态，这就需要抽象出主要代码到一个Library，然后基于Library扩展几个App Module。<br>相信每个module的build.gradle都会有这个代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">22</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.1"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        minSdkVersion <span class="number">10</span></span><br><span class="line">        targetSdkVersion <span class="number">22</span></span><br><span class="line">        versionCode <span class="number">34</span></span><br><span class="line">        versionName <span class="string">"v2.6.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当升级sdk、build tool、target sdk等，几个module都要更改，非常的麻烦。最重要的是，很容易忘记，最终导致app module之间的差异不统一，也不可控。<br>强大的gradle插件在1.1.0支持全局变量设定，一举解决了这个问题。<br>先在project的根目录下的build.gradle定义ext全局变量:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">    compileSdkVersion = <span class="number">22</span></span><br><span class="line">    buildToolsVersion = <span class="string">"23.0.1"</span></span><br><span class="line">    minSdkVersion = <span class="number">10</span></span><br><span class="line">    targetSdkVersion = <span class="number">22</span></span><br><span class="line">    versionCode = <span class="number">34</span></span><br><span class="line">    versionName = <span class="string">"v2.6.1"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在各module的build.gradle中引用如下：<br><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="component">android &#123;</span><br><span class="line">    compileSdkVersion rootProject<span class="string">.ext.compileSdkVersion</span></span><br><span class="line">    buildToolsVersion rootProject<span class="string">.ext.buildToolsVersion</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId "com<span class="string">.xxx.xxx"</span></span><br><span class="line">        minSdkVersion rootProject<span class="string">.ext.minSdkVersion</span></span><br><span class="line">        targetSdkVersion rootProject<span class="string">.ext.targetSdkVersion</span></span><br><span class="line">        versionCode rootProject<span class="string">.ext.versionCode</span></span><br><span class="line">        versionName rootProject<span class="string">.ext.versionName</span></span><br><span class="line">    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后每次修改project级别的build.gradle即可实现全局统一配置。</p>
<h2 id="7-_自定义导出的APK名称">7. 自定义导出的APK名称</h2><p>默认android studio生成的apk名称为app-debug.apk或者app-release.apk，当有多个渠道的时候，需要同时编出50个渠道包的时候，就麻烦了，不知道谁是谁了。<br>这个时候，就需要自定义导出的APK名称了，不同的渠道编出的APK的文件名应该是不一样的。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="comment">// rename the apk with the version name</span></span><br><span class="line">    applicationVariants<span class="built_in">.</span><span class="literal">all</span> &#123; variant <span class="subst">-&gt;</span><br><span class="line">        </span>variant<span class="built_in">.</span>outputs<span class="built_in">.</span>each &#123; output <span class="subst">-&gt;</span><br><span class="line">            </span>output<span class="built_in">.</span>outputFile = <span class="literal">new</span> File(</span><br><span class="line">                    output<span class="built_in">.</span>outputFile<span class="built_in">.</span><span class="keyword">parent</span>,</span><br><span class="line">                    <span class="string">"ganchai-$&#123;variant.buildType.name&#125;-$&#123;variant.versionName&#125;-$&#123;variant.productFlavors[0].name&#125;.apk"</span><span class="built_in">.</span>toLowerCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当apk太多时，如果能把apk按debug，release，preview分一下类就更好了（事实上，对于我这样经常发版的人，一编往往就要编四五十个版本的人，debug和release版本全混在一起没法看，必须分类），简单：<br><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    <span class="regexp">//</span> <span class="keyword">rename</span> the apk with the version name</span><br><span class="line">    // add output file <span class="sub"><span class="keyword">sub</span> folder by build type</span><br><span class="line">    applicationVariants.all &#123;</span> variant -&gt;</span><br><span class="line">        variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">            output.outputFile = new File(</span><br><span class="line">                    output.outputFile.parent + <span class="string">"/<span class="subst">$&#123;variant.buildType.name&#125;</span>"</span>,</span><br><span class="line">                    <span class="string">"ganchai-<span class="subst">$&#123;variant.buildType.name&#125;</span>-<span class="subst">$&#123;variant.versionName&#125;</span>-<span class="subst">$&#123;variant.productFlavors[<span class="number">0</span>].name&#125;</span>.apk"</span>.toLowerCase())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在生成了类似于ganchai-dev-preview-v2.4.0.0.apk这样格式的包了，preview的包自然就放在preview的文件夹下，清晰明了。</p>
<h2 id="8-_混淆技巧">8. 混淆技巧</h2><p>混淆能让反编译的代码可读性变的很差，而且还能显著的减少APK包的大小。</p>
<h3 id="1)-_第一个技巧">1). 第一个技巧</h3><p>相信很多朋友对混淆都觉得麻烦，甚至说，非常乱。因为添加混淆规则需要查询官方说明文档，甚至有的官方文档还没说明。当你引用了太多库后，添加混淆规则将使一场噩梦。<br>这里介绍一个技巧，不用查官方文档，不用逐个库考虑添加规则。<br>首先，除了默认的混淆配置(android-sdk/tools/proguard/proguard-android.txt), 自己的代码肯定是要自己配置的：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 位于module下的proguard-rules.pro</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment">######</span><span class="comment">### 主程序不能混淆的代码 ###</span><span class="comment">######</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">-dontwarn xxx.model.**</span><br><span class="line">-keep <span class="class"><span class="keyword">class</span> <span class="title">xxx</span>.<span class="title">model</span>.** &#123; *; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 等等，自己的代码自己清楚</span></span><br><span class="line"></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment">######</span><span class="comment">##### 不优化泛型和反射 ###</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">######</span><span class="comment">#</span></span><br><span class="line"></span><br><span class="line">-keepattributes Signature</span><br></pre></td></tr></table></figure></p>
<p>接下来是麻烦的第三方库，一般来说，如果是极光推的话，它的包名是cn.jpush, 添加如下代码即可：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-dontwarn cn.jpush.<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line">-keep class cn.jpush.<span class="keyword">*</span><span class="keyword">*</span> &#123; <span class="keyword">*</span>; &#125;</span><br></pre></td></tr></table></figure></p>
<p>其他的第三库也是如此，一个一个添加，太累！其实可以用第三方反编译工具（比如jadx：<a href="https://github.com/skylot/jadx" target="_blank" rel="external">https://github.com/skylot/jadx</a>&nbsp;），打开apk后，一眼就能看到引用的所有第三方库的包名，把所有不想混淆或者不确定能不能混淆的，直接都添加又有何不可：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#####################################</span><br><span class="line">######### 第三方库或者jar包 ###########</span><br><span class="line">#####################################</span><br><span class="line"></span><br><span class="line">-<span class="ruby">dontwarn cn.jpush.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">cn</span>.<span class="title">jpush</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.squareup.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">squareup</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.octo.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">octo</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn de.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">de</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn javax.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">javax</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn org.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">org</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn u.aly.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">u</span>.<span class="title">aly</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn uk.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">uk</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.baidu.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">baidu</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.facebook.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">facebook</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">-<span class="ruby">dontwarn com.google.**</span><br><span class="line"></span>-<span class="ruby">keep <span class="class"><span class="keyword">class</span> <span class="title">com</span>.<span class="title">google</span>.** &#123; *;</span> &#125;</span><br><span class="line"></span></span><br><span class="line">## ... ...</span><br></pre></td></tr></table></figure></p>
<h3 id="2)-_第二个技巧">2). 第二个技巧</h3><p>一般release版本混淆之后，像友盟这样的统计系统如果有崩溃异常，会记录如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java<span class="class">.lang</span><span class="class">.NullPointerException</span>: java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">	at com<span class="class">.xxx</span><span class="class">.TabMessageFragment</span>$<span class="number">7</span>.<span class="function"><span class="title">run</span><span class="params">(Unknown Source)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个Unknown Source是很要命的，排除错误无法定位到具体行了，大大降低调试效率。<br>当然，友盟支持上传Mapping文件，可帮助定位，mapping文件的位置在：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">project &gt; <span class="class"><span class="keyword">module</span></span></span><br><span class="line">        &gt; build &gt; outputs &gt; &#123;flavor name&#125; &gt; &#123;build <span class="keyword">type</span>&#125; &gt; mapping.txt</span><br></pre></td></tr></table></figure></p>
<p>如果版本一多，mapping.txt每次都要重新生成，还要上传，终归还是麻烦。<br>其实，在proguard-rules.pro中添加如下代码即可：<br><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="deletion">-keepattributes SourceFile,LineNumberTable</span></span><br></pre></td></tr></table></figure></p>
<p>当然apk包会大那么一点点（我这里6M的包，大个200k吧），但是再也不用mapping.txt也能定位到行了，为了这种解脱，这个代价我个人觉得是值的，而且超值！</p>
<h2 id="9-_动态设置一些额外信息">9. 动态设置一些额外信息</h2><p>假如想把当前的编译时间、编译的机器、最新的commit版本添加到apk，而这些信息又不好写在代码里，强大的gradle给了我创造可能的自信：<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        resValue <span class="string">"string"</span>, <span class="string">"build_time"</span>, buildTime()</span><br><span class="line">        resValue <span class="string">"string"</span>, <span class="string">"build_host"</span>, hostName()</span><br><span class="line">        resValue <span class="string">"string"</span>, <span class="string">"build_revision"</span>, revision()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">buildTime</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> new <span class="constant">Date</span>().format(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hostName</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="constant">System</span>.getProperty(<span class="string">"user.name"</span>) + <span class="string">"@"</span> + <span class="constant">InetAddress</span>.localHost.hostName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">revision</span><span class="params">()</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">code</span> = <span class="title">new</span> <span class="title">ByteArrayOutputStream</span><span class="params">()</span></span></span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine <span class="string">'git'</span>, <span class="string">'rev-parse'</span>, <span class="string">'--short'</span>, <span class="string">'HEAD'</span></span><br><span class="line">        standardOutput = code</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码实现了动态的添加了3个字符串资源: build_time、build_host、build_revision, 然后在其他地方可像如引用字符串一样使用如下：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在Activity里调用</span></span><br><span class="line"><span class="function"><span class="title">getString</span><span class="params">(R.string.build_time)</span></span>  <span class="comment">// 输出2015-11-07 17:01</span></span><br><span class="line"><span class="function"><span class="title">getString</span><span class="params">(R.string.build_host)</span></span>  <span class="comment">// 输出jay@deepin，这是我的电脑的用户名和PC名</span></span><br><span class="line"><span class="function"><span class="title">getString</span><span class="params">(R.string.build_revision)</span></span> <span class="comment">// 输出3dd5823, 这是最后一次commit的sha值</span></span><br></pre></td></tr></table></figure></p>
<p>这个地方，如何从命令行读取返回结果，很有意思。<br>其实这段代码来自我学习VLC源码时偶然看到，深受启发，不敢独享，特摘抄在此。<br>vlc源码及编译地址：<a href="https://wiki.videolan.org/AndroidCompile%EF%BC%8C" target="_blank" rel="external">https://wiki.videolan.org/AndroidCompile，</a>&nbsp;有兴趣可以过去一观。</p>
<h2 id="10-_给自己留个”后门”:_点七下">10. 给自己留个”后门”: 点七下</h2><p>为了调试方便，我们往往会在debug版本留一个显示我们想看的界面（记得之前微博的一个iOS版本就泄露了一个调试界面），如何进入到一个界面，我们可以仿照android开发者选项的方式，点七下才显示，我们来实现一个：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> clickCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> clickTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">sevenClickView.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clickTime == <span class="number">0</span>) &#123;</span><br><span class="line">            clickTime = System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (System.currentTimeMillis() - clickTime &gt; <span class="number">500</span>) &#123;</span><br><span class="line">            clickCount = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clickCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        clickTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clickCount &gt; <span class="number">6</span>) &#123;</span><br><span class="line">            <span class="comment">// 点七下条件达到，跳到debug界面</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>release版本肯定是不能暴露这个界面的，也不能让人用am在命令行调起，如何防止呢，可以在release版本把这个debug界面的exported设为false。</p>
<h2 id="11-_自动化构建">11. 自动化构建</h2><p>如何使用jenkins打包android和ios，并上传到蒲公英平台，这个可以参考我的另外一篇文章专门介绍:&nbsp;<a href="http://www.jayfeng.com/2015/10/22/%E4%BD%BF%E7%94%A8jenkins%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BAandroid%E5%92%8Cios%E5%BA%94%E7%94%A8/" target="_blank" rel="external">《使用jenkins自动化构建android和ios应用》</a>，不过，这篇文章还没写完，实际上在公司里已经一直在用了，哪天心情好了总会写完的，这里不再赘述。</p>
<h2 id="12-_小结">12. 小结</h2><p>android打包因为groovy语言的强大，变的强大的同时必然也变的复杂，今天把我经历的这些门道拿出来说道一下，做一个小小的总结，后续有更新我还会添加。</p>
<p>转自：<a href="http://www.jayfeng.com/2015/11/07/Android%E6%89%93%E5%8C%85%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/" target="_blank" rel="external">Android打包的那些事</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/10/%E8%BD%AC-%E4%BD%A0%E5%BA%94%E8%AF%A5%E5%85%B3%E6%B3%A8%E7%9A%84-so%E6%96%87%E4%BB%B6/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]你应该关注的.so文件]]></title>
                <content><![CDATA[<p><a href="http://ph0b.com/android-abis-and-so-files/" target="_blank" rel="external"><strong>原文链接</strong></a></p>
<p>早期的Android系统几乎只支持ARMv5的CPU架构，你知道现在它支持多少种吗？7种！</p>
<p>Android系统目前支持以下七种不同的CPU架构：ARMv5，ARMv7 (从2010年起)，x86 (从2011年起)，MIPS (从2012年起)，ARMv8，MIPS64和x86_64 (从2014年起)，每一种都关联着一个相应的ABI。</p>
<a id="more"></a>
<p>应用程序二进制接口（Application Binary Interface）定义了二进制文件（尤其是.so文件）如何运行在相应的系统平台上，从使用的指令集，内存对齐到可用的系统函数库。在Android 系统上，每一个CPU架构对应一个ABI：armeabi，armeabi-v7a，x86，mips，arm64- v8a，mips64，x86_64。</p>
<div style="padding: 0px; margin: 0px; line-height: 25.2000007629395px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; text-align: right; background-color: rgb(250, 250, 250);"><a name="_label0" style="padding: 0px; margin: 0px; color: rgb(34, 116, 155);"></a></div>

<h3 id="为什么你需要重点关注-so文件">为什么你需要重点关注.so文件</h3><p>如果项目中使用到了NDK，它将会生成.so文件，因此显然你已经在关注它了。如果只是使用Java语言进行编码，你可能在想不需要关注.so文 件了吧，因为Java是跨平台的。但事实上，即使你在项目中只是使用Java语言，很多情况下，你可能并没有意识到项目中依赖的函数库或者引擎库里面已经 嵌入了.so文件，并依赖于不同的ABI。</p>
<p>例如，项目中使用RenderScript支持库，OpenCV，Unity，android-gif-drawable，SQLCipher等，你都已经在生成的APK文件中包含.so文件了，而你需要关注.so文件。</p>
<p>Android应用支持的ABI取决于APK中位于lib/ABI目录中的.so文件，其中ABI可能是上面说过的七种ABI中的一种。</p>
<p><img src="http://i.imgur.com/mS2Zzpo.png" alt="关于Android的.so文件你所需要知道的"></p>
<p><a href="https://play.google.com/store/apps/details?id=com.xh.nativelibsmonitor.app" target="_blank" rel="external">Native Libs Monitor</a>&nbsp;这个应用可以帮助我们理解手机上安装的APK用到了哪些.so文件，以及.so文件来源于哪些函数库或者框架。</p>
<div style="padding: 0px; margin: 0px; line-height: 25.2000007629395px; color: rgb(64, 64, 64); font-family: 'Microsoft YaHei', Verdana, sans-serif, SimSun; font-size: 14px; widows: 1; background-color: rgb(250, 250, 250);"><br><br>当然，我们也可以自己对app反编译来获取这些信息，不过相对麻烦一些。<br></div>

<p>很多设备都支持多于一种的ABI。例如ARM64和x86设备也可以同时运行armeabi-v7a和armeabi的二进制包。但最好是针对特 定平台提供相应平台的二进制包，这种情况下运行时就少了一个模拟层（例如x86设备上模拟arm的虚拟层），从而得到更好的性能（归功于最近的架构更新， 例如硬件fpu，更多的寄存器，更好的向量化等）。</p>
<p>我们可以通过Build.SUPPORTED_ABIS得到根据偏好排序的设备支持的ABI列表。但你不应该从你的应用程序中读取它，因为 Android包管理器安装APK时，会自动选择APK包中为对应系统ABI预编译好的.so文件，如果在对应的lib／ABI目录中存在.so文件的 话。</p>
<h3 id="App中可能出错的地方">App中可能出错的地方</h3><p>处理.so文件时有一条简单却并不知名的重要法则。</p>
<p>你应该尽可能的提供专为每个ABI优化过的.so文件，但要么全部支持，要么都不支持：你不应该混合着使用。你应该为每个ABI目录提供对应的.so文件。</p>
<p>当一个应用安装在设备上，只有该设备支持的CPU架构对应的.so文件会被安装。在x86设备上，libs/x86目录中如果存在.so文件的 话，会被安装，如果不存在，则会选择armeabi-v7a中的.so文件，如果也不存在，则选择armeabi目录中的.so文件（因为x86设备也支 持armeabi-v7a和armeabi）。</p>
<h3 id="其他地方也可能出错">其他地方也可能出错</h3><p>当你引入一个.so文件时，不止影响到CPU架构。我从其他开发者那里可以看到一系列常见的错误，其中最多的是”UnsatisfiedLinkError”，”dlopen: failed”以及其他类型的crash或者低下的性能：</p>
<h4 id="使用android-21平台版本编译的-so文件运行在android-15的设备上">使用android-21平台版本编译的.so文件运行在android-15的设备上</h4><p>使用NDK时，你可能会倾向于使用最新的编译平台，但事实上这是错误的，因为NDK平台不是后向兼容的，而是前向兼容的。推荐使用app的minSdkVersion对应的编译平台。</p>
<p>这也意味着当你引入一个预编译好的.so文件时，你需要检查它被编译所用的平台版本。</p>
<h4 id="混合使用不同C++运行时编译的-so文件">混合使用不同C++运行时编译的.so文件</h4><p>.so文件可以依赖于不同的C++运行时，静态编译或者动态加载。混合使用不同版本的C++运行时可能导致很多奇怪的crash，是应该避免的。 作为一个经验法则，当只有一个.so文件时，静态编译C++运行时是没问题的，否则当存在多个.so文件时，应该让所有的.so文件都动态链接相同的 C++运行时。</p>
<p>这意味着当引入一个新的预编译.so文件，而且项目中还存在其他的.so文件时，我们需要首先确认新引入的.so文件使用的C++运行时是否和已经存在的.so文件一致。</p>
<h4 id="没有为每个支持的CPU架构提供对应的-so文件">没有为每个支持的CPU架构提供对应的.so文件</h4><p>这一点在前文已经说到了，但你应该真的特别注意它，因为它可能发生在根本没有意识到的情况下。</p>
<p>例如：你的app支持armeabi-v7a和x86架构，然后使用Android Studio新增了一个函数库依赖，这个函数库包含.so文件并支持更多的CPU架构，例如新增android-gif-drawable函数库：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">compile</span> ‘<span class="tag">pl</span><span class="class">.droidsonroids</span><span class="class">.gif</span><span class="pseudo">:android-gif-drawable</span><span class="pseudo">:1</span><span class="class">.1</span>.+’</span><br></pre></td></tr></table></figure></p>
<p>发布我们的app后，会发现它在某些设备上会发生Crash，例如Galaxy S6，最终可以发现只有64位目录下的.so文件被安装进手机。</p>
<p>解决方案：重新编译我们的.so文件使其支持缺失的ABIs，或者设置<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ndk</span><span class="class">.abiFilters</span></span><br></pre></td></tr></table></figure></p>
<p>显示指定支持的ABIs。</p>
<p>最后一点：&nbsp;如果你是一个SDK提供者，但提供的函数库不支持所有的ABIs，那你将会搞砸你的用户，因为他们能支持的ABIs必将只能少于你提供的。</p>
<h4 id="将-so文件放在错误的地方">将.so文件放在错误的地方</h4><p>我们往往很容易对.so文件应该放在或者生成到哪里感到困惑，下面是一个总结：</p>
<ul>
<li>Android Studio工程放在jniLibs/ABI目录中（当然也可以通过在build.gradle文件中的设置jniLibs.srcDir属性自己指定）</li>
<li>Eclipse工程放在libs/ABI目录中（这也是ndk-build命令默认生成.so文件的目录）</li>
<li>AAR压缩包中位于jni/ABI目录中（.so文件会自动包含到引用AAR压缩包的APK中）</li>
<li>最终APK文件中的lib/ABI目录中</li>
<li>通过PackageManager安装后，在小于Android 5.0的系统中，.so文件位于app的nativeLibraryPath目录中；在大于等于Android 5.0的系统中，.so文件位于app的nativeLibraryRootDir/CPU_ARCH目录中。</li>
</ul>
<h4 id="只提供armeabi架构的-so文件而忽略其他ABIs的">只提供armeabi架构的.so文件而忽略其他ABIs的</h4><p>所有的x86/x86_64/armeabi-v7a/arm64-v8a设备都支持armeabi架构的.so文件，因此似乎移除其他ABIs的.so文件是一个减少APK大小的好技巧。但事实上并不是：这不只影响到函数库的性能和兼容性。</p>
<p>x86设备能够很好的运行ARM类型函数库，但并不保证100%不发生crash，特别是对旧设备。64位设备（arm64-v8a, x86_64, mips64）能够运行32位的函数库，但是以32位模式运行，在64位平台上运行32位版本的ART和Android组件，将丢失专为64位优化过的性 能（ART，webview，media等等）。</p>
<p>以减少APK包大小为由是一个错误的借口，因为你也可以选择在应用市场上传指定ABI版本的APK，生成不同ABI版本的APK可以在build.gradle中如下配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">   ...</span><br><span class="line">   splits &#123;</span><br><span class="line">     abi &#123;</span><br><span class="line">       enable <span class="keyword">true</span></span><br><span class="line">       reset()</span><br><span class="line">       <span class="keyword">include</span> <span class="string">'x86'</span>, <span class="string">'x86_64'</span>, <span class="string">'armeabi-v7a'</span>, <span class="string">'arm64-v8a'</span> <span class="comment">//select ABIs to build APKs for</span></span><br><span class="line">       universalApk <span class="keyword">true</span> <span class="comment">//generate an additional APK that contains all the ABIs</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// map for the version code</span></span><br><span class="line">   <span class="keyword">project</span>.ext.versionCodes = [<span class="string">'armeabi'</span>: <span class="number">1</span>, <span class="string">'armeabi-v7a'</span>: <span class="number">2</span>, <span class="string">'arm64-v8a'</span>: <span class="number">3</span>, <span class="string">'mips'</span>: <span class="number">5</span>, <span class="string">'mips64'</span>: <span class="number">6</span>, <span class="string">'x86'</span>: <span class="number">8</span>, <span class="string">'x86_64'</span>: <span class="number">9</span>]</span><br><span class="line">   android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">     <span class="comment">// assign different version code for each output</span></span><br><span class="line">     variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">       output.versionCodeOverride =</span><br><span class="line">           <span class="keyword">project</span>.ext.versionCodes.get(output.getFilter(com.android.build.OutputFile.ABI), <span class="number">0</span>) * <span class="number">1000000</span> + android.defaultConfig.versionCode</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转自： <a href="http://www.open-open.com/lib/view/open1440421271716.html" target="_blank" rel="external">http://www.open-open.com/lib/view/open1440421271716.html</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/08/hexo-%E8%8F%9C%E9%B9%B0%E6%95%99%E4%BD%A0%E6%80%8E%E4%B9%88%E8%BD%AC%E8%BD%BD%E5%88%AB%E4%BA%BA%E5%8D%9A%E5%AE%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[hexo 菜鹰教你怎么转载别人博客到自己搭建的博客]]></title>
                <content><![CDATA[<p>有时候在网上看到别人的博文写的不错，想要转载到自己博客里。</p>
<p>但是由于我们是自己搭建的博客，发表的文章都是以源码方式编辑的。没有方便的一键转载什么的~~</p>
<p>那在这种时候改怎么办呢~<br><a id="more"></a></p>
<p>下面是一点个人发现的一些小技巧，<br>当然，也许还有其他更方便你的方式我还没有发现，<br>如果有更加方便的方式转载博客的话，期待能在下方回复，</p>
<h3 id="方法1：">方法1：</h3><p>直接将该网页保存成html格式的，然后将不需要的一些广告或者其他的东西去掉，<br>最后保存将该html直接放在_post目录下，记得添加title、date之类的东西</p>
<h3 id="方法2：">方法2：</h3><p>在网上找个在线或者离线html转Markdown格式的。<br>然后将方法1中获取的html文件~~就不继续说了~</p>
<h3 id="方法3：">方法3：</h3><p>需准备材料：<br>     <strong><a href="http://www.wiz.cn/download.html" target="_blank" rel="external">为知笔记</a></strong><br>安装上为知笔记后再安装一个<a href="http://app.wiz.cn/plugin/file/1995" target="_blank" rel="external">Markdown编辑插件</a></p>
<p>下载完毕后<strong>重启</strong>一下，在<strong>未编辑</strong>状态下能看到!<img src="http://i.imgur.com/gP39Peu.png" alt=""><br>Editor.md  Markdown编辑器</p>
<p>，点击就可以在markdown模式下编辑了！</p>
<p>然而，这与转载博客并没有关系。怎么转载呢？还要保持格式。</p>
<p>是不是发现复制想要转载的文章，然后粘贴在Markdown或者Editplus里格式全无啊。<br>在为知笔记里就不会，按照步骤：</p>
<h4 id="转载博客步骤：">转载博客步骤：</h4><h5 id="1，复制要转载的内容">1，复制要转载的内容</h5><h5 id="2，在为知笔记新建一个笔记，然后粘贴在内容框中">2，在为知笔记新建一个笔记，然后粘贴在内容框中</h5><h5 id="3，保存并退出笔记">3，保存并退出笔记</h5><h5 id="4，点击Editor-md编辑在Markdown模式下编辑">4，点击Editor.md编辑在Markdown模式下编辑</h5><p>你会发现他自动帮你转好了，直接复制可用。有可能有少数部分不是很完美，但是稍作休整就好了，记得添加博客的格式头文件(title/date/layout之类的属性)</p>
<p>搞完这些，你的博客发布什么的就不用多说了吧！搞定！有问题可以在下方评论或者直接联系我！</p>
<h3 id="2015-12-13更新方法：">2015-12-13更新方法：</h3><p>发现有些博文转载过来的时候出现code部分和正文部分混淆的问题。<br>现有一种方法可以最大程度的避免出现此类问题：<br>重新更新转载步骤：</p>
<h4 id="转载博客步骤：-1">转载博客步骤：</h4><h5 id="1，复制要转载的内容-1">1，复制要转载的内容</h5><h5 id="2，在为知笔记新建一个笔记，然后粘贴在内容框中-1">2，在为知笔记新建一个笔记，然后粘贴在内容框中</h5><h5 id="3，保存并退出笔记-1">3，保存并退出笔记</h5><h5 id="4，点击编辑">4，点击编辑</h5><h5 id="5，进入编辑模式后点击html(在html格式下编辑)">5，进入编辑模式后点击html(在html格式下编辑)</h5><h5 id="6，ctrl+A全选，ctrl+C复制。">6，ctrl+A全选，ctrl+C复制。</h5><h5 id="7，在Editplus或者其他编辑器中粘贴，进行标签替换">7，在Editplus或者其他编辑器中粘贴，进行标签替换</h5><p>分别将<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;h1&gt;</span> 替换为<span class="comment">#空格 </span></span><br><span class="line"><span class="variable">&lt;/h1&gt;</span>替换为空格<span class="comment">#</span></span><br><span class="line"><span class="variable">&lt;h2&gt;</span> 替换为<span class="comment">##空格</span></span><br><span class="line"><span class="variable">&lt;/h2&gt;</span>替换为空格<span class="comment">##</span></span><br></pre></td></tr></table></figure></p>
<p>按照上面方法依次替换下面的标签：<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;h3&gt;</span><span class="tag">&lt;/h3&gt;</span></span><br><span class="line"><span class="tag">&lt;h4&gt;</span><span class="tag">&lt;/h4&gt;</span></span><br><span class="line"><span class="tag">&lt;h5&gt;</span><span class="tag">&lt;/h5&gt;</span></span><br><span class="line"><span class="tag">&lt;h6&gt;</span><span class="tag">&lt;/h6&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="8，替换完成后全选复制">8，替换完成后全选复制</h5><h5 id="9，将替换完成的内容粘贴在新建的博文后面即可">9，将替换完成的内容粘贴在新建的博文后面即可</h5><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这个方法简单而言：就是将html格式的网页后缀直接变为md，</span><br><span class="line">然后添加title等属性，之后替换<span class="escape">`&lt;</span>h1&gt;<span class="escape">`代</span>表段落的标签即可！</span><br><span class="line">(其实替换标签的这一步只是为了在自动生成的文章目录中</span><br><span class="line">能自动链接到文章中的相应部分，如果没有文章目录，</span><br><span class="line">可忽略此步骤)</span><br></pre></td></tr></table></figure>
<p><strong>当然，最重要最重要的是，记得尊重著作权，在文章最后或者文章某处留下原文链接</strong></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/07/android_marshmallow_change_detail/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[Android6.0 Marshmallow(棉花糖) 对开发者的影响]]></title>
                <content><![CDATA[<p>Android6.0 Marshmallow(棉花糖)<br>官方原文：<a href="https://developer.android.com/intl/zh-cn/about/versions/marshmallow/android-6.0.html" target="_blank" rel="external">https://developer.android.com/intl/zh-cn/about/versions/marshmallow/android-6.0.html</a></p>
<p>6.0新版本包含了许多对系统功能和API的变化，<br> 而我们作为开发者，也要考虑自己的程序需要做哪些兼容性的改变！</p>
<p><a href="http://tech.sina.com.cn/mobile/n/n/2015-09-30/doc-ifxieyms4231929.shtml" target="_blank" rel="external">优化为主提升体验 Android 6.0亮点解析 http://tech.sina.com.cn/mobile/n/n/2015-09-30/doc-ifxieyms4231929.shtml</a><br><a id="more"></a></p>
<h2 id="系统功能改变：">系统功能改变：</h2><h3 id="1，Doze_and_App_Standby：">1，Doze and App Standby：</h3><p> 也就是睡眠和app待机。<br> 从Android6.0开始，Android提供了两种延长电池使用寿命的功能：睡眠和app待机。<br> 当设备没有连接电源，进入Doze模式时，让应用程序处于待机状态以此减少电池的消耗<br> 据说，在nexus5和nexus6上测试，平均续航时间提高了30%。(亲儿子数据，仅供参考)<br> 系统进入睡眠状态后，会隔一段时间处理一下正在挂起任务，随着时间的推移，后面的间隔时间会越来越长，以此减少电量的消耗</p>
<h3 id="2，Runtime_Permissions：">2，Runtime Permissions：</h3><p> 也就是在程序请求要用的权限 的时候，系统会给一个弹框。提示用户，要不要给这个程序的某某权限。在6.0以前的Android系统上，<br> 是在安装之前把所有应用需要的权限全部展示给看，用户决定是否要安装这个App，之后App用权限的时候不会提示用户(有些手机会提示是因为系统定制的或者第三方软件的提示)。<br> 如果一个程序被静默安装了，用户不知道，也没有权限提示。那是非常不安全滴~<br> 那么6.0以后，不止在用户安装的时候会提示用户，程序在运行的时候，请求某种权限之前，系统也会弹出一个对话框，让用户决定是否给XX权限给XX软件。<br> 当然，如果是你不认识的App，请求某些比较隐私的权限。就可以果断卸载了。酱紫，就防止了很多app会泄露隐私了(哎。有些App的一些强盗行为拦都拦不住、不说了~)。</p>
<h3 id="3，Boring_SSL:">3，Boring SSL:</h3><p> Boring SSL 是更安全的SSL协议，在Android6.0以前使用的是open SSL协议。 升级为 Boring SSL（心脏出血漏洞、中间人攻击等漏洞修复）</p>
<h3 id="4，应用数据自动备份功能">4，应用数据自动备份功能</h3><p>（不过，听说是基于 Google 账号的自动备份~）</p>
<h2 id="系统增强">系统增强</h2><h3 id="1，访问硬件标识符">1，访问硬件标识符</h3><h3 id="2，APK内容修改签名认证">2，APK内容修改签名认证</h3><h3 id="3，USB连接">3，USB连接</h3><h3 id="4，App_Links">4，App Links</h3><h2 id="重点：API相关修改：">重点：API相关修改：</h2><h3 id="1，Apache_HTTP_Client去除">1，Apache HTTP Client去除</h3><p> HttpClient在6.0中已经去掉了,用OKhttp替代，如果要继续使用HttpClient。并且还想支持6.0的用户的话，就只能添加HttpClient的支持库了。<br> Eclipse的话在libs中加入<br> org.apache.http.legacy.jar<br> 上面的jar包在：**\android-sdk-windows\platforms\android-23\optional下（需要下载android 6.0的SDK），</p>
<p>AndroidStudio的话就容易多了。在Gradle中添加一句话就解决：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">useLibrary</span> <span class="string">'org.apache.http.legacy'</span></span><br></pre></td></tr></table></figure>
<h3 id="2，Notifycation的变更">2，Notifycation的变更</h3><p> 1，不要打扰模式（新的INTERRUPTION_FILTER_ALARMS过滤级别）<br> 2，添加新的category值CATEGORY REMINDER 用于区分CATEGORY_EVENT和CATEGORY_ALARM<br> 3，新的Icon类，你可以通过setSmallIcon() 和setLargeIcon() 修改Notifacations图标，同样的addAction() 方法现在接收一个Icon对象，不再是一个资源文件了。<br> 4，新的getActiveNotification()方法 允许你查找哪些应用的Notifications还活着</p>
<h3 id="3，删除全局支持书签（Browser_Bookmark_Changes）">3，删除全局支持书签（Browser Bookmark Changes）</h3><p> 读取历史书签和写入历史书签的权限也被去掉 只能内部存储书签<br>android.provider.Browser.getAllBookmarks() 和android.provider.Browser.saveBookmark()方法现在除去。同样，READ_HISTORY_BOOKMARKS和WRITE_HISTORY_BOOKMARKS权限被除去。如果您的应用目标的Android 6.0（API级别23）或更高，没有从全局供应商访问书签或使用书签的权限。相反，您的应用程序应该在内部存储书签数据。</p>
<h3 id="4，Voice_Interactions(语音交互)">4，Voice Interactions(语音交互)</h3><p>在应用中通过Voice Actions构建一个语音<br><a href="https://developer.android.com/intl/zh-cn/reference/android/app/VoiceInteractor.html" target="_blank" rel="external">VoiceInteractor</a></p>
<h3 id="5，Adoptable_Storage_Devices(存储设备)">5，Adoptable Storage Devices(存储设备)</h3><p>可以选择手机内部存储和外部SD卡存储</p>
<h3 id="6，手电筒">6，手电筒</h3><p>api的更新 可以直接使用setTouchMode()方法来开启或者关闭手电筒</p>
<h3 id="7，4K_Display_Mode">7，4K Display Mode</h3><p> 让高配手机得以4K呈现</p>
<h3 id="8，支持指纹认证">8，支持指纹认证</h3><p>提供原生指纹识别API <a href="https://developer.android.com/intl/zh-cn/reference/android/hardware/fingerprint/FingerprintManager.html" target="_blank" rel="external">FingerprintManager</a></p>
<p>当然少不了权限：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission</span><br><span class="line">android:<span class="property">name</span>=<span class="string">"android.permission.USE_FINGERPRINT"</span> /&gt;</span><br></pre></td></tr></table></figure></p>
<p>(还可以用模拟器模拟的哟，官方文档有介绍)</p>
<h2 id="API增强：">API增强：</h2><h3 id="1，蓝牙笔增强">1，蓝牙笔增强</h3><h3 id="2，蓝牙">2，蓝牙</h3><p>扫描  减少蓝牙扫描消耗 提升系统性能</p>
<h3 id="3，热点2-0支持">3，热点2.0支持</h3><p> 提供新的热点API 用于支持热点2.0 </p>
<h3 id="4，签名文件">4，签名文件</h3><p> Android新版本的秘钥库提供程序不再支持DSA</p>
<h3 id="5，相机服务更新">5，相机服务更新</h3><p> 访问共享资源的相机业务 已经从之前的先来先访问的服务方式，变为高优先级进程先访问模式</p>
<h3 id="6，WIFI_网络">6，WIFI 网络</h3><p> 只能修改你自己创建的WifiConfiguration相关状态</p>
<hr>
<pre><code>这里整理了大部分<span class="keyword">Android6.0相关的东西。
</span>我感觉对开发者影响总的来说不是很多，就一个HttpClient的去除可能影响较大，其他的相对较少吧~

原生支持指纹和语音的这个东西，这个感觉好处是有滴，但是有限。

其他的就只能算是优化了
</code></pre>]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/06/hexo-blog-encode-confusion-question/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[hexo博客出现乱码的问题]]></title>
                <content><![CDATA[<p>我blog之前的标题是Eagle，里面没有中文，所以一直没有发现这个问题。</p>
<p>现在修改标题里有中文后就乱码了。<br>在网上了解了下，将该中文所在的文件编码修改为UTF-8就行了。</p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/12/05/launcher-folder-click-close-folder-faild/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[[转]深入理解Android（一）：Gradle详解]]></title>
                <content><![CDATA[<p>编者按：随着移动设备硬件能力的提升，Android系统开放的特质开始显现，各种开发的奇技淫巧、黑科技不断涌现，InfoQ特联合《深入理解Android》系列图书作者邓凡平，开设<a href="http://www.infoq.com/cn/android-in-depth" target="_blank" rel="external">深入理解Android</a>专栏，探索Android从框架到应用开发的奥秘。</p>
<a id="more"></a>
<p>Gradle是当前非常“劲爆”的构建工具。本篇文章就是专为讲解Gradle而来。介绍Gradle之前，先说点题外话。</p>
<h2 id="一、题外话">一、题外话</h2><p>说实话，我在索尼工作的时候，就见过Gradle。但是当时我一直不知道这是什么东西。而且索尼工具组的工程师还将其和Android Studio索尼版一起推送，偶一看就更没兴趣了。为什么那个时候如此不待见Gradle呢？因为我此前一直是做ROM开发。在这个层面上，我们用make，mm或者mmm就可以了。而且，编译耗时对我们来说也不是啥痛点，因为用组内吊炸天的神机服务器完整编译索尼的image也要耗费1个小时左右。所以，那个时侯Gradle完全不是我们的菜。</p>
<p>现在，搞APP开发居多，编译/打包等问题立即就成痛点了。比如：</p>
<ul>
<li>一个APP有多个版本，Release版、Debug版、Test版。甚至针对不同APP Store都有不同的版本。在以前ROM的环境下，虽然可以配置Android.mk，但是需要依赖整个Android源码，而且还不能完全做到满足条件，很多事情需要手动搞。一个app如果涉及到多个开发者，手动操作必然会带来混乱。</li>
<li>library工程我们需要编译成jar包，然后发布给其他开发者使用。以前是用eclipse的export，做一堆选择。要是能自动编译成jar包就爽了。</li>
</ul>
<p>上述问题对绝大部分APP开发者而言都不陌生，而<strong>Gradle</strong>作为一种很方便的的构建工具，可以非常轻松得解决构建过程中的各种问题。</p>
<h2 id="二、闲言构建">二、闲言构建</h2><p>构建，叫build也好，叫make也行。反正就是根据输入信息然后干一堆事情，最后得到几个产出物（Artifact）。</p>
<p>最最简单的构建工具就是make了。make就是根据Makefile文件中写的规则，执行对应的命令，然后得到目标产物。</p>
<p><strong>日常生活中，和构建最类似的一个场景就是做菜。输入各种食材，然后按固定的工序，最后得到一盘菜。当然，做同样一道菜，由于需求不同，做出来的东西也不尽相同。比如，宫保鸡丁这道菜，回民要求不能放大油、口淡的要求少放盐和各种油、辣不怕的男女汉子们可以要求多放辣子….总之，做菜包含固定的工序，但是对于不同条件或需求，需要做不同的处理。</strong></p>
<p>在Gradle爆红之前，常用的构建工具是ANT，然后又进化到Maven。ANT和Maven这两个工具其实也还算方便，现在还有很多地方在使用。但是二者都有一些缺点，所以让更懒得人觉得不是那么方便。比如，Maven编译规则是用XML来编写的。XML虽然通俗易懂，但是很难在xml中描述<strong>if{某条件成立，编译某文件}/else{编译其他文件}</strong>这样有不同条件的任务。</p>
<p>怎么解决？怎么解决好？对程序员而言，自然是编程解决，但是有几个小要求：</p>
<ul>
<li>这种“编程”不要搞得和程序员理解的编程那样复杂。寥寥几笔，轻轻松松把要做的事情描述出来就最好不过。所以，Gradle选择了Groovy。Groovy基于Java并拓展了Java。 Java程序员可以无缝切换到使用Groovy开发程序。<strong>Groovy说白了就是把写Java程序变得像写脚本一样简单。写完就可以执行，Groovy内部会将其编译成Java class然后启动虚拟机来执行。当然，这些底层的渣活不需要你管。</strong></li>
<li>除了可以用很灵活的语言来写构建规则外，Gradle另外一个特点就是它是一种DSL，即<strong>Domain Specific Language</strong>，领域相关语言。什么是DSL，说白了它是某个行业中的行话。还是不明白？徐克导演得《智取威虎山》中就有很典型的DSL使用描述，比如：</li>
</ul>
<blockquote>
<p>土匪：蘑菇，你哪路？什么价？（什么人？到哪里去？）</p>
<p>杨子荣：哈！想啥来啥，想吃奶来了妈妈，想娘家的人，孩子他舅舅来了。（找同行）</p>
<p>杨子荣：拜见三爷！</p>
<p>土匪：天王盖地虎！（你好大的胆！敢来气你的祖宗？）</p>
<p>杨子荣：宝塔镇河妖！（要是那样，叫我从山上摔死，掉河里淹死。）</p>
<p>土匪：野鸡闷头钻，哪能上天王山！（你不是正牌的。）</p>
<p>杨子荣：地上有的是米，喂呀，有根底！（老子是正牌的，老牌的。）</p>
</blockquote>
<p>Gradle中也有类似的行话，比如sourceSets代表源文件的集合等…..<strong>太多了，记不住</strong>。以后我们都会接触到这些行话。那么，对使用者而言，这些行话的好处是什么呢？这就是：</p>
<p><strong>一句行话可以包含很多意思，而且在这个行当里的人一听就懂，不用解释。另外，基于行话，我们甚至可以建立一个模板，使用者只要往这个模板里填必须要填的内容，Gradle就可以非常漂亮得完成工作，得到想要的东西。</strong></p>
<p>这就和现在的智能炒菜机器似的，只要选择菜谱，把食材准备好，剩下的事情就不用你操心了。吃货们对这种做菜方式肯定是以反感为主，太没有特色了。但是程序员对Gradle类似做法却热烈拥抱。</p>
<p>到此，大家应该明白要真正学会Gradle恐怕是离不开下面两个基础知识：</p>
<ul>
<li>Groovy，由于它基于Java，所以我们仅介绍Java之外的东西。了解Groovy语言是掌握Gradle的基础。</li>
<li>Gradle作为一个工具，它的行话和它“为人处事”的原则。</li>
</ul>
<h2 id="三、Groovy介绍">三、Groovy介绍</h2><p>Groovy是一种动态语言。这种语言比较有特点，它和Java一样，也运行于Java虚拟机中。恩？？对头，简单粗暴点儿看，你可以认为Groovy扩展了Java语言。比如，Groovy对自己的定义就是：<strong>Groovy是在 java平台上的、 具有像Python， Ruby 和 Smalltalk 语言特性的灵活动态语言， Groovy保证了这些特性像 Java语法一样被 Java开发者使用。</strong></p>
<p>除了语言和Java相通外，Groovy有时候又像一种脚本语言。前文也提到过，当我执行Groovy脚本时，Groovy会先将其编译成Java类字节码，然后通过Jvm来执行这个Java类。图1展示了Java、Groovy和Jvm之间的关系。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image001.png" alt=""></p>
<p> <strong>实际上，由于Groovy Code在真正执行的时候已经变成了Java字节码，所以JVM根本不知道自己运行的是Groovy代码</strong>。</p>
<p>下面我们将介绍Groovy。由于此文的主要目的是Gradle，所以我们不会过多讨论Groovy中细枝末节的东西，而是把知识点集中在以后和Gradle打交道时一些常用的地方上。</p>
<h3 id="3-1_Groovy开发环境">3.1  Groovy开发环境</h3><p>在学习本节的时候，最好部署一下Groovy开发环境。根据<a href="http://www.groovy-lang.org/download.html#gvm" target="_blank" rel="external">Groovy官网</a>的介绍，部署Groovy开发环境非常简单，在Ubuntu或者cygwin之类的地方：</p>
<ul>
<li>curl -s get.gvmtool.net | bash</li>
<li>source “$HOME/.gvm/bin/gvm-init.sh”</li>
<li>gvm install groovy</li>
<li><p>执行完最后一步，Groovy就下载并安装了。</p>
<p>然后，创建一个test.groovy文件，里边只有一行代码：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span>  <span class="string">"hello groovy"</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行groovy test.groovy，输出结果如图2所示：</li>
</ul>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image003.png" alt=""> </p>
<p>亲们，必须要完成上面的操作啊。做完后，有什么感觉和体会？</p>
<p><strong>最大的感觉可能就是groovy和shell脚本，或者python好类似。</strong></p>
<p>另外，除了可以直接使用JDK之外，Groovy还有一套<a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">GDK</a>。</p>
<p>说实话，看了这么多家API文档，还是Google的Android API文档做得好。其页面中右上角有一个搜索栏，在里边输入一些关键字，瞬间就能列出候选类，相关文档，方便得不得了啊…..</p>
<h3 id="3-2_一些前提知识">3.2  一些前提知识</h3><p>为了后面讲述方面，这里先介绍一些前提知识。初期接触可能有些别扭，看习惯就好了。</p>
<ul>
<li>Groovy注释标记和Java一样，支持<strong>//</strong>或者<strong>/</strong>/**</li>
<li>Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心</li>
<li>Groovy中支持动态类型，即<strong>定义变量的时候可以不指定其类型</strong>。Groovy中，变量定义可以使用关键字def。<strong>注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字</strong></li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">variable1</span> =</span> <span class="number">1</span>   <span class="comment">//可以不使用分号结尾</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">varable2</span> =</span> <span class="string">"I am a person"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span>  <span class="title">int</span> <span class="title">x</span> =</span> <span class="number">1</span>   <span class="comment">//变量定义时，也可以直接指定类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数定义时，参数的类型也可以不指定。比如</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">String</span> <span class="tag">testFunction</span>(arg1,arg2)&#123;<span class="comment">//无需指定参数类型</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。比如：</li>
</ul>
<p>//无类型的函数定义，必须使用def关键字</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def  <span class="title">nonReturnTypeFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">     last_line   <span class="comment">//最后一行代码的执行结果就是本函数的返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果指定了函数返回类型，则可不必加def关键字来定义函数</span></span><br><span class="line"><span class="function">String  <span class="title">getString</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"I am a string"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上</p>
<ul>
<li>函数返回值：Groovy的函数里，可以不使用return xxx来设置xxx为函数返回值。如果不使用return语句的话，则函数里最后一句代码的执行结果被设置成返回值。比如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个函数的返回值是字符串"getSomething return value"</span></span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">getSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="string">"getSomething return value"</span> <span class="comment">//如果这是最后一行代码，则返回类型为String</span></span><br><span class="line"></span><br><span class="line">      <span class="number">1000</span> <span class="comment">//如果这是最后一行代码，则返回类型为Integer</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型，否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。</p>
<ul>
<li>Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点：</li>
</ul>
<p>1  单引号’’中的内容严格对应Java中的String，不对$符号进行转义</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> singleQuote=<span class="string">'I am $ dolloar'</span>  <span class="comment">//输出就是I am $ dolloar</span></span><br></pre></td></tr></table></figure>
<p>2  双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会<strong>$表达式</strong>先求值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleQuoteWithoutDollar</span> =</span> <span class="string">"I am one dollar"</span> <span class="comment">//输出 I am one dollar</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span> =</span> <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doubleQuoteWithDollar</span> =</span> <span class="string">"I am $x dolloar"</span> <span class="comment">//输出I am 1 dolloar</span></span><br></pre></td></tr></table></figure>
<p>3 三个引号’’’xxx’’’中的字符串支持随意换行 比如</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multieLines</span></span> = <span class="string">''</span><span class="string">' begin</span><br><span class="line">  line  1 </span><br><span class="line">  line  2</span><br><span class="line">  end '</span><span class="string">''</span></span><br></pre></td></tr></table></figure>
<ul>
<li>最后，除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">println</span><span class="params">(<span class="string">"test"</span>)</span></span> ---&gt; println <span class="string">"test"</span></span><br></pre></td></tr></table></figure>
<p><strong>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如</strong></p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getSomething</span><span class="params">()</span>&#123;</span></span><br><span class="line">   <span class="string">"hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getSomething()   //如果不加括号的话，Groovy会误认为getSomething是一个变量。</p>
<p>所以，调用函数要不要带括号，我个人意见是如果这个函数是Groovy API或者Gradle API中比较常用的，比如println，就可以不带括号。否则还是带括号。Groovy自己也没有太好的办法解决这个问题，只能<strong>兵来将挡水来土掩</strong>了。</p>
<p>好了，了解上面一些基础知识后，我们再介绍点深入的内容。</p>
<h3 id="3-3_Groovy中的数据类型">3.3  Groovy中的数据类型</h3><p>Groovy中的数据类型我们就介绍两种和Java不太一样的：</p>
<ul>
<li>一个是Java中的基本数据类型。</li>
<li>另外一个是Groovy中的容器类。</li>
<li>最后一个非常重要的是闭包。</li>
</ul>
<p>放心，这里介绍的东西都很简单</p>
<p><strong>3.3.1  基本数据类型</strong></p>
<p>作为动态语言，Groovy世界中的所有事物都是对象。所以，<strong>int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。</strong>比如下图中的代码执行结果：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image005.png" alt=""></p>
<p>图4  int实际上是Integer</p>
<p><strong>3.3.2  容器类</strong></p>
<p>Groovy中的容器类很简单，就三种：</p>
<ul>
<li>List：链表，其底层对应Java中的List接口，一般用ArrayList作为真正的实现类。</li>
<li>Map：键-值表，其底层对应Java中的LinkedHashMap。</li>
<li>Range：范围，它其实是List的一种拓展。</li>
</ul>
<p>对容器而言，我们最重要的是了解它们的用法。下面是一些简单的例子：</p>
<ol>
<li>List类</li>
</ol>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">变量定义：<span class="built_in">List</span>变量由[]定义，比如</span><br><span class="line"></span><br><span class="line">def aList = [<span class="number">5</span>,<span class="string">'string'</span>,<span class="keyword">true</span>] <span class="comment">//List由[]定义，其元素可以是任何对象</span></span><br><span class="line"></span><br><span class="line">变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，<span class="built_in">List</span>会自动</span><br><span class="line">往该索引添加元素</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span> aList[<span class="number">1</span>] == <span class="string">'string'</span></span><br><span class="line"><span class="keyword">assert</span> aList[<span class="number">5</span>] == <span class="keyword">null</span> <span class="comment">//第6个元素为空</span></span><br><span class="line">aList[<span class="number">100</span>] = <span class="number">100</span>  <span class="comment">//设置第101个元素的值为10</span></span><br><span class="line"><span class="keyword">assert</span> aList[<span class="number">100</span>] == <span class="number">100</span></span><br><span class="line"></span><br><span class="line">那么，aList到现在为止有多少个元素呢？</span><br><span class="line"></span><br><span class="line">println aList.size  ===&gt;结果是<span class="number">101</span></span><br></pre></td></tr></table></figure>
<ol>
<li>Map类</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">容器变量定义</span><br><span class="line"></span><br><span class="line">变量定义：Map变量由[:]定义，比如</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> aMap = [<span class="string">'key1'</span>:<span class="string">'value1'</span>,<span class="string">'key2'</span>:<span class="literal">true</span>] </span><br><span class="line"></span><br><span class="line">Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用<span class="string">''</span>或<span class="string">""</span>包起来，也可以不用引号包起来。比如</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> aNewMap = [<span class="string">key1:</span><span class="string">"value"</span>,<span class="string">key2:</span><span class="literal">true</span>] <span class="comment">//其中的key1和key2默认被</span></span><br><span class="line">处理成字符串<span class="string">"key1"</span>和<span class="string">"key2"</span></span><br><span class="line"></span><br><span class="line">不过Key要是不使用引号包起来的话，也会带来一定混淆，比如</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> key1=<span class="string">"wowo"</span></span><br><span class="line"><span class="keyword">def</span> aConfusedMap=[<span class="string">key1:</span><span class="string">"who am i?"</span>]</span><br><span class="line"></span><br><span class="line">aConfuseMap中的key1到底是<span class="string">"key1"</span>还是变量key1的值“wowo”？显然，答案是字符串<span class="string">"key1"</span>。如果要是<span class="string">"wowo"</span>的话，则aConfusedMap的定义必须设置成：</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> aConfusedMap=[(key1):<span class="string">"who am i?"</span>]</span><br><span class="line"></span><br><span class="line">Map中元素的存取更加方便，它支持多种方法：</span><br><span class="line"></span><br><span class="line">println aMap.keyName    &lt;==这种表达方法好像key就是aMap的一个成员变量一样</span><br><span class="line">println aMap[<span class="string">'keyName'</span>] &lt;==这种表达方法更传统一点</span><br><span class="line">aMap.anotherkey = <span class="string">"i am map"</span>  &lt;==为map添加新元素</span><br></pre></td></tr></table></figure>
<ol>
<li>Range类</li>
</ol>
<p>Range是Groovy对List的一种拓展，变量定义和大体的使用方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def aRange = <span class="number">1.</span><span class="number">.5</span>  &lt;==Range类型的变量 由begin值+两个点+end值表示</span><br><span class="line">                      左边这个aRange包含<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>这<span class="number">5</span>个值</span><br><span class="line"></span><br><span class="line">如果不想包含最后一个元素，则</span><br><span class="line"></span><br><span class="line">def aRangeWithoutEnd = <span class="number">1.</span>.&lt;<span class="number">5</span>  &lt;==包含<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>这<span class="number">4</span>个元素</span><br><span class="line">println aRange.from</span><br><span class="line">println aRange.to</span><br></pre></td></tr></table></figure>
<p><strong>3.3.4  Groovy API的一些秘笈</strong></p>
<p>前面讲这些东西，主要是让大家了解Groovy的语法。实际上在coding的时候，是离不开SDK的。由于Groovy是动态语言，所以要使用它的SDK也需要掌握一些小诀窍。</p>
<p>Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></p>
<p>以上文介绍的Range为例，我们该如何更好得使用它呢？</p>
<ul>
<li><p>先定位到Range类。它位于groovy.lang包中：</p>
<p>有了API文档，你就可以放心调用其中的函数了。<strong>不过，不过，不过</strong>：我们刚才代码中用到了Range.from/to属性值，但翻看Range API文档的时候，其实并没有这两个成员变量。图6是Range的方法</p>
</li>
</ul>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image007.png" alt=""></p>
<p> 文档中并没有说明Range有from和to这两个属性，但是却有getFrom和getTo这两个函数。<strong>What happened？</strong>原来：</p>
<p>根据Groovy的原则，如果一个类中有名为xxyyzz这样的属性（其实就是成员变量），Groovy会自动为它添加getXxyyzz和setXxyyzz两个函数，用于获取和设置xxyyzz属性值。</p>
<p>注意，get和set后第一个字母是大写的</p>
<p>所以，当你看到Range中有getFrom和getTo这两个函数时候，就得知道潜规则下，Range有from和to这两个属性。当然，由于它们不可以被外界设置，所以没有公开setFrom和setTo函数。</p>
<h3 id="3-4_闭包">3.4  闭包</h3><p><strong>3.4.1  闭包的样子</strong></p>
<p>闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！</p>
<p>闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> aClosure = &#123;<span class="comment">//闭包是一段代码，所以需要用花括号括起来..  </span></span><br><span class="line">    Stringparam1, <span class="keyword">int</span> param2 -&gt;  <span class="comment">//这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </span></span><br><span class="line">    <span class="keyword">println</span><span class="string">"this is code"</span> <span class="comment">//这是代码，最后一句是返回值，  </span></span><br><span class="line">   <span class="comment">//也可以使用return，和Groovy中普通函数一样  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简而言之，Closure的定义格式是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span> =</span> &#123;paramters -&gt; code&#125;  <span class="comment">//或者  </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">xxx</span> =</span> &#123;无参数，纯code&#125;  这种<span class="keyword">case</span>不需要-&gt;符号</span><br></pre></td></tr></table></figure>
<p><strong>说实话，从C/C++语言的角度看，闭包和函数指针很像</strong>。闭包定义好后，要调用它的方法就是：</p>
<p>闭包对象.call(参数)  或者更像函数指针调用的方法：</p>
<p>闭包对象(参数)  </p>
<p>比如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aClosure.<span class="function"><span class="title">call</span><span class="params">(<span class="string">"this is string"</span>,<span class="number">100</span>)</span></span>  或者  </span><br><span class="line"><span class="function"><span class="title">aClosure</span><span class="params">(<span class="string">"this is string"</span>, <span class="number">100</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>上面就是一个闭包的定义和使用。在闭包中，还需要注意一点：</p>
<p><strong>如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。</strong></p>
<p>比如：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span> = &#123; <span class="string">"Hello, $it!"</span> &#125;</span><br><span class="line">assert greeting(<span class="string">'Patrick'</span>) == <span class="string">'Hello, Patrick!'</span></span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greeting</span></span> = &#123; it -&gt; <span class="string">"Hello, $it!"</span> &#125;</span><br><span class="line">assert greeting(<span class="string">'Patrick'</span>) == <span class="string">'Hello, Patrick!'</span></span><br></pre></td></tr></table></figure>
<p>但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">noParamClosure</span></span> = &#123; -&gt; <span class="keyword">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>这个时候，我们就不能给noParamClosure传参数了！</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">noParamClosure </span>(<span class="string">"test"</span>)  &lt;==报错喔！</span><br></pre></td></tr></table></figure>
<p><strong>3.4.2  Closure使用中的注意点</strong></p>
<ol>
<li>省略圆括号</li>
</ol>
<p>闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; each(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">self</span>, Closure closure)</span><br></pre></td></tr></table></figure>
<p>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是，在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List</span></span><br><span class="line">iamList.each&#123;  <span class="comment">//调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了？</span></span><br><span class="line">      println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有两个知识点：</p>
<ul>
<li><strong>each函数调用的圆括号不见了</strong>！原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def  <span class="title">testClosure</span><span class="params">(<span class="keyword">int</span> a1,String b1, Closure closure)</span></span>&#123;</span><br><span class="line">      <span class="comment">//do something</span></span><br><span class="line">      closure() <span class="comment">//调用闭包</span></span><br><span class="line">&#125;</span><br><span class="line">那么调用的时候，就可以免括号！</span><br><span class="line">testClosure (<span class="number">4</span>, <span class="string">"test"</span>, &#123;</span><br><span class="line">   println <span class="string">"i am in closure"</span></span><br><span class="line">&#125; )  <span class="comment">//红色的括号可以不写..</span></span><br></pre></td></tr></table></figure>
<p>注意，这个特点非常关键，因为以后在Gradle中经常会出现图7这样的代码：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image008.png" alt=""></p>
<p>经常碰见图7这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我confuse（不知道其他人是否有同感），以doLast为例，完整的代码应该按下面这种写法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">doLast</span>(&#123;</span><br><span class="line">   <span class="keyword">println</span> <span class="string">'Hello world!'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>有了圆括号，你会知道 doLast只是把一个Closure对象传了进去。很明显，它不代表这段脚本解析到doLast的时候就会调用println ‘Hello world!’ 。</p>
<p>但是把圆括号去掉后，就感觉好像println ‘Hello world!’立即就会被调用一样！</p>
<ol>
<li>如何确定Closure的参数</li>
</ol>
<p>另外一个比较让人头疼的地方是，Closure的参数该怎么搞？还是刚才的each函数：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">List</span>&lt;T&gt; each(<span class="keyword">List</span>&lt;T&gt; <span class="keyword">self</span>, Closure closure)</span><br></pre></td></tr></table></figure>
<p>如何使用它呢？比如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def iamList = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]  <span class="comment">//定义一个List变量</span></span><br><span class="line">iamList.each&#123;  <span class="comment">//调用它的each函数，只要传入一个Closure就可以了。</span></span><br><span class="line">  println it</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看起来很轻松，其实：</p>
<ul>
<li><strong>对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？</strong></li>
</ul>
<p>我们能写成下面这样吗？</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iamList.each&#123;<span class="built_in">String</span> name,<span class="keyword">int</span> x -&gt;</span><br><span class="line">  <span class="keyword">return</span> x</span><br><span class="line">&#125;  <span class="comment">//运行的时候肯定报错！</span></span><br></pre></td></tr></table></figure>
<p>所以，Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？</p>
<p>此问题如何破解？只能通过查询API文档才能了解上下文语义。比如下图8：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image009.png" alt=""></p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image010.png" alt=""></p>
<p> 图8中：</p>
<ul>
<li>each函数说明中，将给指定的closure传递Set中的每一个item。所以，closure的参数只有一个。</li>
<li>findAll中，<strong>绝对抓瞎</strong>了。一个是没说明往Closure里传什么。另外没说明Closure的返回值是什么…..。</li>
</ul>
<p><strong>对Map的findAll而言，Closure可以有两个参数。findAll会将Key和Value分别传进去。并且，Closure返回true，表示该元素是自己想要的。返回false表示该元素不是自己要找的</strong>。示意代码如图9所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image011.png" alt=""></p>
<p> Closure的使用有点坑，很大程度上依赖于你对API的熟悉程度，所以最初阶段，SDK查询是少不了的。</p>
<h3 id="3-5_脚本类、文件I/O和XML操作">3.5  脚本类、文件I/O和XML操作</h3><p>最后，我们来看一下Groovy中比较高级的用法。</p>
<p><strong>3.5.1  脚本类</strong></p>
<ol>
<li>脚本中import其他类</li>
</ol>
<p>Groovy中可以像Java那样写package，然后写类。比如在文件夹com/cmbc/groovy/目录中放一个文件，叫Test.groovy，如图10所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image012.png" alt=""></p>
<p> 你看，图10中的Test.groovy和Java类就很相似了。当然，如果不声明public/private等访问权限的话，Groovy中类及其变量默认都是public的。</p>
<p>现在，我们在测试的根目录下建立一个test.groovy文件。其代码如下所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image013.png" alt=""></p>
<p> 你看，test.groovy先import了com.cmbc.groovy.Test类，然后创建了一个Test类型的对象，接着调用它的print函数。</p>
<p>这两个groovy文件的目录结构如图12所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image014.png" alt=""></p>
<p> 在groovy中，系统自带会加载当前目录/子目录下的xxx.groovy文件。所以，当执行groovy test.groovy的时候，test.groovy import的Test类能被自动搜索并加载到。</p>
<ol>
<li>脚本到底是什么</li>
</ol>
<p>Java中，我们最熟悉的是类。但是我们在Java的一个源码文件中，不能不写class（interface或者其他….），而Groovy可以像写脚本一样，把要做的事情都写在xxx.groovy中，而且可以通过groovy xxx.groovy直接执行这个脚本。这到底是怎么搞的？</p>
<p>既然是基于Java的，Groovy会先把xxx.groovy中的内容转换成一个Java类。比如：</p>
<p>test.groovy的代码是：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">println</span> <span class="string">'Groovy world!'</span></span><br></pre></td></tr></table></figure>
<p>Groovy把它转换成这样的Java类：</p>
<p>执行<strong> groovyc</strong> -d classes test.groovy</p>
<p><strong>groovyc</strong>是groovy的编译命令，-d classes用于将编译得到的class文件拷贝到classes文件夹下</p>
<p>图13是test.groovy脚本转换得到的java class。用jd-gui反编译它的代码：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image015.png" alt=""></p>
<p> 图13中：</p>
<ul>
<li>test.groovy被转换成了一个test类，它从script派生。</li>
<li>每一个脚本都会生成一个static main函数。这样，当我们groovy test.groovy的时候，其实就是用java去执行这个main函数</li>
<li><strong>脚本中的所有代码都会放到run函数中</strong>。比如，println ‘Groovy world’，这句代码实际上是包含在run函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在test类中。</li>
</ul>
<p><strong>groovyc</strong>是一个比较好的命令，读者要掌握它的用法。然后利用jd-gui来查看对应class的Java源码。</p>
<ol>
<li>脚本中的变量和作用域</li>
</ol>
<p>前面说了，xxx.groovy只要不是和Java那样的class，那么它就是一个脚本。而且脚本的代码其实都会被放到run函数中去执行。那么，在Groovy的脚本中，很重要的一点就是脚本中定义的<strong>变量和它的作用域</strong>。举例：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span></span> = <span class="number">1</span> &lt;==注意，这个x有<span class="function"><span class="keyword">def</span>（或者指明类型，比如 <span class="title">int</span></span> x = <span class="number">1</span>）  </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printx</span></span>()&#123;  </span><br><span class="line">   println x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printx()  &lt;==报错，说x找不到</p>
<p>为什么？继续来看反编译后的class文件。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image016.png" alt=""></p>
<p> 图14中：</p>
<ul>
<li><strong>printx被定义成test类的成员函数</strong></li>
<li><strong>def x = 1</strong>，这句话是在run中创建的。所以，x=1从代码上看好像是在整个脚本中定义的，但实际上printx访问不了它。printx是test成员函数，除非x也被定义成test的成员函数，否则printx不能访问它。</li>
</ul>
<p>那么，如何使得printx能访问x呢？很简单，定义的时候不要加类型和def。即：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>  &lt;==注意，去掉<span class="function"><span class="keyword">def</span>或者类型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printx</span><span class="params">()</span>&#123;</span></span><br><span class="line">   println x</span><br><span class="line">&#125;</span><br><span class="line">printx()  &lt;==<span class="constant">OK</span></span><br></pre></td></tr></table></figure>
<p>这次Java源码又变成什么样了呢？</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image017.png" alt=""></p>
<p> 图15中，x也没有被定义成test的成员函数，而是在run的执行过程中，将x作为一个属性添加到test实例对象中了。然后在printx中，先获取这个属性。</p>
<p>注意，Groovy的文档说 x = 1这种定义将使得x变成test的成员变量，但从反编译情况看，这是不对的…..</p>
<p>虽然printx可以访问x变量了，但是假如有其他脚本却无法访问x变量。因为它不是test的成员变量。</p>
<p>比如，我在测试目录下创建一个新的名为test1.groovy。这个test1将访问test.groovy中定义的printx函数：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image018.png" alt=""></p>
<p> 这种方法使得我们可以将代码分成模块来编写，<strong>比如将公共的功能放到test.groovy中，然后使用公共功能的代码放到test1.groovy中</strong>。</p>
<p>执行groovy test1.groovy，报错。说x找不到。这是因为x是在test的run函数动态加进去的。怎么办？</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor"><span class="keyword">import</span> groovy.transform.Field;   //必须要先<span class="keyword">import</span></span></span><br><span class="line">@<span class="keyword">Field</span> x = <span class="number">1</span>  &lt;==在x前面加上@<span class="keyword">Field</span>标注，这样，x就彻彻底底是test的成员变量了。</span><br></pre></td></tr></table></figure>
<p>查看编译后的test.class文件，得到：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image019.png" alt=""></p>
<p> 这个时候，test.groovy中的x就成了test类的成员函数了。如此，我们可以在script中定义那些需要输出给外部脚本或类使用的变量了！</p>
<p><strong>3.5.2  文件I/O操作</strong></p>
<p>本节介绍下Groovy的文件I/O操作。直接来看例子吧，虽然比Java看起来简单，但要理解起来其实比较难。尤其是当你要自己查SDK并编写代码的时候。</p>
<p>整体说来，Groovy的I/O操作是在原有Java I/O操作上进行了更为简单方便的封装，并且使用Closure来简化代码编写。主要封装了如下一些了类：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image020.png" alt=""></p>
<ol>
<li>读文件</li>
</ol>
<p>Groovy中，文件读操作简单到令人发指：</p>
<p>def targetFile = new File(文件名)  &lt;==File对象还是要创建的。</p>
<p>然后打开<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></p>
<p>看看Groovy定义的API：</p>
<p>1 读该文件中的每一行：eachLine的唯一参数是一个Closure。Closure的参数是文件每一行的内容</p>
<p>   其内部实现肯定是Groovy打开这个文件，然后读取文件的一行，然后调用Closure…</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">targetFile.eachLine</span>&#123;   </span><br><span class="line">  <span class="keyword">StringoneLine </span>-&gt;  </span><br><span class="line">   printlnoneLine      </span><br><span class="line">  &lt;==是不是令人发指？？！</span><br></pre></td></tr></table></figure>
<p>2 直接得到文件内容</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">targetFile.<span class="function"><span class="title">getBytes</span><span class="params">()</span></span>  &lt;==文件内容一次性读出，返回类型为byte[]</span><br></pre></td></tr></table></figure>
<p> 注意前面提到的getter和setter函数，这里可以直接使用targetFile.bytes    //….</p>
<p>3 使用InputStream.InputStream的SDK在 <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def ism =  targetFile.<span class="function"><span class="title">newInputStream</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">//操作ism，最后记得关掉  </span></span><br><span class="line">ism.close</span><br></pre></td></tr></table></figure>
<p>4 使用闭包操作inputStream，以后在Gradle里会常看到这种搞法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> targetFile.withInputStream&#123; ism -&gt;</span><br><span class="line">   操作ism. 不用<span class="built_in">close</span>。Groovy会自动替你<span class="built_in">close</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实够简单，令人发指。我当年死活也没找到withInputStream是个啥意思。所以，请各位开发者牢记Groovy I/O操作相关类的SDK地址：</p>
<ul>
<li>java.io.File: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a></strong></li>
<li>java.io.InputStream: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a>       </strong></li>
<li>java.io.OutputStream: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/OutputStream.html</a></strong></li>
<li>java.io.Reader: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Reader.html</a></strong></li>
<li>java.io.Writer: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/Writer.html</a></strong></li>
<li>java.nio.file.Path: <strong><a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/nio/file/Path.html</a></strong></li>
</ul>
<ol>
<li>写文件</li>
</ol>
<p>和读文件差不多。不再啰嗦。这里给个例子，告诉大家如何copy文件。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> srcFile = <span class="keyword">new</span> <span class="keyword">File</span>(源文件名)  </span><br><span class="line"><span class="keyword">def</span> targetFile = <span class="keyword">new</span> <span class="keyword">File</span>(目标文件名)  </span><br><span class="line">targetFile.withOutputStream&#123; os-&gt;  </span><br><span class="line">  srcFile.withInputStream&#123; ins-&gt;  </span><br><span class="line">      os &lt;&lt; ins   <span class="comment">//利用OutputStream的&lt;&lt;操作符重载，完成从inputstream到OutputStream  </span></span><br><span class="line">       <span class="comment">//的输出  </span></span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于OutputStream的&lt;&lt;操作符重载，查看SDK文档后可知：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image021.png" alt=""></p>
<p> 再一次向极致简单致敬。但是，SDK恐怕是离不开手了…</p>
<p><strong>3.5.3  XML操作</strong></p>
<p>除了I/O异常简单之外，Groovy中的XML操作也极致得很。Groovy中，XML的解析提供了和XPath类似的方法，名为GPath。这是一个类，提供相应API。关于XPath，请看<a href="https://en.wikipedia.org/wiki/XPath" target="_blank" rel="external">Wiki</a>。</p>
<p>GPath功能包括：给个例子好了，来自Groovy官方文档。</p>
<p>test.xml文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">response</span> <span class="attribute">version-api</span>=<span class="value">"2.0"</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="title">value</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="title">books</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"20"</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>  </span><br><span class="line">                   <span class="tag">&lt;<span class="title">title</span>&gt;</span>Don Xijote<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                   <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"1"</span>&gt;</span>Manuel De Cervantes<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">               <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"14"</span> <span class="attribute">id</span>=<span class="value">"2"</span>&gt;</span>  </span><br><span class="line">                   <span class="tag">&lt;<span class="title">title</span>&gt;</span>Catcher in the Rye<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"2"</span>&gt;</span>JD Salinger<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"13"</span> <span class="attribute">id</span>=<span class="value">"3"</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Alice in Wonderland<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"3"</span>&gt;</span>Lewis Carroll<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="title">book</span> <span class="attribute">available</span>=<span class="value">"5"</span> <span class="attribute">id</span>=<span class="value">"4"</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">title</span>&gt;</span>Don Xijote<span class="tag">&lt;/<span class="title">title</span>&gt;</span>  </span><br><span class="line">                  <span class="tag">&lt;<span class="title">author</span> <span class="attribute">id</span>=<span class="value">"4"</span>&gt;</span>Manuel De Cervantes<span class="tag">&lt;/<span class="title">author</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;/<span class="title">book</span>&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;/<span class="title">books</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="title">response</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>现在来看怎么玩转GPath：</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步，创建XmlSlurper类  </span></span><br><span class="line">def xparser = new <span class="function"><span class="title">XmlSlurper</span><span class="params">()</span></span>  </span><br><span class="line">def targetFile = new <span class="function"><span class="title">File</span><span class="params">(<span class="string">"test.xml"</span>)</span></span>  </span><br><span class="line"><span class="comment">//轰轰的GPath出场  </span></span><br><span class="line">GPathResult gpathResult =xparser.<span class="function"><span class="title">parse</span><span class="params">(targetFile)</span></span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">//开始玩test.xml。现在我要访问id=4的book元素。  </span></span><br><span class="line"><span class="comment">//下面这种搞法，gpathResult代表根元素response。通过e1.e2.e3这种  </span></span><br><span class="line"><span class="comment">//格式就能访问到各级子元素....  </span></span><br><span class="line">def book4 = gpathResult<span class="class">.value</span><span class="class">.books</span><span class="class">.book</span>[<span class="number">3</span>]  </span><br><span class="line"><span class="comment">//得到book4的author元素  </span></span><br><span class="line">def author = book4<span class="class">.author</span>  </span><br><span class="line"><span class="comment">//再来获取元素的属性和textvalue  </span></span><br><span class="line">assert author.<span class="function"><span class="title">text</span><span class="params">()</span></span> == <span class="string">' Manuel De Cervantes '</span>  </span><br><span class="line">获取属性更直观  </span><br><span class="line">author.@id == <span class="string">'4'</span> 或者 author[<span class="string">'@id'</span>] == <span class="string">'4'</span>  </span><br><span class="line">属性一般是字符串，可通过toInteger转换成整数  </span><br><span class="line">author.@id.<span class="function"><span class="title">toInteger</span><span class="params">()</span></span> == <span class="number">4</span>  </span><br><span class="line">好了。GPath就说到这。再看个例子。我在使用Gradle的时候有个需求，就是获取AndroidManifest.xml版本号（versionName）。有了GPath，一行代码搞定，请看：  </span><br><span class="line">def androidManifest = <span class="function"><span class="title">newXmlSlurper</span><span class="params">()</span></span>.<span class="function"><span class="title">parse</span><span class="params">(<span class="string">"AndroidManifest.xml"</span>)</span></span>  </span><br><span class="line">println androidManifest[<span class="string">'@android:versionName'</span>]  </span><br><span class="line">或者  </span><br><span class="line">println androidManifest.@<span class="string">'android:versionName'</span></span><br></pre></td></tr></table></figure>
<h3 id="3-6_更多">3.6  更多</h3><p>作为一门语言，Groovy是复杂的，是需要深入学习和钻研的。一本厚书甚至都无法描述Groovy的方方面面。</p>
<p>Anyway，从使用角度看，尤其是又限定在Gradle这个领域内，能用到的都是Groovy中一些简单的知识。</p>
<h2 id="四、Gradle介绍">四、Gradle介绍</h2><p>现在正式进入Gradle。Gradle是一个工具，同时它也是一个编程框架。前面也提到过，使用这个工具可以完成app的编译打包等工作。当然你也可以用它干其他的事情。</p>
<p>Gradle是什么？学习它到什么地步就可以了？</p>
<p>=====&gt;看待问题的时候，所站的角度非常重要。</p>
<p>–&gt;当你把Gradle当工具看的时候，我们只想着如何用好它。会写、写好配置脚本就OK</p>
<p>–&gt;当你把它当做编程框架看的时候，你可能需要学习很多更深入的内容。</p>
<p>另外，今天我们把它当工具看，明天因为需求发生变化，我们可能又得把它当编程框架看。</p>
<h3 id="4-1_Gradle开发环境部署">4.1  Gradle开发环境部署</h3><p>Gradle的官网：<strong><a href="http://gradle.org/" target="_blank" rel="external">http://gradle.org/</a></strong></p>
<p>文档位置：<a href="https://docs.gradle.org/current/release-notes。其中的**_User" target="_blank" rel="external">https://docs.gradle.org/current/release-notes。其中的**_User</a> Guide_<strong>和</strong><em>DSL Reference</em>**很关键。User Guide就是介绍Gradle的一本书，而DSL Reference是Gradle API的说明。</p>
<p>以Ubuntu为例，下载Gradle：<strong><a href="http://gradle.org/gradle-download/" target="_blank" rel="external">http://gradle.org/gradle-download/</a></strong>  选择<strong>Complete distribution</strong>和<strong>Binary only distribution</strong>都行。然后解压到指定目录。</p>
<p>最后，设置~/.bashrc，把Gradle加到PATH里，如图20所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image022.png" alt=""></p>
<p><strong>执行source ~/.bashrc，初始化环境</strong>。</p>
<p><strong>执行gradle –version，如果成功运行就OK了</strong>。</p>
<p>注意，为什么说Gradle是一个编程框架？来看它提供的API文档：</p>
<p><strong><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></strong></p>
<p>原来，我们编写所谓的编译脚本，其实就是玩Gradle的API….所以它从更底层意义上看，是一个编程框架！</p>
<p>既然是编程框架，我在讲解Gradle的时候，尽量会从API的角度来介绍。有些读者肯定会不耐烦，为嘛这么费事？</p>
<p><strong>从我个人的经历来看：因为我从网上学习到的资料来看，几乎全是从脚本的角度来介绍Gradle，结果学习一通下来，只记住参数怎么配置，却不知道它们都是函数调用，都是严格对应相关API的。</strong></p>
<p>而从API角度来看待Gradle的话，有了SDK文档，你就可以编程。编程是靠记住一行行代码来实现的吗？不是，是在你掌握大体流程，然后根据SDK+API来完成的！</p>
<p>其实，Gradle自己的User Guide也明确说了：</p>
<p><strong>Build scripts are code</strong></p>
<h3 id="4-2_基本组件">4.2  基本组件</h3><p>Gradle是一个框架，它定义一套自己的游戏规则。我们要玩转Gradle，必须要遵守它设计的规则。下面我们来讲讲Gradle的基本组件：</p>
<p>Gradle中，每一个待编译的工程都叫一个Project。每一个Project在构建的时候都包含一系列的Task。比如一个Android APK的编译可能包含：<strong>Java源码编译Task、资源编译Task、JNI编译Task、lint检查Task、打包生成APK的Task、签名Task等</strong>。</p>
<p>一个Project到底包含多少个Task，其实是由编译脚本指定的插件决定。插件是什么呢？插件就是用来定义Task，并具体执行这些Task的东西。</p>
<p>刚才说了，Gradle是一个框架，作为框架，它负责定义流程和规则。而具体的编译工作则是通过插件的方式来完成的。比如<strong>编译Java有Java插件，编译Groovy有Groovy插件，编译Android APP有Android APP插件，编译Android Library有Android Library插件</strong></p>
<p>好了。到现在为止，你知道Gradle中每一个待编译的工程都是一个Project，一个具体的编译过程是由一个一个的Task来定义和执行的。</p>
<p><strong>4.2.1  一个重要的例子</strong></p>
<p>下面我们来看一个实际的例子。这个例子非常有代表意义。图22是一个名为posdevice的目录。这个目录里包含3个Android Library工程，2个Android APP工程。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image024.png" alt=""></p>
<p> 在图22的例子中：</p>
<ul>
<li>CPosDeviceSdk、CPosSystemSdk、CPosSystemSdkxxxImpl是Android Library。<strong>其中，CPosSystemSdkxxxImpl依赖CPosSystemSdk</strong></li>
<li>CPosDeviceServerApk和CPosSdkDemo是Android APP。这些App和SDK有依赖关系。CPosDeviceServerApk依赖CPosDeviceSdk，而CPosSdkDemo依赖所有的Sdk Library。</li>
</ul>
<p>请回答问题，在上面这个例子中，有多少个Project？</p>
<p>答案是：每一个Library和每一个App都是单独的Project。根据Gradle的要求，每一个Project在其根目录下都需要有一个build.gradle。build.gradle文件就是该Project的编译脚本，类似于Makefile。</p>
<p>看起来好像很简单，但是请注意：posdevice虽然包含5个独立的Project，但是要独立编译他们的话，得：</p>
<ol>
<li>cd  某个Project的目录。比如 cd CPosDeviceSdk</li>
<li>然后执行 gradle  xxxx（xxx是任务的名字。对Android来说，assemble这个Task会生成最终的产物，所以gradle assemble）</li>
</ol>
<p>这很麻烦啊，有10个独立Project，就得重复执行10次这样的命令。更有甚者，所谓的独立Project其实有依赖关系的。比如我们这个例子。</p>
<p>那么，我想在posdevice目录下，直接执行gradle assemble，是否能把这5个Project的东西都编译出来呢？</p>
<p>答案自然是可以。在Gradle中，这叫<strong>Multi-Projects Build</strong>。把posdevice改造成支持Gradle的Multi-Projects Build很容易，需要：</p>
<ul>
<li>在posdevice下也添加一个build.gradle。这个build.gradle一般干得活是：配置其他子Project的。比如为子Project添加一些属性。这个build.gradle有没有都无所属。</li>
<li>在posdevice下添加一个名为settings.gradle。这个文件很重要，名字必须是settings.gradle。它里边用来告诉Gradle，这个multiprojects包含多少个子Project。</li>
</ul>
<p>来看settings.gradle的内容，最关键的内容就是告诉Gradle这个multiprojects包含哪些子projects:</p>
<p>[settings.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过include函数，将子Project的名字（其文件夹名）包含进来  </span></span><br><span class="line"><span class="keyword">include</span>  <span class="string">'CPosSystemSdk'</span> ,<span class="string">'CPosDeviceSdk'</span> ,  </span><br><span class="line">       <span class="string">'CPosSdkDemo'</span>,<span class="string">'CPosDeviceServerApk'</span>,<span class="string">'CPosSystemSdkWizarPosImpl'</span></span><br></pre></td></tr></table></figure>
<p>强烈建议：</p>
<p>如果你确实只有一个Project需要编译，我也建议你在目录下添加一个settings.gradle。我们团队内部的所有单个Project都已经改成支持Multiple-Project Build了。改得方法就是添加settings.gradle，然后include对应的project名字。</p>
<p>另外，settings.gradle除了可以include外，还可以设置一些函数。这些函数会在gradle构建整个工程任务的时候执行，所以，可以在settings做一些初始化的工作。比如：我的settings.gradle的内容：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为initMinshengGradleEnvironment的函数。该函数内部完成一些初始化操作</span></span><br><span class="line"><span class="comment">//比如创建特定的目录，设置特定的参数等</span></span><br><span class="line"><span class="keyword">def</span> initMinshengGradleEnvironment()&#123;  </span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment ....."</span>  </span><br><span class="line">    ......<span class="comment">//干一些special的私活....  </span></span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment completes..."</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//settings.gradle加载的时候，会执行initMinshengGradleEnvironment  </span></span><br><span class="line">initMinshengGradleEnvironment()  </span><br><span class="line"><span class="comment">//include也是一个函数：  </span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'CPosSystemSdk'</span> , <span class="string">'CPosDeviceSdk'</span> ,  </span><br><span class="line">      <span class="string">'CPosSdkDemo'</span>,<span class="string">'CPosDeviceServerApk'</span>,<span class="string">'CPosSystemSdkWizarPosImpl'</span></span><br></pre></td></tr></table></figure>
<p><strong>4.2.2  gradle命令介绍</strong></p>
<ol>
<li>gradle projects查看工程信息</li>
</ol>
<p>到目前为止，我们了解了Gradle什么呢？</p>
<ul>
<li><strong>每一个Project都必须设置一个build.gradle文件。至于其内容，我们留到后面再说</strong>。</li>
<li><strong>对于multi-projects build，需要在根目录下也放一个build.gradle，和一个settings.gradle</strong>。</li>
<li><strong>一个Project是由若干tasks来组成的，当gradle xxx的时候，实际上是要求gradle执行xxx任务。这个任务就能完成具体的工作</strong>。</li>
<li>当然，具体的工作和不同的插件有关系。编译Java要使用Java插件，编译Android APP需要使用Android APP插件。这些我们都留待后续讨论</li>
</ul>
<p>gradle提供一些方便命令来查看和Project，Task相关的信息。比如在posdevice中，我想看这个multi projects到底包含多少个子Project：</p>
<p>执行 gradle projects，得到图23：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image025.png" alt=""></p>
<p> 你看，multi projects的情况下，posdevice这个目录对应的build.gradle叫Root Project，它包含5个子Project。</p>
<p>如果你修改settings.gradle，使得include只有一个参数，则gradle projects的子project也会变少，比如图24：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image026.png" alt=""></p>
<ol>
<li>gradle tasks查看任务信息</li>
</ol>
<p>查看了Project信息，这个还比较简单，直接看settings.gradle也知道。那么Project包含哪些Task信息，怎么看呢？图23,24中最后的输出也告诉你了，想看某个Project包含哪些Task信息，只要执行：</p>
<p><strong>gradle project-path:tasks</strong>  就行。注意，<strong>project-path</strong>是目录名，后面必须跟冒号。</p>
<p>对于Multi-project，在根目录中，需要指定你想看哪个poject的任务。不过你要是已经cd到某个Project的目录了，则不需指定Project-path。</p>
<p>来看图25：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image027.png" alt=""></p>
<p> 图25是gradle CPosSystemSdk:tasks的结果。</p>
<ul>
<li>cd CPossystemSdk</li>
<li>gradle tasks 得到同样的结果</li>
</ul>
<p>CPosSystemSdk是一个Android Library工程，Android Library对应的插件定义了好多Task。每种插件定义的Task都不尽相同，这就是所谓的Domain Specific，需要我们对相关领域有比较多的了解。</p>
<p>这些都是后话，我们以后会详细介绍。</p>
<ol>
<li>gradle task-name执行任务</li>
</ol>
<p>图25中列出了好多任务，这时候就可以通过 gradle 任务名来执行某个任务。这和make xxx很像。比如：</p>
<ul>
<li>gradle clean是执行清理任务，和make clean类似。</li>
<li>gradle properites用来查看所有属性信息。</li>
</ul>
<p>gradle tasks会列出每个任务的描述，通过描述，我们大概能知道这些任务是干什么的…..。然后gradle task-name执行它就好。</p>
<p>这里要强调一点：Task和Task之间往往是有关系的，<strong>这就是所谓的依赖关系。比如，assemble task就依赖其他task先执行，assemble才能完成最终的输出</strong>。</p>
<p>依赖关系对我们使用gradle有什么意义呢？</p>
<p>如果知道Task之间的依赖关系，那么开发者就可以添加一些定制化的Task。比如我为assemble添加一个SpecialTest任务，并指定assemble依赖于SpecialTest。当assemble执行的时候，就会先处理完它依赖的task。自然，SpecialTest就会得到执行了…</p>
<p>大家先了解这么多，等后面介绍如何写gradle脚本的时候，这就是调用几个函数的事情，Nothing Special!</p>
<h3 id="4-3_Gradle工作流程">4.3  Gradle工作流程</h3><p>Gradle的工作流程其实蛮简单，用一个图26来表达：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image028.png" alt=""></p>
<p> 图26告诉我们，Gradle工作包含三个阶段：</p>
<ul>
<li>首先是初始化阶段。对我们前面的multi-project build而言，就是执行settings.gradle</li>
<li>Initiliazation phase的下一个阶段是Configration阶段。</li>
<li>Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过API来添加的。</li>
<li>Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。恩？前面说过，一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。所以，我们可以添加一个HOOK，即当Task关系图建立好后，执行一些操作。</li>
<li><p>最后一个阶段就是执行任务了。当然，任务执行完后，我们还可以加Hook。</p>
<p>我在：</p>
</li>
<li><p>settings.gradle加了一个输出。</p>
</li>
<li>在posdevice的build.gradle加了图25中的beforeProject函数。</li>
<li>在CPosSystemSdk加了taskGraph whenReady函数和buidFinished函数。</li>
</ul>
<p>好了，Hook的代码怎么写，估计你很好奇，而且肯定会埋汰，怎么就还没告诉我怎么写Gradle。马上了！</p>
<p>最后，关于Gradle的工作流程，你只要记住：</p>
<ul>
<li>Gradle有一个初始化流程，这个时候settings.gradle会执行。</li>
<li>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。</li>
<li>然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！</li>
</ul>
<p><strong>下面来告诉你怎么写代码！</strong></p>
<h3 id="4-4_Gradle编程模型及API实例详解">4.4  Gradle编程模型及API实例详解</h3><p><strong>希望你在进入此节之前，一定花时间把前面内容看一遍！！！</strong></p>
<p><strong><a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a></strong>  &lt;==这个文档很重要</p>
<p>Gradle基于Groovy，Groovy又基于Java。所以，Gradle执行的时候和Groovy一样，会把脚本转换成Java对象。Gradle主要有三种对象，这三种对象和三种不同的脚本文件对应，在gradle执行的时候，会将脚本转换成对应的对端：</p>
<ul>
<li>Gradle对象：当我们执行gradle xxx或者什么的时候，gradle会从默认的配置脚本中构造出一个Gradle对象。在整个执行过程中，只有这么一个对象。Gradle对象的数据类型就是Gradle。我们一般很少去定制这个默认的配置脚本。</li>
<li>Project对象：每一个build.gradle会转换成一个Project对象。</li>
<li>Settings对象：显然，每一个settings.gradle都会转换成一个Settings对象。</li>
</ul>
<p>注意，对于其他gradle文件，除非定义了class，否则会转换成一个实现了Script接口的对象。这一点和3.5节中Groovy的脚本类相似</p>
<p>当我们执行gradle的时候，gradle首先是按顺序解析各个gradle文件。这里边就有所所谓的生命周期的问题，即先解析谁，后解析谁。图27是Gradle文档中对生命周期的介绍：结合上一节的内容，相信大家都能看明白了。<strong>现在只需要看红框里的内容：</strong></p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image030.png" alt=""></p>
<p><strong>4.4.1  Gradle对象</strong></p>
<p>我们先来看Gradle对象，它有哪些属性呢？如图28所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image031.png" alt=""></p>
<p> 我在posdevice build.gradle中和settings.gradle中分别加了如下输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在settings.gradle中，则输出"In settings,gradle id is"  </span></span><br><span class="line">println <span class="string">"In posdevice, gradle id is "</span> +gradle.<span class="function"><span class="title">hashCode</span><span class="params">()</span></span>  </span><br><span class="line">println <span class="string">"Home Dir:"</span> + gradle<span class="class">.gradleHomeDir</span>  </span><br><span class="line">println <span class="string">"User Home Dir:"</span> + gradle<span class="class">.gradleUserHomeDir</span>  </span><br><span class="line">println <span class="string">"Parent: "</span> + gradle.parent</span><br></pre></td></tr></table></figure>
<p>得到结果如图29所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image032.png" alt=""></p>
<ul>
<li>你看，在settings.gradle和posdevice build.gradle中，我们得到的gradle实例对象的hashCode是一样的（都是791279786）。</li>
<li>HomeDir是我在哪个目录存储的gradle可执行程序。</li>
<li>User Home Dir：是gradle自己设置的目录，里边存储了一些配置文件，以及编译过程中的缓存文件，生成的类文件，编译中依赖的插件等等。</li>
</ul>
<p>Gradle的函数接口在文档中也有。</p>
<p><strong>4.4.2  Project对象</strong></p>
<p>每一个build.gradle文件都会转换成一个Project对象。在Gradle术语中，Project对象对应的是<strong>Build Script</strong>。</p>
<p>Project包含若干Tasks。另外，由于Project对应具体的工程，所以需要为Project加载所需要的插件，比如为Java工程加载Java插件。<strong>其实，一个Project包含多少Task往往是插件决定的。</strong></p>
<p>所以，在Project中，我们要：</p>
<ul>
<li>加载插件。</li>
<li>不同插件有不同的行话，即不同的配置。我们要在Project中配置好，这样插件就知道从哪里读取源文件等</li>
<li>设置属性。</li>
</ul>
<ol>
<li>加载插件</li>
</ol>
<p>Project的API位于<strong><a href="https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/org/gradle/api/Project.html</a></strong>。加载插件是调用它的apply函数.apply其实是Project实现的PluginAware接口定义的：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image033.png" alt=""></p>
<p> 来看代码：</p>
<p>[apply函数的用法]</p>
<p>apply是一个函数，此处调用的是图30中最后一个apply函数。注意，Groovy支持函数调用的时候通过  参数名1:参数值2，参数名2：参数值2 的方式来传递参数</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span>    &lt;==如果是编译Library，则加载此插件</span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span>  &lt;==如果是编译Android APP，则加载此插件</span><br></pre></td></tr></table></figure>
<p>除了加载二进制的插件（上面的插件其实都是下载了对应的jar包，这也是通常意义上我们所理解的插件），还可以加载一个gradle文件。为什么要加载gradle文件呢？</p>
<p><strong>其实这和代码的模块划分有关。一般而言，我会把一些通用的函数放到一个名叫utils.gradle文件里。然后在其他工程的build.gradle来加载这个utils.gradle。这样，通过一些处理，我就可以调用utils.gradle中定义的函数了。</strong></p>
<p>加载utils.gradle插件的代码如下：</p>
<p>utils.gradle是我封装的一个gradle脚本，里边定义了一些方便函数，比如读取AndroidManifest.xml中</p>
<p>的versionName，或者是copy jar包/APK包到指定的目录</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apply from: rootProject.<span class="function"><span class="title">getRootDir</span><span class="params">()</span></span>.<span class="function"><span class="title">getAbsolutePath</span><span class="params">()</span></span> + <span class="string">"/utils.gradle"</span></span><br></pre></td></tr></table></figure>
<p>也是使用apply的最后一个函数。那么，apply最后一个函数到底支持哪些参数呢？还是得看图31中的API说明：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image034.png" alt=""></p>
<p> 我这里不遗余力的列出API图片，就是希望大家在写脚本的时候，碰到不会的，一定要去查看API文档！</p>
<ol>
<li>设置属性</li>
</ol>
<p>如果是单个脚本，则不需要考虑属性的跨脚本传播，但是Gradle往往包含不止一个build.gradle文件，比如我设置的utils.gradle，settings.gradle。如何在多个脚本中设置属性呢？</p>
<p>Gradle提供了一种名为<strong>extra property</strong>的方法。<strong>extra property</strong>是额外属性的意思，在第一次定义该属性的时候需要通过ext前缀来标示它是一个额外的属性。定义好之后，后面的存取就不需要ext前缀了。ext属性支持Project和Gradle对象。即Project和Gradle对象都可以设置ext属性</p>
<p>举个例子：</p>
<p>我在settings.gradle中想为Gradle对象设置一些外置属性，所以在initMinshengGradleEnvironment函数中</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> initMinshengGradleEnvironment()&#123;  </span><br><span class="line">    <span class="comment">//属性值从local.properites中读取  </span></span><br><span class="line">    Propertiesproperties = <span class="keyword">new</span> Properties()  </span><br><span class="line">    FilepropertyFile = <span class="keyword">new</span> <span class="keyword">File</span>(rootDir.getAbsolutePath() +<span class="string">"/local.properties"</span>)  </span><br><span class="line">   properties.load(propertyFile.newDataInputStream())  </span><br><span class="line">    <span class="comment">//gradle就是gradle对象。它默认是Settings和Project的成员变量。可直接获取  </span></span><br><span class="line">   <span class="comment">//ext前缀，表明操作的是外置属性。api是一个新的属性名。前面说过，只在  </span></span><br><span class="line">   <span class="comment">//第一次定义或者设置它的时候需要ext前缀  </span></span><br><span class="line">    gradle.ext.api =properties.getProperty(<span class="string">'sdk.api'</span>)  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">println</span> gradle.api  <span class="comment">//再次存取api的时候，就不需要ext前缀了  </span></span><br><span class="line">    ......  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>再来一个例子强化一下：</p>
<p>我在utils.gradle中定义了一些函数，然后想在其他build.gradle中调用这些函数。那该怎么做呢？</p>
<p>[utils.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//utils.gradle中定义了一个获取AndroidManifests.xmlversionName的函数  </span></span><br><span class="line"><span class="keyword">def</span>  getVersionNameAdvanced()&#123;  </span><br><span class="line">  下面这行代码中的<span class="keyword">project</span>是谁？  </span><br><span class="line">   defxmlFile = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">"AndroidManifest.xml"</span>)  </span><br><span class="line">   defrootManifest = <span class="keyword">new</span> XmlSlurper().parse(xmlFile)  </span><br><span class="line">   returnrootManifest[<span class="string">'@android:versionName'</span>]    </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//现在，想把这个API输出到各个Project。由于这个utils.gradle会被每一个Project Apply，所以  </span></span><br><span class="line"><span class="comment">//我可以把getVersionNameAdvanced定义成一个closure，然后赋值到一个外部属性  </span></span><br><span class="line">  下面的ext是谁的ext？  </span><br><span class="line">ext&#123; <span class="comment">//此段花括号中代码是闭包  </span></span><br><span class="line">    <span class="comment">//除了ext.<span class="label">xxx=value这种定义方法外，还可以使用ext&#123;&#125;这种书写方法。  </span></span></span><br><span class="line">    <span class="comment">//ext&#123;&#125;不是ext(Closure)对应的函数调用。但是ext&#123;&#125;中的&#123;&#125;确实是闭包。  </span></span><br><span class="line">    getVersionNameAdvanced = <span class="keyword">this</span>.&amp;getVersionNameAdvanced  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中有两个问题：</p>
<ul>
<li><p>project是谁？</p>
</li>
<li><p>ext是谁的ext？</p>
</li>
</ul>
<p>上面两个问题比较关键，我也是花了很长时间才搞清楚。这两个问题归结到一起，其实就是：</p>
<p><strong>加载utils.gradle的Project对象和utils.gradle本身所代表的Script对象到底有什么关系？</strong></p>
<p>我们在Groovy中也讲过怎么在一个Script中import另外一个Script中定义的类或者函数（见<strong>3.5 脚本类、文件I/O和XML操作一节</strong>）。在Gradle中，这一块的处理比Groovy要复杂，具体怎么搞我还没完全弄清楚，但是Project和utils.gradle对于的Script的对象的关系是：</p>
<ul>
<li>当一个Project apply一个gradle文件的时候，这个gradle文件会转换成一个Script对象。这个，相信大家都已经知道了。</li>
<li>Script中有一个delegate对象，这个delegate默认是加载（即调用apply）它的Project对象。但是，在apply函数中，有一个from参数，还有一个to参数（参考<strong>图31</strong>）。通过to参数，你可以把delegate对象指定为别的东西。</li>
<li>delegate对象是什么意思？当你在Script中操作一些不是Script自己定义的变量，或者函数时候，gradle会到Script的delegate对象去找，看看有没有定义这些变量或函数。</li>
</ul>
<p>现在你知道问题1,2和答案了：</p>
<ul>
<li>问题1：project就是加载utils.gradle的project。由于posdevice有5个project，所以utils.gradle会分别加载到5个project中。所以，getVersionNameAdvanced才不用区分到底是哪个project。反正一个project有一个utils.gradle对应的Script。</li>
<li>问题2：ext：自然就是Project对应的ext了。此处为Project添加了一些closure。那么，在Project中就可以调用getVersionNameAdvanced函数了</li>
</ul>
<p>比如：我在posdevice每个build.gradle中都有如下的代码：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tasks.getByName(<span class="string">"assemble"</span>)&#123;  </span><br><span class="line">   it.<span class="keyword">doLast</span>&#123;  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"$project.name: After assemble, jar libs are copied tolocal repository"</span>  </span><br><span class="line">        copyOutput(<span class="keyword">true</span>)  <span class="comment">//copyOutput是utils.gradle输出的closure  </span></span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过这种方式，我将一些常用的函数放到utils.gradle中，然后为加载它的Project设置ext属性。最后，Project中就可以调用这种赋值函数了！</strong></p>
<p>注意：此处我研究的还不是很深，而且我个人感觉：</p>
<ol>
<li>在Java和Groovy中：我们会把常用的函数放到一个辅助类和公共类中，然后在别的地方import并调用它们。</li>
<li><p>但是在Gradle，更正规的方法是在xxx.gradle中定义插件。然后通过添加Task的方式来完成工作。gradle的user guide有详细介绍如何实现自己的插件。</p>
</li>
<li><p>Task介绍</p>
</li>
</ol>
<p>Task是Gradle中的一种数据类型，它代表了一些要执行或者要干的工作。不同的插件可以添加不同的Task。每一个Task都需要和一个Project关联。</p>
<p>Task的API文档位于<strong><a href="https://docs.gradle.org/current/dsl/org.gradle.api.Task.html" target="_blank" rel="external">https://docs.gradle.org/current/dsl/org.gradle.api.Task.html</a></strong>。关于Task，我这里简单介绍下build.gradle中怎么写它，以及Task中一些常见的类型</p>
<p>关于Task。来看下面的例子：</p>
<p>[build.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Task是和Project关联的，所以，我们要利用Project的task函数来创建一个Task  </span></span><br><span class="line"><span class="keyword">task</span> myTask  &lt;==myTask是新建<span class="keyword">Task</span>的名字  </span><br><span class="line"><span class="keyword">task</span> myTask &#123; configure closure &#125;  </span><br><span class="line"><span class="keyword">task</span> myType &lt;&lt; &#123; <span class="keyword">task</span> action &#125; &lt;==注意，&lt;&lt;符号是<span class="keyword">doLast</span>的缩写  </span><br><span class="line"><span class="keyword">task</span> myTask(type: SomeType)  </span><br><span class="line"><span class="keyword">task</span> myTask(type: SomeType) &#123; configure closure &#125;</span><br></pre></td></tr></table></figure>
<p>上述代码中都用了Project的一个函数，名为task，注意：</p>
<ul>
<li>一个Task包含若干Action。所以，Task有doFirst和doLast两个函数，用于添加需要最先执行的Action和需要和需要最后执行的Action。Action就是一个闭包。</li>
<li>Task创建的时候可以指定Type，通过<strong>type:名字</strong>表达。这是什么意思呢？其实就是告诉Gradle，这个新建的Task对象会从哪个基类Task派生。比如，Gradle本身提供了一些通用的Task，最常见的有Copy 任务。Copy是Gradle中的一个类。当我们：<strong>task myTask(type:Copy)</strong>的时候，创建的Task就是一个Copy Task。</li>
<li>当我们使用 <strong>task myTask{ xxx}</strong>的时候。花括号是一个closure。这会导致gradle在创建这个Task之后，返回给用户之前，会先执行closure的内容。</li>
<li>当我们使用<strong>task myTask &lt;&lt; {xxx}</strong>的时候，我们创建了一个Task对象，同时把closure做为一个action加到这个Task的action队列中，并且告诉它“最后才执行这个closure”（<strong>注意，&lt;&lt;符号是doLast的代表</strong>）。</li>
</ul>
<p>图32是Project中关于task函数说明：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image035.png" alt=""></p>
<p> 陆陆续续讲了这么些内容，我自己感觉都有点烦了。是得，Gradle用一整本书来讲都嫌不够呢。</p>
<p>anyway，到目前为止，我介绍的都是一些比较基础的东西，还不是特别多。但是后续例子该涉及到的知识点都有了。下面我们直接上例子。这里有两个例子：</p>
<ul>
<li>posdevice的例子</li>
<li>另外一个是单个project的例子</li>
</ul>
<p><strong>4.4.3  posdevice实例</strong></p>
<p>现在正是开始通过例子来介绍怎么玩gradle。这里要特别强调一点，根据Gradle的哲学。gradle文件中包含一些所谓的<strong>Script Block</strong>（<strong>姑且这么称它</strong>）。<strong>Script Block</strong>作用是让我们来配置相关的信息。不同的<strong>SB</strong>有不同的需要配置的东西。这也是我最早说的行话。比如，源码对应的SB，就需要我们配置源码在哪个文件夹里。关于SB，我们后面将见识到！</p>
<p>posdevice是一个multi project。下面包含5个Project。对于这种Project，请大家回想下我们该创建哪些文件？</p>
<ul>
<li>settings.gradle是必不可少的</li>
<li>根目录下的build.gradle。这个我们没讲过，因为posdevice的根目录本身不包含代码，而是包含其他5个子project。</li>
<li>每个project目录下包含对于的build.gradle</li>
<li>另外，我把常用的函数封装到一个名为utils.gradle的脚本里了。</li>
</ul>
<p>马上一个一个来看它们。</p>
<ol>
<li>utils.gradle</li>
</ol>
<p>utils.gradle是我自己加的，为我们团队特意加了一些常见函数。主要代码如下：</p>
<p>[utils.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> groovy.util.XmlSlurper  <span class="comment">//解析XML时候要引入这个groovy的package  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> copyFile(String srcFile,dstFile)&#123;  </span><br><span class="line">     ......<span class="comment">//拷贝文件函数，用于将最后的生成物拷贝到指定的目录  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">def</span> rmFile(String targetFile)&#123;  </span><br><span class="line">    .....<span class="comment">//删除指定目录中的文件  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> cleanOutput(<span class="keyword">boolean</span> bJar = <span class="keyword">true</span>)&#123;  </span><br><span class="line">    ....<span class="comment">//clean的时候清理  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> copyOutput(<span class="keyword">boolean</span> bJar = <span class="keyword">true</span>)&#123;  </span><br><span class="line">    ....<span class="comment">//copyOutput内部会调用copyFile完成一次build的产出物拷贝  </span></span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> getVersionNameAdvanced()&#123;<span class="comment">//老朋友  </span></span><br><span class="line">   defxmlFile = <span class="keyword">project</span>.<span class="keyword">file</span>(<span class="string">"AndroidManifest.xml"</span>)  </span><br><span class="line">   defrootManifest = <span class="keyword">new</span> XmlSlurper().parse(xmlFile)  </span><br><span class="line">   returnrootManifest[<span class="string">'@android:versionName'</span>]    </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//对于android library编译，我会disable所有的debug编译任务  </span></span><br><span class="line"><span class="keyword">def</span> disableDebugBuild()&#123;  </span><br><span class="line">  <span class="comment">//project.tasks包含了所有的tasks，下面的findAll是寻找那些名字中带debug的Task。  </span></span><br><span class="line">  <span class="comment">//返回值保存到targetTasks容器中  </span></span><br><span class="line">  <span class="keyword">def</span> targetTasks = <span class="keyword">project</span>.tasks.<span class="keyword">findAll</span>&#123;<span class="keyword">task</span> -&gt;  </span><br><span class="line">     <span class="keyword">task</span>.name.contains(<span class="string">"Debug"</span>)  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">//对满足条件的task，设置它为disable。如此这般，这个Task就不会被执行  </span></span><br><span class="line"> targetTasks.<span class="keyword">each</span>&#123;  </span><br><span class="line">     <span class="keyword">println</span><span class="string">"disable debug task  :$&#123;it.name&#125;"</span>  </span><br><span class="line">    it.setEnabled <span class="keyword">false</span>  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//将函数设置为extra属性中去，这样，加载utils.gradle的Project就能调用此文件中定义的函数了  </span></span><br><span class="line">ext&#123;  </span><br><span class="line">    copyFile= <span class="keyword">this</span>.©<span class="keyword">File</span>  </span><br><span class="line">    rmFile =<span class="keyword">this</span>.&amp;rmFile  </span><br><span class="line">   cleanOutput = <span class="keyword">this</span>.&amp;cleanOutput  </span><br><span class="line">   copyOutput = <span class="keyword">this</span>.©Output  </span><br><span class="line">   getVersionNameAdvanced = <span class="keyword">this</span>.&amp;getVersionNameAdvanced  </span><br><span class="line">   disableDebugBuild = <span class="keyword">this</span>.&amp;disableDebugBuild  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图33展示了被disable的Debug任务的部分信息：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image036.png" alt=""></p>
<ol>
<li>settings.gradle</li>
</ol>
<p>这个文件中我们该干什么？调用include把需要包含的子Project加进来。代码如下：</p>
<p>[settings.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*我们团队内部建立的编译环境初始化函数 </span><br><span class="line">  这个函数的目的是 </span><br><span class="line">  1  解析一个名为local.properties的文件，读取AndroidSDK和NDK的路径 </span><br><span class="line">  2  获取最终产出物目录的路径。这样，编译完的apk或者jar包将拷贝到这个最终产出物目录中 </span><br><span class="line">  3 获取Android SDK指定编译的版本 </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="keyword">def</span> initMinshengGradleEnvironment()&#123;  </span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment ....."</span>  </span><br><span class="line">   Properties properties = <span class="keyword">new</span> Properties()  </span><br><span class="line">   <span class="comment">//local.properites也放在posdevice目录下  </span></span><br><span class="line">    FilepropertyFile = <span class="keyword">new</span> <span class="keyword">File</span>(rootDir.getAbsolutePath()+ <span class="string">"/local.properties"</span>)  </span><br><span class="line">   properties.load(propertyFile.newDataInputStream())  </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">      根据Project、Gradle生命周期的介绍，settings对象的创建位于具体Project创建之前 </span><br><span class="line">      而Gradle底对象已经创建好了。所以，我们把local.properties的信息读出来后，通过 </span><br><span class="line">     extra属性的方式设置到gradle对象中 </span><br><span class="line">      而具体Project在执行的时候，就可以直接从gradle对象中得到这些属性了！ </span><br><span class="line">    */</span>  </span><br><span class="line">    gradle.ext.api =properties.getProperty(<span class="string">'sdk.api'</span>)  </span><br><span class="line">    gradle.ext.sdkDir =properties.getProperty(<span class="string">'sdk.dir'</span>)  </span><br><span class="line">     gradle.ext.ndkDir =properties.getProperty(<span class="string">'ndk.dir'</span>)  </span><br><span class="line">     gradle.ext.localDir =properties.getProperty(<span class="string">'local.dir'</span>)  </span><br><span class="line">    <span class="comment">//指定debugkeystore文件的位置，debug版apk签名的时候会用到  </span></span><br><span class="line">    gradle.ext.debugKeystore= properties.getProperty(<span class="string">'debug.keystore'</span>)  </span><br><span class="line">     ......  </span><br><span class="line">    <span class="keyword">println</span><span class="string">"initialize Minsheng Gradle Environment completes..."</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//初始化  </span></span><br><span class="line">initMinshengGradleEnvironment()  </span><br><span class="line"><span class="comment">//添加子Project信息  </span></span><br><span class="line"><span class="keyword">include</span> <span class="string">'CPosSystemSdk'</span> , <span class="string">'CPosDeviceSdk'</span> ,<span class="string">'CPosSdkDemo'</span>,<span class="string">'CPosDeviceServerApk'</span>, <span class="string">'CPosSystemSdkWizarPosImpl'</span></span><br></pre></td></tr></table></figure>
<p>注意，对于Android来说，local.properties文件是必须的，它的内容如下：</p>
<p>[local.properties]</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local.dir=<span class="regexp">/home/innost</span><span class="regexp">/workspace/minsheng</span>-flat-dir/  </span><br><span class="line"><span class="regexp">//</span>注意，根据<span class="constant">Android</span> <span class="constant">Gradle</span>的规范，只有下面两个属性是必须的，其余都是我自己加的  </span><br><span class="line">sdk.dir=<span class="regexp">/home/innost</span><span class="regexp">/workspace/android</span>-aosp-sdk/  </span><br><span class="line">ndk.dir=<span class="regexp">/home/innost</span><span class="regexp">/workspace/android</span>-aosp-ndk/  </span><br><span class="line">debug.keystore=<span class="regexp">/home/innost</span><span class="regexp">/workspace/tools</span><span class="regexp">/mykeystore.jks  </span><br><span class="line">sdk.api=android-19</span></span><br></pre></td></tr></table></figure>
<p>再次强调，<strong>sdk.dir</strong>和<strong>ndk.dir</strong>是Android Gradle必须要指定的，其他都是我自己加的属性。当然。不编译<strong>ndk</strong>，就不需要<strong>ndk.dir</strong>属性了。</p>
<ol>
<li>posdevice build.gradle</li>
</ol>
<p>作为multi-project根目录，一般情况下，它的build.gradle是做一些全局配置。来看我的build.gradle</p>
<p>[posdevice build.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面这个subprojects&#123;&#125;就是一个Script Block  </span></span><br><span class="line"><span class="keyword">subprojects</span> &#123;  </span><br><span class="line">  <span class="keyword">println</span><span class="string">"Configure for $project.name"</span> <span class="comment">//遍历子Project，project变量对应每个子Project  </span></span><br><span class="line">  <span class="keyword">buildscript</span> &#123;  <span class="comment">//这也是一个SB  </span></span><br><span class="line">    <span class="keyword">repositories</span> &#123;<span class="comment">//repositories是一个SB  </span></span><br><span class="line">       <span class="comment">///jcenter是一个函数，表示编译过程中依赖的库，所需的插件可以在jcenter仓库中  </span></span><br><span class="line">       <span class="comment">//下载。  </span></span><br><span class="line">       jcenter()  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">dependencies</span> &#123; <span class="comment">//SB  </span></span><br><span class="line">        <span class="comment">//dependencies表示我们编译的时候，依赖android开发的gradle插件。插件对应的  </span></span><br><span class="line">       <span class="comment">//class path是com.android.tools.build。版本是1.2.3  </span></span><br><span class="line">        <span class="keyword">classpath</span><span class="string">'com.android.tools.build:gradle:1.2.3'</span>  </span><br><span class="line">    &#125;  </span><br><span class="line">   <span class="comment">//为每个子Project加载utils.gradle 。当然，这句话可以放到buildscript花括号之后  </span></span><br><span class="line">   applyfrom: rootProject.getRootDir().getAbsolutePath() + <span class="string">"/utils.gradle"</span>  </span><br><span class="line"> &#125;<span class="comment">//buildscript结束  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>感觉解释得好苍白，SB在Gradle的API文档中也是有的。先来看Gradle定义了哪些SB。如图34所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image037.png" alt=""></p>
<p> 你看，subprojects、dependencies、repositories都是SB。那么SB到底是什么？它是怎么完成所谓配置的呢？</p>
<p>仔细研究，你会发现SB后面都需要跟一个花括号，而花括号，恩，我们感觉里边可能一个Closure。由于图34说，这些SB的Description都有“Configure xxx for this project”，<strong>所以很可能subprojects是一个函数，然后其参数是一个Closure。是这样的吗？</strong></p>
<p>Absolutely right。只是这些函数你直接到Project API里不一定能找全。不过要是你好奇心重，不妨到<strong><a href="https://docs.gradle.org/current/javadoc/" target="_blank" rel="external">https://docs.gradle.org/current/javadoc/</a></strong>，选择<strong>Index</strong>这一项，然后<strong>ctrl+f</strong>，输入图34中任何一个Block，你都会找到对应的函数。比如我替你找了几个API，如图35所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image038.png" alt=""></p>
<p> 特别提示：当你下次看到一个不认识的SB的时候，就去看API吧。</p>
<p>下面来解释代码中的各个SB：</p>
<ul>
<li>subprojects：它会遍历posdevice中的每个子Project。在它的Closure中，默认参数是子Project对应的Project对象。由于其他SB都在subprojects花括号中，所以相当于对每个Project都配置了一些信息。</li>
<li>buildscript：它的closure是在一个类型为ScriptHandler的对象上执行的。主意用来所依赖的classpath等信息。通过查看ScriptHandler API可知，在buildscript SB中，你可以调用ScriptHandler提供的repositories(Closure )、dependencies(Closure)函数。这也是为什么repositories和dependencies两个SB为什么要放在buildscript的花括号中的原因。<strong>明白了？这就是所谓的行话，得知道规矩。不知道规矩你就乱了。记不住规矩，又不知道查SDK，那么就彻底抓瞎，只能到网上到处找答案了！</strong></li>
<li>关于repositories和dependencies，大家直接看API吧。后面碰到了具体代码我们再来介绍</li>
</ul>
<ol>
<li>CPosDeviceSdk build.gradle</li>
</ol>
<p>CPosDeviceSdk是一个Android Library。按Google的想法，Android Library编译出来的应该是一个AAR文件。但是我的项目有些特殊，我需要发布CPosDeviceSdk.jar包给其他人使用。jar在编译过程中会生成，但是它不属于Android Library的标准输出。在这种情况下，我需要在编译完成后，主动copy jar包到我自己设计的产出物目录中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Library工程必须加载此插件。注意，加载了Android插件就不要加载Java插件了。因为Android  </span></span><br><span class="line"><span class="comment">//插件本身就是拓展了Java插件  </span></span><br><span class="line">apply plugin: <span class="string">'com.android.library'</span>   </span><br><span class="line"><span class="comment">//android的编译，增加了一种新类型的ScriptBlock--&gt;android  </span></span><br><span class="line">android &#123;  </span><br><span class="line">       <span class="comment">//你看，我在local.properties中设置的API版本号，就可以一次设置，多个Project使用了  </span></span><br><span class="line">      <span class="comment">//借助我特意设计的gradle.ext.api属性  </span></span><br><span class="line">       compileSdkVersion =gradle.api  <span class="comment">//这两个红色的参数必须设置  </span></span><br><span class="line">       buildToolsVersion  = <span class="string">"22.0.1"</span>  </span><br><span class="line">       <span class="keyword">sourceSets</span>&#123; <span class="comment">//配置源码路径。这个sourceSets是Java插件引入的  </span></span><br><span class="line">       main&#123; <span class="comment">//main：Android也用了  </span></span><br><span class="line">           manifest.srcFile <span class="string">'AndroidManifest.xml'</span> <span class="comment">//这是一个函数，设置manifest.srcFile  </span></span><br><span class="line">           aidl.srcDirs=[<span class="string">'src'</span>] <span class="comment">//设置aidl文件的目录  </span></span><br><span class="line">           java.srcDirs=[<span class="string">'src'</span>] <span class="comment">//设置java文件的目录  </span></span><br><span class="line">        &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">   <span class="keyword">dependencies</span> &#123;  <span class="comment">//配置依赖关系  </span></span><br><span class="line">      <span class="comment">//compile表示编译和运行时候需要的jar包，fileTree是一个函数，  </span></span><br><span class="line">     <span class="comment">//dir:'libs'，表示搜索目录的名称是libs。include:['*.jar']，表示搜索目录下满足*.jar名字的jar  </span></span><br><span class="line">     <span class="comment">//包都作为依赖jar文件  </span></span><br><span class="line">       <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;  <span class="comment">//android SB配置完了  </span></span><br><span class="line"><span class="comment">//clean是一个Task的名字，这个Task好像是Java插件（这里是Android插件）引入的。  </span></span><br><span class="line"><span class="comment">//dependsOn是一个函数，下面这句话的意思是 clean任务依赖cposCleanTask任务。所以  </span></span><br><span class="line"><span class="comment">//当你gradle clean以执行clean Task的时候，cposCleanTask也会执行  </span></span><br><span class="line">clean.dependsOn <span class="string">'cposCleanTask'</span>  </span><br><span class="line"><span class="comment">//创建一个Task，  </span></span><br><span class="line"><span class="keyword">task</span> cposCleanTask() &lt;&lt;&#123;  </span><br><span class="line">    cleanOutput(<span class="keyword">true</span>)  <span class="comment">//cleanOutput是utils.gradle中通过extra属性设置的Closure  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//前面说了，我要把jar包拷贝到指定的目录。对于Android编译，我一般指定gradle assemble  </span></span><br><span class="line"><span class="comment">//它默认编译debug和release两种输出。所以，下面这个段代码表示：  </span></span><br><span class="line"><span class="comment">//tasks代表一个Projects中的所有Task，是一个容器。getByName表示找到指定名称的任务。  </span></span><br><span class="line"><span class="comment">//我这里要找的assemble任务，然后我通过doLast添加了一个Action。这个Action就是copy  </span></span><br><span class="line"><span class="comment">//产出物到我设置的目标目录中去  </span></span><br><span class="line">tasks.getByName(<span class="string">"assemble"</span>)&#123;  </span><br><span class="line">   it.<span class="keyword">doLast</span>&#123;  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"$project.name: After assemble, jar libs are copied tolocal repository"</span>  </span><br><span class="line">        copyOutput(<span class="keyword">true</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">/* </span><br><span class="line">  因为我的项目只提供最终的release编译出来的Jar包给其他人，所以不需要编译debug版的东西 </span><br><span class="line">  当Project创建完所有任务的有向图后，我通过afterEvaluate函数设置一个回调Closure。在这个回调 </span><br><span class="line">  Closure里，我disable了所有Debug的Task </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="keyword">project</span>.afterEvaluate&#123;  </span><br><span class="line">    disableDebugBuild()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Android自己定义了好多ScriptBlock。Android定义的DSL参考文档在</p>
<p><strong><a href="https://developer.android.com/tools/building/plugin-for-gradle.html" target="_blank" rel="external">https://developer.android.com/tools/building/plugin-for-gradle.html</a></strong>下载。注意，它居然没有提供在线文档。</p>
<p>图36所示为Android的DSL参考信息。</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image039.png" alt=""></p>
<p>图37为<strong>buildToolsVersion</strong>和<strong>compileSdkVersion</strong>的说明：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image040.png" alt=""></p>
<p> 从图37可知，这两个变量是必须要设置的…..</p>
<ol>
<li>CPosDeviceServerApk build.gradle</li>
</ol>
<p>再来看一个APK的build，它包含NDK的编译，并且还要签名。根据项目的需求，我们只能签debug版的，而release版的签名得发布unsigned包给领导签名。另外，CPosDeviceServerAPK依赖CPosDeviceSdk。</p>
<p>虽然我可以先编译CPosDeviceSdk，得到对应的jar包，然后设置CPosDeviceServerApk直接依赖这个jar包就好。但是我更希望CPosDeviceServerApk能直接依赖于CPosDeviceSdk这个工程。这样，整个posdevice可以做到这几个Project的依赖关系是最新的。</p>
<p>[build.gradle]</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span>  <span class="comment">//APK编译必须加载这个插件  </span></span><br><span class="line">android &#123;  </span><br><span class="line">      compileSdkVersion gradle.api  </span><br><span class="line">      buildToolsVersion <span class="string">"22.0.1"</span>  </span><br><span class="line">      <span class="keyword">sourceSets</span>&#123;  <span class="comment">//差不多的设置  </span></span><br><span class="line">       main&#123;  </span><br><span class="line">           manifest.srcFile <span class="string">'AndroidManifest.xml'</span>  </span><br><span class="line">          <span class="comment">//通过设置jni目录为空，我们可不使用apk插件的jni编译功能。为什么？因为据说  </span></span><br><span class="line">         <span class="comment">//APK插件的jni功能好像不是很好使....晕菜  </span></span><br><span class="line">          jni.srcDirs = []   </span><br><span class="line">           jniLibs.srcDir <span class="string">'libs'</span>  </span><br><span class="line">            aidl.srcDirs=[<span class="string">'src'</span>]  </span><br><span class="line">           java.srcDirs=[<span class="string">'src'</span>]  </span><br><span class="line">           res.srcDirs=[<span class="string">'res'</span>]  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//main结束  </span></span><br><span class="line">   signingConfigs &#123; <span class="comment">//设置签名信息配置  </span></span><br><span class="line">       debug &#123;  <span class="comment">//如果我们在local.properties设置使用特殊的keystore，则使用它  </span></span><br><span class="line">           <span class="comment">//下面这些设置，无非是函数调用....请务必阅读API文档  </span></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">project</span>.gradle.debugKeystore != <span class="keyword">null</span>)&#123;  </span><br><span class="line">              storeFile <span class="keyword">file</span>(<span class="string">"file://$&#123;project.gradle.debugKeystore&#125;"</span>)  </span><br><span class="line">              storePassword <span class="string">"android"</span>  </span><br><span class="line">              keyAlias <span class="string">"androiddebugkey"</span>  </span><br><span class="line">              keyPassword <span class="string">"android"</span>  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">   &#125;<span class="comment">//signingConfigs结束  </span></span><br><span class="line">     buildTypes &#123;  </span><br><span class="line">       debug &#123;  </span><br><span class="line">           signingConfig signingConfigs.debug  </span><br><span class="line">           jniDebuggable <span class="keyword">false</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;<span class="comment">//buildTypes结束  </span></span><br><span class="line">   <span class="keyword">dependencies</span> &#123;  </span><br><span class="line">        <span class="comment">//compile：project函数可指定依赖multi-project中的某个子project  </span></span><br><span class="line">       <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':CPosDeviceSdk'</span>)  </span><br><span class="line">       <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])  </span><br><span class="line">   &#125; <span class="comment">//dependices结束  </span></span><br><span class="line">  <span class="keyword">repositories</span>&#123;  </span><br><span class="line">   <span class="keyword">flatDir</span> &#123;<span class="comment">//flatDir：告诉gradle，编译中依赖的jar包存储在dirs指定的目录  </span></span><br><span class="line">           name <span class="string">"minsheng-gradle-local-repository"</span>  </span><br><span class="line">            dirsgradle.LOCAL_JAR_OUT <span class="comment">//LOCAL_JAR_OUT是我存放编译出来的jar包的位置  </span></span><br><span class="line">   &#125;  </span><br><span class="line">  &#125;<span class="comment">//repositories结束  </span></span><br><span class="line">&#125;<span class="comment">//android结束  </span></span><br><span class="line"><span class="comment">/* </span><br><span class="line">   创建一个Task，类型是Exec，这表明它会执行一个命令。我这里让他执行ndk的 </span><br><span class="line">   ndk-build命令，用于编译ndk。关于Exec类型的Task，请自行脑补Gradle的API </span><br><span class="line">*/</span>  </span><br><span class="line"><span class="comment">//注意此处创建task的方法，是直接&#123;&#125;喔，那么它后面的tasks.withType(JavaCompile)  </span></span><br><span class="line"><span class="comment">//设置的依赖关系，还有意义吗？Think！如果你能想明白，gradle掌握也就差不多了  </span></span><br><span class="line"><span class="keyword">task</span> buildNative(type: Exec, <span class="keyword">description</span>: <span class="string">'CompileJNI source via NDK'</span>) &#123;  </span><br><span class="line">       <span class="keyword">if</span>(<span class="keyword">project</span>.gradle.ndkDir == <span class="keyword">null</span>) <span class="comment">//看看有没有指定ndk.dir路径  </span></span><br><span class="line">          <span class="keyword">println</span> <span class="string">"CANNOT Build NDK"</span>  </span><br><span class="line">       <span class="keyword">else</span>&#123;  </span><br><span class="line">            commandLine <span class="string">"/$&#123;project.gradle.ndkDir&#125;/ndk-build"</span>,  </span><br><span class="line">               <span class="string">'-C'</span>, <span class="keyword">file</span>(<span class="string">'jni'</span>).absolutePath,  </span><br><span class="line">               <span class="string">'-j'</span>, <span class="keyword">Runtime</span>.<span class="keyword">runtime</span>.availableProcessors(),  </span><br><span class="line">               <span class="string">'all'</span>, <span class="string">'NDK_DEBUG=0'</span>  </span><br><span class="line">        &#125;  </span><br><span class="line">  &#125;  </span><br><span class="line"> tasks.withType(JavaCompile) &#123;  </span><br><span class="line">       compileTask -&gt; compileTask.dependsOn buildNative  </span><br><span class="line">  &#125;  </span><br><span class="line">  ......    </span><br><span class="line"> <span class="comment">//对于APK，除了拷贝APK文件到指定目录外，我还特意为它们加上了自动版本命名的功能  </span></span><br><span class="line"> tasks.getByName(<span class="string">"assemble"</span>)&#123;  </span><br><span class="line">       it.<span class="keyword">doLast</span>&#123;  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"$project.name: After assemble, jar libs are copied tolocal repository"</span>  </span><br><span class="line">       <span class="keyword">project</span>.ext.versionName = android.defaultConfig.versionName  </span><br><span class="line">       <span class="keyword">println</span> <span class="string">"\t versionName = $versionName"</span>  </span><br><span class="line">       copyOutput(<span class="keyword">false</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>结果展示</li>
</ol>
<p>在posdevice下执行gradle assemble命令，最终的输出文件都会拷贝到我指定的目录，结果如图38所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image041.png" alt=""></p>
<p> 图38所示为posdevice<strong> gradle assemble</strong>的执行结果：</p>
<ul>
<li>library包都编译release版的，copy到xxx/javaLib目录下</li>
<li>apk编译debug和release-unsigned版的，copy到apps目录下</li>
<li>所有产出物都自动从AndroidManifest.xml中提取versionName。</li>
</ul>
<p><strong>4.4.4  实例2</strong></p>
<p>下面这个实例也是来自一个实际的APP。这个APP对应的是一个单独的Project。但是根据我前面的建议，我会把它改造成支持Multi-Projects Build的样子。即在工程目录下放一个settings.build。</p>
<p>另外，这个app有一个特点。它有三个版本，分别是debug、release和demo。这三个版本对应的代码都完全一样，但是在运行的时候需要从assets/runtime_config文件中读取参数。参数不同，则运行的时候会跳转到debug、release或者demo的逻辑上。</p>
<p>注意：我知道assets/runtime_config这种做法不decent，但，这是一个既有项目，我们只能做小范围的适配，而不是伤筋动骨改用更好的方法。另外，从未来的需求来看，暂时也没有大改的必要。</p>
<p>引入gradle后，我们该如何处理呢？</p>
<p>解决方法是：在编译build、release和demo版本前，在build.gradle中自动设置runtime_config的内容。代码如下所示：</p>
<p>[build.gradle]</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="symbol">'com</span>.android.application'  <span class="comment">//加载APP插件  </span></span><br><span class="line"><span class="comment">//加载utils.gradle  </span></span><br><span class="line">apply from:rootProject.getRootDir().getAbsolutePath() + <span class="string">"/utils.gradle"</span>  </span><br><span class="line"><span class="comment">//buildscript设置android app插件的位置  </span></span><br><span class="line">buildscript &#123;  </span><br><span class="line">   repositories &#123; jcenter() &#125;  </span><br><span class="line">   dependencies &#123; classpath <span class="symbol">'com</span>.android.tools.build:gradle:<span class="number">1.2</span><span class="number">.3</span>' &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//androidScriptBlock  </span></span><br><span class="line">android &#123;  </span><br><span class="line">   compileSdkVersion gradle.api  </span><br><span class="line">   buildToolsVersion <span class="string">"22.0.1"</span>  </span><br><span class="line">   sourceSets&#123;<span class="comment">//源码设置SB  </span></span><br><span class="line">        main&#123;  </span><br><span class="line">           manifest.srcFile <span class="symbol">'AndroidManifest</span>.xml'  </span><br><span class="line">           jni.srcDirs = []  </span><br><span class="line">           jniLibs.srcDir <span class="symbol">'lib</span>s'  </span><br><span class="line">           aidl.srcDirs=[<span class="symbol">'sr</span>c']  </span><br><span class="line">           java.srcDirs=[<span class="symbol">'sr</span>c']  </span><br><span class="line">           res.srcDirs=[<span class="symbol">'re</span>s']  </span><br><span class="line">           assets.srcDirs = [<span class="symbol">'asset</span>s'] <span class="comment">//多了一个assets目录  </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">   signingConfigs &#123;<span class="comment">//签名设置  </span></span><br><span class="line">       debug &#123;  <span class="comment">//debug对应的SB。注意  </span></span><br><span class="line">           <span class="keyword">if</span>(project.gradle.debugKeystore != <span class="literal">null</span>)&#123;  </span><br><span class="line">               storeFile file(<span class="string">"file://$&#123;project.gradle.debugKeystore&#125;"</span>)  </span><br><span class="line">               storePassword <span class="string">"android"</span>  </span><br><span class="line">               keyAlias <span class="string">"androiddebugkey"</span>  </span><br><span class="line">               keyPassword <span class="string">"android"</span>  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     最关键的内容来了： buildTypesScriptBlock. </span><br><span class="line">     buildTypes和上面的signingConfigs，当我们在build.gradle中通过&#123;&#125;配置它的时候， </span><br><span class="line">     其背后的所代表的对象是NamedDomainObjectContainer&lt;BuildType&gt; 和 </span><br><span class="line">     NamedDomainObjectContainer&lt;SigningConfig&gt; </span><br><span class="line">     注意，NamedDomainObjectContainer&lt;BuildType/或者SigningConfig&gt;是一种容器， </span><br><span class="line">     容器的元素是BuildType或者SigningConfig。我们在debug&#123;&#125;要填充BuildType或者 </span><br><span class="line">    SigningConfig所包的元素，比如storePassword就是SigningConfig类的成员。而proguardFile等 </span><br><span class="line">    是BuildType的成员。 </span><br><span class="line">    那么，为什么要使用NamedDomainObjectContainer这种数据结构呢？因为往这种容器里 </span><br><span class="line">    添加元素可以采用这样的方法： 比如signingConfig为例 </span><br><span class="line">    signingConfig&#123;//这是一个NamedDomainObjectContainer&lt;SigningConfig&gt; </span><br><span class="line">       test1&#123;//新建一个名为test1的SigningConfig元素，然后添加到容器里 </span><br><span class="line">         //在这个花括号中设置SigningConfig的成员变量的值 </span><br><span class="line">       &#125; </span><br><span class="line">      test2&#123;//新建一个名为test2的SigningConfig元素，然后添加到容器里 </span><br><span class="line">         //在这个花括号中设置SigningConfig的成员变量的值 </span><br><span class="line">      &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    在buildTypes中，Android默认为这几个NamedDomainObjectContainer添加了 </span><br><span class="line">    debug和release对应的对象。如果我们再添加别的名字的东西，那么gradleassemble的时候 </span><br><span class="line">    也会编译这个名字的apk出来。比如，我添加一个名为test的buildTypes，那么gradle assemble </span><br><span class="line">    就会编译一个xxx-test-yy.apk。在此，test就好像debug、release一样。 </span><br><span class="line">   */</span>  </span><br><span class="line">   buildTypes&#123;  </span><br><span class="line">        debug&#123; <span class="comment">//修改debug的signingConfig为signingConfig.debug配置  </span></span><br><span class="line">           signingConfig signingConfigs.debug  </span><br><span class="line">        &#125;  </span><br><span class="line">        demo&#123; <span class="comment">//demo版需要混淆  </span></span><br><span class="line">           proguardFile <span class="symbol">'proguard</span>-project.txt'  </span><br><span class="line">           signingConfig signingConfigs.debug  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="comment">//release版没有设置，所以默认没有签名，没有混淆  </span></span><br><span class="line">    &#125;  </span><br><span class="line">      ......<span class="comment">//其他和posdevice 类似的处理。来看如何动态生成runtime_config文件  </span></span><br><span class="line">   <span class="function"><span class="keyword">def</span>  <span class="title">runtime_config_file</span> =</span> <span class="symbol">'assets</span>/runtime_config'  </span><br><span class="line">   <span class="comment">/* </span><br><span class="line">   我们在gradle解析完整个任务之后，找到对应的Task，然后在里边添加一个doFirst Action </span><br><span class="line">   这样能确保编译开始的时候，我们就把runtime_config文件准备好了。 </span><br><span class="line">   注意，必须在afterEvaluate里边才能做，否则gradle没有建立完任务有向图，你是找不到 </span><br><span class="line">   什么preDebugBuild之类的任务的 </span><br><span class="line">   */</span>  </span><br><span class="line">   project.afterEvaluate&#123;  </span><br><span class="line">      <span class="comment">//找到preDebugBuild任务，然后添加一个Action   </span></span><br><span class="line">      tasks.getByName(<span class="string">"preDebugBuild"</span>)&#123;  </span><br><span class="line">           it.doFirst&#123;  </span><br><span class="line">               println <span class="string">"generate debug configuration for $&#123;project.name&#125;"</span>  </span><br><span class="line">               <span class="function"><span class="keyword">def</span> <span class="title">configFile</span> =</span> <span class="keyword">new</span> <span class="type">File</span>(runtime_config_file)  </span><br><span class="line">               configFile.withOutputStream&#123;os-&gt;  </span><br><span class="line">                   os &lt;&lt; <span class="type">I</span> am <span class="type">Debug</span>\n'  <span class="comment">//往配置文件里写 I am Debug  </span></span><br><span class="line">                &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="comment">//找到preReleaseBuild任务  </span></span><br><span class="line">       tasks.getByName(<span class="string">"preReleaseBuild"</span>)&#123;  </span><br><span class="line">           it.doFirst&#123;  </span><br><span class="line">               println <span class="string">"generate release configuration for $&#123;project.name&#125;"</span>  </span><br><span class="line">               <span class="function"><span class="keyword">def</span> <span class="title">configFile</span> =</span> <span class="keyword">new</span> <span class="type">File</span>(runtime_config_file)  </span><br><span class="line">               configFile.withOutputStream&#123;os-&gt;  </span><br><span class="line">                   os &lt;&lt; <span class="type">I</span> am release\n'  </span><br><span class="line">               &#125;  </span><br><span class="line">           &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">       <span class="comment">//找到preDemoBuild。这个任务明显是因为我们在buildType里添加了一个demo的元素  </span></span><br><span class="line">      <span class="comment">//所以Android APP插件自动为我们生成的  </span></span><br><span class="line">       tasks.getByName(<span class="string">"preDemoBuild"</span>)&#123;  </span><br><span class="line">           it.doFirst&#123;  </span><br><span class="line">               println <span class="string">"generate offlinedemo configuration for$&#123;project.name&#125;"</span>  </span><br><span class="line">               <span class="function"><span class="keyword">def</span> <span class="title">configFile</span> =</span> <span class="keyword">new</span> <span class="type">File</span>(runtime_config_file)  </span><br><span class="line">               configFile.withOutputStream&#123;os-&gt;  </span><br><span class="line">                   os &lt;&lt; <span class="type">I</span> am <span class="type">Demo</span>\n'  </span><br><span class="line">               &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"> .....<span class="comment">//copyOutput</span></span><br></pre></td></tr></table></figure>
<p>最终的结果如图39所示：</p>
<p><img src="http://cdn.infoqstatic.com/statics_s1_20151203-0208/resource/articles/android-in-depth-gradle/zh/resources/image042.png" alt=""></p>
<p> 几个问题，为什么我知道有preXXXBuild这样的任务？</p>
<p><strong>答案：gradle tasks –all查看所有任务。然后，多尝试几次，直到成功</strong></p>
<p>五、总结</p>
<p>到此，我个人觉得Gradle相关的内容都讲完了。很难相信我仅花了1个小时不到的时间就为实例2添加了gradle编译支持。在一周以前，我还觉得这是个心病。回想学习gradle的一个月时间里，走过不少弯路，求解问题的思路也和最开始不一样：</p>
<ul>
<li>最开始的时候，我一直把gradle当做脚本看。然后到处到网上找怎么配置gradle。可能能编译成功，但是完全不知道为什么。比如NameDomainObjectContainer，为什么有debug、release。能自己加别的吗？不知道怎么加，没有章法，没有参考。出了问题只能google，找到一个解法，试一试，成功就不管。这么搞，心里不踏实。</li>
<li>另外，对语法不熟悉，尤其是Groovy语法，虽然看了下快速教材，但总感觉一到gradle就看不懂。主要问题还是闭包，比如Groovy那一节写得文件拷贝的例子中的withOutputStream，还有gradle中的withType，都是些啥玩意啊？</li>
<li>所以后来下决心先把Groovy学会，主要是把自己暴露在闭包里边。另外，Groovy是一门语言，总得有SDK说明吧。写了几个例子，慢慢体会到Groovy的好处，也熟悉Groovy的语法了。</li>
<li>接着开始看Gradle。Gradle有几本书，我看过Gradle in Action。说实话，看得非常痛苦。现在想起来，Gradle其实比较简单，知道它的生命周期，知道它怎么解析脚本，知道它的API，几乎很快就能干活。而Gradle In Action一上来就很细，而且没有从API角度介绍。说个很有趣的事情，书中有个类似下面的例子</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> myTask  &lt;&lt;  &#123;</span><br><span class="line">   <span class="keyword">println</span> <span class="string">' I am myTask'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书中说，如果代码没有加&lt;&lt;，则这个任务在脚本<strong>initialization</strong>（也就是你无论执行什么任务，这个任务都会被执行，<strong>I am myTask</strong>都会被输出）的时候执行，如果加了<strong>&lt;&lt;</strong>，则在gradle myTask后才执行。</p>
<p>我开始完全不知道为什么，死记硬背。<strong>现在你明白了吗？？？？</strong></p>
<p>这和我们调用task这个函数的方式有关！如果没有&lt;&lt;，则闭包在task函数返回前会执行，而如果加了&lt;&lt;，则变成调用myTask.doLast添加一个Action了，自然它会等到grdle myTask的时候才会执行！</p>
<p>现在想起这个事情我还是很愤怒，API都说很清楚了……而且，如果你把Gradle当做编程框架来看，对于我们这些程序员来说，写这几百行代码，那还算是事嘛？？</p>
<p>转自：<a href="http://www.infoq.com/cn/articles/android-in-depth-gradle" target="_blank" rel="external">http://www.infoq.com/cn/articles/android-in-depth-gradle</a></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	 <url>
        <loc>http://github.eagleweb.xyz/2015/11/29/about-github-create-self-blog/</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[关于用Github搭建个人博客的记录]]></title>
                <content><![CDATA[<p>一些搭建博客过程中遇到的问题和技巧</p>
<p> 刚开始的时候以为不是自己的空间，会有一些Github或者其他的网站的推广的一些东西，要知道那些东西是会让我有那么点不爽的存在~<br><br><br>当然，后来事实证明我是错的==<br><a id="more"></a></p>
<h2 id="初识">初识</h2><p>  起初是<a href="http://www.xiaoduanguoguo.com/" target="_blank" rel="external">小段果果</a>给我说的这个东西<br><br><br>  刚开始的时候以为不是自己的空间，会有一些Github或者其他的网站的推广的一些东西，要知道那些东西是会让我有那么点不爽的存在~<br><br><br>当然，后来事实证明我是错的==</p>
<h2 id="开始">开始</h2><p>根据<a href="http://www.xiaoduanguoguo.com/" target="_blank" rel="external">小段果果</a>给的网站<a href="http://www.jianshu.com/p/5368aa49e193" title="使用Github建立个人博客" target="_blank" rel="external">【使用Github建立个人博客】</a>，准备开始搭建个人博客。<br><br><br>开始按照那篇文章中的步骤一步步来做。我这里只是再对那个文档进行一些补充。不会很详细的讲解每个步骤。<br></p>
<h3 id="注册Github账号">注册Github账号</h3><p><a href="https://github.com/" target="_blank" rel="external">注册Github</a>(之前已经有了就可免去此步骤)<br></p>
<h3 id="安装本机所需环境">安装本机所需环境<br></h3><p> 官方：<br><a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a><br><br> <a href="http://git-scm.com/" target="_blank" rel="external">Git</a><br></p>
<p>百度云：<br><a href="http://pan.baidu.com/s/15JnVw" target="_blank" rel="external">Node.js下载</a> 密码：os3g<br><br><a href="http://pan.baidu.com/s/1ntMrMYX" target="_blank" rel="external">Git下载</a> 密码：g4cx<br></p>
<p>两个东西的安装都是一路下一步就可以的。（友情提示：最好先安装Node.js，然后再安装Git。)<br></p>
<h3 id="安装hexo">安装hexo</h3><p>两个东西都安装完之后，在某个地方创建一个文件夹(这个文件夹可以理解为你以后的工作空间，尽量取名为hexo吧~在下文中称这个目录为“本地空间”)，然后刚创建的文件夹内点击鼠标右键，会有一个Git Bash选项(右键菜单中没有git bash选项，可以进入开始菜单找到git bash，然后通过cd进入相应目录执行命令。)，选择Git Bash；之后会弹出一个类似命令行的窗口，在那个命令行窗口里输入下面这条命令来安装hexo(下文中的“执行命令”，都是在这样的方式里打开的命令行窗口里执行)：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure></p>
<p><br>（如果提示找不到npm，可能是因为你先安装的git，然后安装的Node.js造成的。也有可能Node.js版本不对。可以将你电脑上的GitheNode.js都卸载掉，然后下载我给的两个地址下载，之后先安装Node.js，最后安装Git；或许会解决问题）<br><br>安装完hexo之后还要继续输入命令对hexo进行初始化：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p>
<p>咱们一般都不会重复的造轮子，所以安装依赖包啥的其他步骤请参照<a href="http://www.jianshu.com/p/5368aa49e193" title="使用Github建立个人博客" target="_blank" rel="external">【使用Github建立个人博客】</a></p>
<p>博客中的：<br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure></p>
<p>这两个命令可以直接用： <br><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g </span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>替代</p>
<h3 id="SSH配置">SSH配置</h3><p>跟着步骤生成一个ssh-key就好</p>
<h2 id="连接Github">连接Github</h2><h3 id="先在Github上创建一个仓库">先在Github上创建一个仓库</h3><p>仓库名字是由固定格式的：<br><br><br> 用户名.github.io<br><br>例如我的用户名是w1216220482，新建的仓库就必须是：w1216220482.github.io<br><br>这个仓库名新建好后同时也是一个二级域名。而且能正常访问的。<br><br>相关资料：<a href="https://help.github.com/articles/using-jekyll-with-pages/#troubleshooting" target="_blank" rel="external">Github Page help！</a></p>
<h3 id="给项目添加ssh-key">给项目添加ssh-key</h3><p>找不到添加地方的童鞋，在右上角你的头像的处点击出的下拉菜单里有个setting，点进去后就能看到SSH keys这个项了。<br>把id_rsa.pub里的所有内容复制到key的文本框里，标题不用填写，最后点击Add key就OK了</p>
<h3 id="配置hexo中github地址">配置hexo中github地址</h3><p>在本地空间根目录下有_config.yml文件，找到里面的deploy字段(如果没有就添加)，我们需要配置该字段的三个属性：type、repository、branch<br><br><code>注意：在_config.yml配置文件中的所有字段后面都要加空格，否则可能会出一些问题！</code><br><br><br>例如我的用户名是w1216220482，则配置为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: http://github.com/w1216220482/w1216220482.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<p>关于type属性，我之前看网上是用的是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>: github</span><br></pre></td></tr></table></figure></p>
<p>但是使用时发现不能成功连接上github，所以用了另一个方法：<br><br>将github修改为git，然后在本地工作空间右键Git Bash，输入命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>
<p>可成功连接Github。(猜测可能是缺少github插件，这个方法是将github插件修改为了git插件。可能不用修改为git，但是需要输入命令：npm install –save hexo-github才能正常使用~但是没看到教程说过，所以也没试)</p>
<p>酱紫之后呢，应该就能成功的连接上Github了，测试测试：<br><br>之前创建仓库的时候是空的，现在在本地空间右键Git Bash出来的命令窗口里输入hexo clean，执行成功后输入hexo g，等待执行完成，然后输入hexo d，等待上传，过程中会让你输入账户名和密码，依次输入账户名和密码就ok，(我输入的是github的账户名和密码，因为我配置ssh的时候用的是github的账户名和密码，所以不会搞错，但是SSH配置的是其他账户名密码的童鞋就自己测试吧！~看看是哪个用户名密码，知道的好心人可以顺便在下方评论！(网上说是配置SSH时输入的的密码))<br>执行结束后在浏览器里查看那个创建的项目中是否有了数据，如果有了，就说明成功连上了，如果没有~检查下哪里出了问题！重新测试下！</p>
<h2 id="博客相关设置">博客相关设置</h2><h3 id="主题挑选">主题挑选</h3><p>之前初始化hexo的时候就默认自带了一套主题，如果不喜欢，可以在<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo主题库</a>中进行挑选。(点击图片是预览，点击名称是到github上)<br></p>
<h3 id="更换主题">更换主题</h3><p>在上一步挑选完毕之后，点击你选上的那个主题的名称，进入该主题的github，里面都会有该主题的安装方式和说明。<br>例如我用的主题是<a href="https://github.com/wuchong/jacman" target="_blank" rel="external">jacman</a>，里面会有它的一些安装、配置和说明！<br>我想要从默认主题切换为jacman主题，就需要在hexo(本地工作空间)根目录的_config.yml文件中配置博客使用的主题，找到文件中theme字段，将后面的主题名称(默认是landscape)更改为jacman，你可以在你的本地空间中看到themes目录，里面是你所拥有的主题。文件夹的名称就是主题的名称。</p>
<h3 id="本地预览你的博客效果">本地预览你的博客效果</h3><p>执行命令开启本地服务器：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure></p>
<p>然后在浏览器输入：<a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 查看效果（这个地址是默认的配置地址，如果修改过相关的配置，就不一样(都会修改，地址肯定自己也知道)）；</p>
<h3 id="整站配置文件说明">整站配置文件说明</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line">title: 博客标题</span><br><span class="line">subtitle: 次标题</span><br><span class="line">description: 描述</span><br><span class="line">author: 作者</span><br><span class="line">email: 邮箱</span><br><span class="line">language: zh-CN</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line">url: http://www.freehao123.com <span class="comment">#域名</span></span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/ <span class="comment">#URL结构</span></span><br><span class="line">tag_dir: tags <span class="comment">#标签</span></span><br><span class="line">archive_dir: archives <span class="comment">#汇总</span></span><br><span class="line">category_dir: categories <span class="comment">#分类</span></span><br><span class="line">code_dir: downloads/code</span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line">new_post_name: :title.md <span class="comment"># 新的文章名</span></span><br><span class="line">default_layout: post <span class="comment">#New的默认</span></span><br><span class="line">auto_spacing: <span class="literal">false</span> <span class="comment"># Add spaces between asian     characters and western characters</span></span><br><span class="line">titlecase: <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line">external_link: <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line">max_open_file: <span class="number">100</span></span><br><span class="line">multi_thread: <span class="literal">true</span></span><br><span class="line">filename_<span class="keyword">case</span>: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="literal">false</span></span><br><span class="line">highlight: <span class="comment">#代码高亮</span></span><br><span class="line"><span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  line_number: <span class="literal">true</span></span><br><span class="line"> tab_replace:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag #分类与标签</span></span><br><span class="line">default_category: uncategorized </span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Archives </span></span><br><span class="line"><span class="comment">## 2: Enable pagination #激活分页</span></span><br><span class="line"><span class="comment">## 1: Disable pagination #禁止分页</span></span><br><span class="line"><span class="comment">## 0: Fully Disable #全部禁止</span></span><br><span class="line">archive: <span class="number">1</span></span><br><span class="line">category: <span class="number">1</span></span><br><span class="line">tag: <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">port: <span class="number">4000</span> <span class="comment">#预览端口</span></span><br><span class="line">logger: <span class="literal">false</span></span><br><span class="line">logger_format:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format #时间格式</span></span><br><span class="line">date_format: MMM D YYYY</span><br><span class="line">time_format: H:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination #分页数</span></span><br><span class="line">per_page: <span class="number">10</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus #Disqus评论</span></span><br><span class="line">disqus_shortname: freehao123 </span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line">theme: jacman  <span class="comment">#主题</span></span><br><span class="line">exclude_generator:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment #上传</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git <span class="comment">#上传方式</span></span><br><span class="line">  repository: http://github.com/w1216220482/w1216220482.github.io.git <span class="comment">#仓库地址</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<h2 id="扩展：绑定域名">扩展：绑定域名</h2><p>当然，此步骤不是必须的，只是作为扩展了解。因为你现在已经可以通过 你的Github用户名.github.io 来访问你的博客了！所以这个不是必要步骤=</p>
<h3 id="前奏">前奏</h3><p>我记得我应该在上文某个犄角旮旯里说过。新建的仓库，<font color="red"><strong>必须</strong></font>按照那个格式来建。<br>为啥乳此的强调这个呢，这个故事有点长，就不说了(NND，LZ当初搞了一上午没找到原因~C)</p>
<h3 id="准备">准备</h3><p>1，能正常解析的域名一个<br><br>2，已经搞定的Github二级域名博客一个<br><br>3，那啥那啥那啥<br><br>好，有了这三样东西，你就可以开始你的独立域名之旅了~</p>
<h3 id="域名解析">域名解析</h3><p>域名相关的知识，这里就不过多的阐述了。<br><br>将你的博客域名解析一个CNAME类型的，地址为你在github的博客地址(用户名.github.io)。记得去掉http://。<br></p>
<h3 id="配置Github仓库">配置Github仓库</h3><p>解析完成后在你的博客所在仓库的根目录点击+号，新建一个文件<br><img src="http://i.imgur.com/ejEWzI5.png" alt=""><br><br>文件名叫CNAME，然后文件的内容是你刚解析到你博客地址的域名（解析的那个域名就写哪个域名，是二级域名就填写二级域名，例如：github.eagleweb.xyz）</p>
<p>乳此完成之后，等待一会儿，访问你刚才的域名。如果看到了你的博客，就说明成功了，如果看到说连接错误，那就是失败了。</p>
<p><br></p>
<p>每次写完博客提交之后，CNAME文件总是会消失的问题：<br>解决办法：将CNAME文件放到主题包的source目录下面。(答案来自<a href="http://wdbaoge.com/" target="_blank" rel="external">无敌小包哥</a>)</p>
<h2 id="博客插件的安装与卸载">博客插件的安装与卸载</h2><p><a href="https://hexo.io/plugins/" target="_blank" rel="external">插件库</a><br><br>安装插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install 插件名称 --save</span><br></pre></td></tr></table></figure></p>
<p>卸载插件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall 插件名称 --save</span><br></pre></td></tr></table></figure></p>
<h2 id="博客搭建相关资料">博客搭建相关资料</h2><h3 id="搭建前准备">搭建前准备</h3><p><a href="https://github.com" target="_blank" rel="external">Github</a><br><br></p>
<h3 id="hexo相关">hexo相关</h3><p><a href="http://zipperary.com/categories/hexo/" target="_blank" rel="external">hexo系列指南</a><br><br><a href="http://www.jianshu.com/p/5368aa49e193" target="_blank" rel="external">使用Github建立个人博客</a><br><br><a href="http://www.freehao123.com/hexo-node-js/" target="_blank" rel="external">Hexo免费静态博客安装和使用方法-基于Node.js高效率静态博客程序</a><br><br><br><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客</a><br><br><br><a href="http://www.pchou.info/web-build/2014/07/04/build-github-blog-page-08.html" target="_blank" rel="external">一步步在Github上创建博客主页-最新版</a><br></p>
<h3 id="博客配置相关">博客配置相关</h3><p><a href="https://hexo.io/plugins/" target="_blank" rel="external">插件库</a><br><br><br><a href="https://hexo.io/themes/" target="_blank" rel="external">主题库</a><br><br><br><a href="http://zn.baidu.com" target="_blank" rel="external">百度站内搜索</a><br><br><a href="http://tongji.baidu.com" target="_blank" rel="external">百度统计</a><br><br><a href="http://www.jiathis.com/" target="_blank" rel="external">jiathis分享</a><br><br><a href="http://duoshuo.com/" target="_blank" rel="external">多说社会化评论</a><br></p>
<h3 id="Markdown快速入门">Markdown快速入门</h3><p><a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown快速入门</a><br></p>
]]></content>
            </display>
        </data>
    </url>
	
	 
	
	
	   
	<url>
        <loc>http://github.eagleweb.xyz/tags/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[tags]]></title>
                <content><![CDATA[<p>.</p>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/search/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title></title>
                <content><![CDATA[<script type="text/javascript">(function(){document.write(unescape('%3Cdiv id="bdcs"%3E%3C/div%3E'));var bdcs = document.createElement('script');bdcs.type = 'text/javascript';bdcs.async = true;bdcs.src = 'http://znsv.baidu.com/customer_search/api/js?sid=13039785338213961459' + '&plate_url=' + encodeURIComponent(window.location.href) + '&t=' + Math.ceil(new Date()/3600000);var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(bdcs, s);})();</script>

<p><div id="bdcs-frame-box"></div></p>
<script type="text/javascript">
var bdcsFrameSid="13039785338213961459";
var bdcsFrameWidth = 552;
var bdcsFrameWt = 1;
var bdcsFrameHt = 1;
var bdcsFrameResultNum = 10;
var bdcsFrameBgColor = "#ffffff";
</script>
<script type="text/javascript" src="http://zhannei.baidu.com/static/js/iframe.js"></script>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/googlee6fab509e0e3c496.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title></title>
                <content><![CDATA[google-site-verification: googlee6fab509e0e3c496.html]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/categories/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[categories]]></title>
                <content><![CDATA[<p>.</p>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/about/index.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title><![CDATA[菜鹰帅帅]]></title>
                <content><![CDATA[<p>大家好，我是菜鹰帅帅。</p>
<p>————— 游戏 才刚刚开始！<br><br><br><br><br></p>
<p>正在进行的作品：</p>
<p><a href="http://www.mumayi.com/android-9.html" target="_blank" rel="external">M桌面 http://www.mumayi.com/android-9.html</a><br><br></p>
<p>个人无聊编写的小玩意：<br><br>暂不公布</p>
]]></content>
            </display>
        </data>
    </url>
    
	<url>
        <loc>http://github.eagleweb.xyz/404.html</loc>
        <priority>0.5</priority>
        <data>
            <display>
                <title></title>
                <content><![CDATA[
<script type="text/javascript" src="http://www.qq.com/404/search_children.js" charset="utf-8" homepageurl="http://github.eagleweb.xyz/" homepagename="回到我的主页"></script>]]></content>
            </display>
        </data>
    </url>
    
  
</urlset>